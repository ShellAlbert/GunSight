<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>The X Keyboard Extension:</title><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><style xmlns="" type="text/css">/*
 * Copyright (c) 2011 Gaetan Nadon
 * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Shared stylesheet for X.Org documentation translated to HTML format
 * http://www.sagehill.net/docbookxsl/UsingCSS.html
 * http://www.w3schools.com/css/default.asp
 * https://addons.mozilla.org/en-US/firefox/addon/web-developer/developers
 * https://addons.mozilla.org/en-US/firefox/addon/font-finder/
 */

/*
 * The sans-serif fonts are considered more legible on a computer screen
 * http://dry.sailingissues.com/linux-equivalents-verdana-arial.html
 *
 */
body {
  font-family: "Bitstream Vera Sans", "DejaVu Sans", Tahoma, Geneva, Arial, Sans-serif;
  /* In support of using "em" font size unit, the w3c recommended method */
  font-size: 100%;
}

/*
 * Selection: all elements requiring mono spaced fonts.
 *
 * The family names attempt to match the proportionally spaced font
 * family names such that the same font name is used for both.
 * We'd like to use Bitstream, for example, in both proportionally and
 * mono spaced font text.
 */
.command,
.errorcode,
.errorname,
.errortype,
.filename,
.funcsynopsis,
.function,
.parameter,
.programlisting,
.property,
.screen,
.structname,
.symbol,
.synopsis,
.type
{
  font-family:  "Bitstream Vera Sans Mono", "DejaVu Sans Mono", Courier, "Liberation Mono", Monospace;
}

/*
 * Books have a title page, a preface, some chapters and appendices,
 * a glossary, an index and a bibliography, in that order.
 *
 * An Article has no preface and no chapters. It has sections, appendices,
 * a glossary, an index and a bibliography.
 */

/*
 * Selection: book main title and subtitle
 */
div.book>div.titlepage h1.title,
div.book>div.titlepage h2.subtitle {
  text-align: center;
}

/*
 * Selection: article main title and subtitle
 */
div.article>div.titlepage h2.title,
div.article>div.titlepage h3.subtitle,
div.article>div.sect1>div.titlepage h2.title,
div.article>div.section>div.titlepage h2.title {
  text-align: center;
}

/*
 * Selection: various types of authors and collaborators, individuals or corporate
 *
 * These authors are not always contained inside an authorgroup.
 * They can be contained inside a lot of different parent types where they might
 * not be centered.
 * Reducing the margin at the bottom makes a visual separation between authors
 * We specify here the ones on the title page, others may be added based on merit.
 */
div.titlepage .authorgroup,
div.titlepage .author,
div.titlepage .collab,
div.titlepage .corpauthor,
div.titlepage .corpcredit,
div.titlepage .editor,
div.titlepage .othercredit {
  text-align: center;
  margin-bottom: 0.25em;
}

/*
 * Selection: the affiliation of various types of authors and collaborators,
 * individuals or corporate.
 */
div.titlepage .affiliation {
  text-align: center;
}

/*
 * Selection: product release information (X Version 11, Release 7)
 *
 * The releaseinfo element can be contained inside a lot of different parent
 * types where it might not be centered.
 * We specify here the one on the title page, others may be added based on merit.
 */
div.titlepage p.releaseinfo {
  font-weight: bold;
  text-align: center;
}

/*
 * Selection: publishing date
 */
div.titlepage .pubdate {
  text-align: center;
}

/*
 * The legal notices are displayed in smaller sized fonts
 * Justification is only supported in IE and therefore not requested.
 *
 */
.legalnotice {
  font-size: small;
  font-style: italic;
}

/*
 * For documentation having multiple licenses, the copyright and legalnotice
 * elements sequence cannot instantiated multiple times.
 * The copyright notice and license text are therefore coded inside a legalnotice
 * element. The role attribute on the paragraph is used to allow styling of the
 * copyright notice text which should not be italicized.
 */
p.multiLicensing {
  font-style: normal;
  font-size: medium;
}

/*
 * Selection: book or article main ToC title
 * A paragraph is generated for the title rather than a level 2 heading.
 * We do not want to select chapters sub table of contents, only the main one
 */
div.book>div.toc>p,
div.article>div.toc>p {
  font-size: 1.5em;
  text-align: center;
}

/*
 * Selection: major sections of a book or an article
 *
 * Unlike books, articles do not have a titlepage element for appendix.
 * Using the selector "div.titlepage h2.title" would be too general.
 */
div.book>div.preface>div.titlepage h2.title,
div.book>div.chapter>div.titlepage h2.title,
div.article>div.sect1>div.titlepage h2.title,
div.article>div.section>div.titlepage h2.title,
div.book>div.appendix>div.titlepage h2.title,
div.article>div.appendix h2.title,
div.glossary>div.titlepage h2.title,
div.index>div.titlepage h2.title,
div.bibliography>div.titlepage h2.title {
   /* Add a border top over the major parts, just like printed books */
   /* The Gray color is already used for the ruler over the main ToC. */
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: Gray;
  /* Put some space between the border and the title */
  padding-top: 0.2em;
  text-align: center;
}

/*
 * A Screen is a verbatim environment for displaying text that the user might
 * see on a computer terminal. It is often used to display the results of a command.
 *
 * http://www.css3.info/preview/rounded-border/
 */
.screen {
  background: #e0ffff;
  border-width: 1px;
  border-style: solid;
  border-color: #B0C4DE;
  border-radius: 1.0em;
  /* Browser's vendor properties prior to CSS 3 */
  -moz-border-radius: 1.0em;
  -webkit-border-radius: 1.0em;
  -khtml-border-radius: 1.0em;
  margin-left: 1.0em;
  margin-right: 1.0em;
  padding: 0.5em;
}

/*
 * Emphasis program listings with a light shade of gray similar to what
 * DocBook XSL guide does: http://www.sagehill.net/docbookxsl/ProgramListings.html
 * Found many C API docs on the web using like shades of gray.
 */
.programlisting {
  background: #F4F4F4;
  border-width: 1px;
  border-style: solid;
  border-color: Gray;
  padding: 0.5em;
}

/*
 * Emphasis functions synopsis using a darker shade of gray.
 * Add a border such that it stands out more.
 * Set the padding so the text does not touch the border.
 */
.funcsynopsis, .synopsis {
  background: #e6e6fa;
  border-width: 1px;
  border-style: solid;
  border-color: Gray;
  clear: both;
  margin: 0.5em;
  padding: 0.25em;
}

/*
 * Selection: paragraphs inside synopsis
 *
 * Removes the default browser margin, let the container set the padding.
 * Paragraphs are not always used in synopsis
 */
.funcsynopsis p,
.synopsis p {
  margin: 0;
  padding: 0;
}

/*
 * Selection: variable lists, informal tables and tables
 *
 * Note the parameter name "variablelist.as.table" in xorg-xhtml.xsl
 * A table with rows and columns is constructed inside div.variablelist
 *
 * Set the left margin so it is indented to the right
 * Display informal tables with single line borders
 */
table {
  margin-left: 0.5em;
  border-collapse: collapse;
}

/*
 * Selection: paragraphs inside tables
 *
 * Removes the default browser margin, let the container set the padding.
 * Paragraphs are not always used in tables
 */
td p {
  margin: 0;
  padding: 0;
}

/*
 * Add some space between the left and right column.
 * The vertical alignment helps the reader associate a term
 * with a multi-line definition.
 */
td, th {
  padding-left: 1.0em;
  padding-right: 1.0em;
  vertical-align: top;
}

.warning {
  border: 1px solid red;
  background: #FFFF66;
  padding-left: 0.5em;
}
</style></head><body><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="xkblib"></a>The X Keyboard Extension:</h1></div><div><h2 class="subtitle">Library Specification</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Amber</span> <span class="othername">J.</span> <span class="surname">Benson</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Gary</span> <span class="surname">Aitken</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Erik</span> <span class="surname">Fortune</span></h3><div class="affiliation"><span class="orgname">Silicon Graphics, Inc<br /></span></div></div><div class="author"><h3 class="author"><span class="firstname">Donna</span> <span class="surname">Converse</span></h3><div class="affiliation"><span class="orgname">X Consortium, Inc<br /></span></div></div><div class="author"><h3 class="author"><span class="firstname">George</span> <span class="surname">Sachs</span></h3><div class="affiliation"><span class="orgname">Hewlett-Packard Company<br /></span></div></div><div class="author"><h3 class="author"><span class="firstname">Will</span> <span class="surname">Walker</span></h3><div class="affiliation"><span class="orgname">Digital Equipment Corporation<br /></span></div></div></div></div><div><p class="releaseinfo">X Version 11, Release 7.7</p></div><div><p class="copyright">Copyright © 1995, 1996 X Consortium Inc., Silicon Graphics Inc., Hewlett-Packard Company, Digital Equipment Corporation</p></div><div><div class="legalnotice"><a id="idm41"></a><p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the “Software”),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
</p><p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
</p><p>
THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p><p>
Except as contained in this notice, the names of the X Consortium, Silicon
Graphics Inc., Hewlett-Packard Company, and Digital Equipment Corporation
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.
</p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="preface"><a href="#acknowledgement">Acknowledgement</a></span></dt><dt><span class="chapter"><a href="#Overview">1. Overview</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Core_X_Protocol_Support_for_Keyboards">Core X Protocol Support for Keyboards</a></span></dt><dt><span class="sect1"><a href="#Xkb_Keyboard_Extension_Support_for_Keyboards">Xkb Keyboard Extension Support for Keyboards</a></span></dt><dt><span class="sect1"><a href="#Xkb_Extension_Components">Xkb Extension Components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Groups_and_Shift_Levels">Groups and Shift Levels</a></span></dt><dt><span class="sect2"><a href="#Radio_Groups">Radio Groups</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Client_Types">Client Types</a></span></dt><dt><span class="sect1"><a href="#Compatibility_With_the_Core_Protocol">Compatibility With the Core Protocol</a></span></dt><dt><span class="sect1"><a href="#Additional_Protocol_Errors">Additional Protocol Errors</a></span></dt><dt><span class="sect1"><a href="#Extension_Library_Functions">Extension Library Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Error_Indications">Error Indications</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Initialization_and_General_Programming_Information">2. Initialization and General Programming Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Extension_Header_Files">Extension Header Files</a></span></dt><dt><span class="sect1"><a href="#Extension_Name">Extension Name</a></span></dt><dt><span class="sect1"><a href="#Determining_Library_Compatibility">Determining Library Compatibility</a></span></dt><dt><span class="sect1"><a href="#Initializing_the_Keyboard_Extension">Initializing the Keyboard Extension</a></span></dt><dt><span class="sect1"><a href="#Disabling_the_Keyboard_Extension">Disabling the Keyboard Extension</a></span></dt><dt><span class="sect1"><a href="#Protocol_Errors">Protocol Errors</a></span></dt><dt><span class="sect1"><a href="#Display_and_Device_Specifications_in_Function_Calls">Display and Device Specifications in Function Calls</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Data_Structures">3. Data Structures</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Allocating_Xkb_Data_Structures">Allocating Xkb Data Structures</a></span></dt><dt><span class="sect1"><a href="#Adding_Data_and_Editing_Data_Structures">Adding Data and Editing Data Structures</a></span></dt><dt><span class="sect1"><a href="#Making_Changes_to_the_Servers_Keyboard_Description">Making Changes to the Server’s Keyboard Description</a></span></dt><dt><span class="sect1"><a href="#Tracking_Keyboard_Changes_in_the_Server">Tracking Keyboard Changes in the Server</a></span></dt><dt><span class="sect1"><a href="#Freeing_Data_Structures">Freeing Data Structures</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Xkb_Events">4. Xkb Events</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Xkb_Event_Types">Xkb Event Types</a></span></dt><dt><span class="sect1"><a href="#Xkb_Event_Data_Structures">Xkb Event Data Structures</a></span></dt><dt><span class="sect1"><a href="#Selecting_Xkb_Events">Selecting Xkb Events</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Event_Masks">Event Masks</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Unified_Xkb_Event_Type">Unified Xkb Event Type</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Keyboard_State">5. Keyboard State</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Keyboard_State_Description">Keyboard State Description</a></span></dt><dt><span class="sect1"><a href="#Changing_the_Keyboard_State">Changing the Keyboard State</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Changing_Modifiers">Changing Modifiers</a></span></dt><dt><span class="sect2"><a href="#Changing_Groups">Changing Groups</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Determining_Keyboard_State">Determining Keyboard State</a></span></dt><dt><span class="sect1"><a href="#Tracking_Keyboard_State">Tracking Keyboard State</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Complete_Keyboard_Description">6. Complete Keyboard Description</a></span></dt><dd><dl><dt><span class="sect1"><a href="#The_XkbDescRec_Structure">The XkbDescRec Structure</a></span></dt><dt><span class="sect1"><a href="#Obtaining_a_Keyboard_Description_from_the_Server">Obtaining a Keyboard Description from the Server</a></span></dt><dt><span class="sect1"><a href="#Tracking_Changes_to_the_Keyboard_Description_in_the_Server">Tracking Changes to the Keyboard Description in the Server</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_a_Keyboard_Description">Allocating and Freeing a Keyboard Description</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Virtual_Modifiers">7. Virtual Modifiers</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Virtual_Modifier_Names_and_Masks">Virtual Modifier Names and Masks</a></span></dt><dt><span class="sect1"><a href="#Modifier_Definitions">Modifier Definitions</a></span></dt><dt><span class="sect1"><a href="#Binding_Virtual_Modifiers_to_Real_Modifiers">Binding Virtual Modifiers to Real Modifiers</a></span></dt><dt><span class="sect1"><a href="#Virtual_Modifier_Key_Mapping">Virtual Modifier Key Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Inactive_Modifier_Sets">Inactive Modifier Sets</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Conventions">Conventions</a></span></dt><dt><span class="sect1"><a href="#Example">Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Indicators">8. Indicators</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Indicator_Names">Indicator Names</a></span></dt><dt><span class="sect1"><a href="#Indicator_Data_Structures">Indicator Data Structures</a></span></dt><dd><dl><dt><span class="sect2"><a href="#XkbIndicatorRec">XkbIndicatorRec</a></span></dt><dt><span class="sect2"><a href="#XkbIndicatorMapRec">XkbIndicatorMapRec</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Information_About_Indicators">Getting Information About Indicators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Getting_Indicator_State">Getting Indicator State</a></span></dt><dt><span class="sect2"><a href="#Getting_Indicator_Information_by_Index">Getting Indicator Information by Index</a></span></dt><dt><span class="sect2"><a href="#Getting_Indicator_Information_by_Name">Getting Indicator Information by Name</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Changing_Indicator_Maps_and_State">Changing Indicator Maps and State</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Effects_of_Explicit_Changes_on_Indicators">Effects of Explicit Changes on Indicators</a></span></dt><dt><span class="sect2"><a href="#Changing_Indicator_Maps_by_Index">Changing Indicator Maps by Index</a></span></dt><dt><span class="sect2"><a href="#Changing_Indicator_Maps_by_Name">Changing Indicator Maps by Name</a></span></dt><dt><span class="sect2"><a href="#XkbIndicatorChangesRec">The XkbIndicatorChangesRec Structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Changes_to_Indicator_State_or_Map">Tracking Changes to Indicator State or Map</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Indicator_Maps">Allocating and Freeing Indicator Maps</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Bells">9. Bells</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Bell_Names">Bell Names</a></span></dt><dt><span class="sect1"><a href="#Audible_Bells">Audible Bells</a></span></dt><dt><span class="sect1"><a href="#Bell_Functions">Bell Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Generating_Named_Bells">Generating Named Bells</a></span></dt><dt><span class="sect2"><a href="#Generating_Named_Bell_Events">Generating Named Bell Events</a></span></dt><dt><span class="sect2"><a href="#Forcing_a_Server_Generated_Bell">Forcing a Server-Generated Bell</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Detecting_Bells">Detecting Bells</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Keyboard_Controls">10. Keyboard Controls</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Controls_that_Enable_and_Disable_Other_Controls">Controls that Enable and Disable Other Controls</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_EnabledControls_Control">The EnabledControls Control</a></span></dt><dt><span class="sect2"><a href="#The_AutoReset_Control">The AutoReset Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Control_for_Bell_Behavior">Control for Bell Behavior</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_AudibleBell_Control">The AudibleBell Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_Repeat_Key_Behavior">Controls for Repeat Key Behavior</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_PerKeyRepeat_Control">The PerKeyRepeat Control</a></span></dt><dt><span class="sect2"><a href="#The_RepeatKeys_Control">The RepeatKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_DetectableAutorepeat_Control">The DetectableAutorepeat Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls">Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)</a></span></dt><dt><span class="sect1"><a href="#Controls_for_Using_the_Mouse_from_the_Keyboard">Controls for Using the Mouse from the Keyboard</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_MouseKeys_Control">The MouseKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_MouseKeysAccel_Control">The MouseKeysAccel Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_Better_Keyboard_Access_by_Physically_ImpairedPersons">Controls for Better Keyboard Access by Physically Impaired
Persons</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_AccessXKeys_Control">The AccessXKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_AccessXTimeout_Control">The AccessXTimeout Control</a></span></dt><dt><span class="sect2"><a href="#The_AccessXFeedback_Control">The AccessXFeedback Control</a></span></dt><dt><span class="sect2"><a href="#AccessXNotify_Events">AccessXNotify Events</a></span></dt><dt><span class="sect2"><a href="#StickyKeys_RepeatKeys_and_MouseKeys_Events">StickyKeys, RepeatKeys, and MouseKeys Events</a></span></dt><dt><span class="sect2"><a href="#The_SlowKeys_Control">The SlowKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_BounceKeys_Control">The BounceKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_StickyKeys_Control">The StickyKeys Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_General_Keyboard_Mapping">Controls for General Keyboard Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_GroupsWrap_Control">The GroupsWrap Control</a></span></dt><dt><span class="sect2"><a href="#The_IgnoreLockMods_Control">The IgnoreLockMods Control</a></span></dt><dt><span class="sect2"><a href="#The_IgnoreGroupLock_Control">The IgnoreGroupLock Control</a></span></dt><dt><span class="sect2"><a href="#The_InternalMods_Control">The InternalMods Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#The_XkbControlsRec_Structure">The XkbControlsRec Structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm6021"></a></span></dt></dl></dd><dt><span class="sect1"><a href="#Querying_Controls">Querying Controls</a></span></dt><dt><span class="sect1"><a href="#Changing_Controls">Changing Controls</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_XkbControlsChangesRec_Structure">The XkbControlsChangesRec Structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Changes_to_Keyboard_Controls">Tracking Changes to Keyboard Controls</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_an_XkbControlsRec">Allocating and Freeing an XkbControlsRec</a></span></dt><dt><span class="sect1"><a href="#The_Miscellaneous_Per_client_Controls">The Miscellaneous Per-client Controls</a></span></dt></dl></dd><dt><span class="chapter"><a href="#X_Library_Controls">11. X Library Controls</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Controls_Affecting_Keycode_to_String_Translation">Controls Affecting Keycode-to-String Translation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ForceLatin1Lookup">ForceLatin1Lookup</a></span></dt><dt><span class="sect2"><a href="#ConsumeLookupMods">ConsumeLookupMods</a></span></dt><dt><span class="sect2"><a href="#AlwaysConsumeShiftAndLock">AlwaysConsumeShiftAndLock</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_Affecting_Compose_Processing">Controls Affecting Compose Processing</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ConsumeKeysOnComposeFail">ConsumeKeysOnComposeFail</a></span></dt><dt><span class="sect2"><a href="#ComposeLED">ComposeLED</a></span></dt><dt><span class="sect2"><a href="#BeepOnComposeFail">BeepOnComposeFail</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_Effecting_Event_Delivery">Controls Effecting Event Delivery</a></span></dt><dd><dl><dt><span class="sect2"><a href="#IgnoreNewKeyboards">IgnoreNewKeyboards</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Manipulating_the_Library_Controls">Manipulating the Library Controls</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Determining_Which_Library_Controls_are_Implemented">Determining Which Library Controls are Implemented</a></span></dt><dt><span class="sect2"><a href="#Determining_the_State_of_the_Library_Controls">Determining the State of the Library Controls</a></span></dt><dt><span class="sect2"><a href="#Changing_the_State_of_the_Library_Controls">Changing the State of the Library Controls</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Interpreting_Key_Events">12. Interpreting Key Events</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Effects_of_Xkb_on_the_Core_X_Library">Effects of Xkb on the Core X Library</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Effects_of_Xkb_on_Event_State">Effects of Xkb on Event State</a></span></dt><dt><span class="sect2"><a href="#Effects_of_Xkb_on_MappingNotify_Events">Effects of Xkb on MappingNotify Events</a></span></dt><dt><span class="sect2"><a href="#X_Library_Functions_Affected_by_Xkb">X Library Functions Affected by Xkb</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Xkb_Event_and_Keymap_Functions">Xkb Event and Keymap Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Keyboard_Geometry">13. Keyboard Geometry</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Shapes_and_Outlines">Shapes and Outlines</a></span></dt><dt><span class="sect1"><a href="#Sections">Sections</a></span></dt><dt><span class="sect1"><a href="#Rows_and_Keys">Rows and Keys</a></span></dt><dt><span class="sect1"><a href="#Doodads">Doodads</a></span></dt><dt><span class="sect1"><a href="#Overlay_Rows_and_Overlay_Keys">Overlay Rows and Overlay Keys</a></span></dt><dt><span class="sect1"><a href="#Drawing_a_Keyboard_Representation">Drawing a Keyboard Representation</a></span></dt><dt><span class="sect1"><a href="#Geometry_Data_Structures">Geometry Data Structures</a></span></dt><dd><dl><dt><span class="sect2"><a href="#DoodadRec_Structures">DoodadRec Structures</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Keyboard_Geometry_From_the_Server">Getting Keyboard Geometry From the Server</a></span></dt><dt><span class="sect1"><a href="#Using_Keyboard_Geometry">Using Keyboard Geometry</a></span></dt><dt><span class="sect1"><a href="#Adding_Elements_to_a_Keyboard_Geometry">Adding Elements to a Keyboard Geometry</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Geometry_Components">Allocating and Freeing Geometry Components</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Xkb_Keyboard_Mapping">14. Xkb Keyboard Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Notation_and_Terminology">Notation and Terminology</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Core_Implementation">Core Implementation</a></span></dt><dt><span class="sect2"><a href="#Xkb_Implementation">Xkb Implementation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Map_Components_from_the_Server">Getting Map Components from the Server</a></span></dt><dt><span class="sect1"><a href="#Changing_Map_Components_in_the_Server">Changing Map Components in the Server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_XkbMapChangesRec_Structure">The XkbMapChangesRec Structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Changes_to_Map_Components">Tracking Changes to Map Components</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Client_and_Server_Maps">Allocating and Freeing Client and Server Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Allocating_an_Empty_Client_Map">Allocating an Empty Client Map</a></span></dt><dt><span class="sect2"><a href="#Freeing_a_Client_Map">Freeing a Client Map</a></span></dt><dt><span class="sect2"><a href="#Allocating_an_Empty_Server_Map">Allocating an Empty Server Map</a></span></dt><dt><span class="sect2"><a href="#Freeing_a_Server_Map">Freeing a Server Map</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Xkb_Client_Keyboard_Mapping">15. Xkb Client Keyboard Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#The_XkbClientMapRec_Structure">The XkbClientMapRec Structure</a></span></dt><dt><span class="sect1"><a href="#Key_Types">Key Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_Canonical_Key_Types">The Canonical Key Types</a></span></dt><dt><span class="sect2"><a href="#Getting_Key_Types_from_the_Server">Getting Key Types from the Server</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Levels_in_a_Key_Type">Changing the Number of Levels in a Key Type</a></span></dt><dt><span class="sect2"><a href="#Copying_Key_Types">Copying Key Types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Key_Symbol_Map">Key Symbol Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Per_Key_Key_Type_Indices">Per-Key Key Type Indices</a></span></dt><dt><span class="sect2"><a href="#Per_Key_Group_Information">Per-Key Group Information</a></span></dt><dt><span class="sect2"><a href="#Key_Width">Key Width</a></span></dt><dt><span class="sect2"><a href="#Offset_in_to_the_Symbol_Map">Offset in to the Symbol Map</a></span></dt><dt><span class="sect2"><a href="#Getting_the_Symbol_Map_for_Keys_from_the_Server">Getting the Symbol Map for Keys from the Server</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Groups_and_Types_Bound_to_a_Key">Changing the Number of Groups and Types Bound to a Key</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Symbols_Bound_to_a_Key">Changing the Number of Symbols Bound to a Key</a></span></dt></dl></dd><dt><span class="sect1"><a href="#The_Per_Key_Modifier_Map">The Per-Key Modifier Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Getting_the_Per_Key_Modifier_Map_from_the_Server">Getting the Per-Key Modifier Map from the Server</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#Xkb_Server_Keyboard_Mapping">16. Xkb Server Keyboard Mapping</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Key_Actions">Key Actions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_XkbAction_Structure">The XkbAction Structure</a></span></dt><dt><span class="sect2"><a href="#The_XkbAnyAction_Structure">The XkbAnyAction Structure</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_Modifiers_State">Actions for Changing Modifiers’ State</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_Group_State">Actions for Changing Group State</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Moving_the_Pointer">Actions for Moving the Pointer</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Simulating_Pointer_Button_Press_and_Release">Actions for Simulating Pointer Button Press and Release</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_the_Pointer_Button_Simulated">Actions for Changing the Pointer Button Simulated</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Locking_Modifiers_and_Group">Actions for Locking Modifiers and Group</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_the_Active_Screen">Actions for Changing the Active Screen</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_Boolean_Controls_State">Actions for Changing Boolean Controls State</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Generating_Messages">Actions for Generating Messages</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Generating_a_Different_Keycode">Actions for Generating a Different Keycode</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Generating_DeviceButtonPress_and_DeviceButtonRelease">Actions for Generating DeviceButtonPress and DeviceButtonRelease</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Simulating_Events_from_Device_Valuators">Actions for Simulating Events from Device Valuators</a></span></dt><dt><span class="sect2"><a href="#Obtaining_Key_Actions_for_Keys_from_the_Server">Obtaining Key Actions for Keys from the Server</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Actions_Bound_to_a_Key">Changing the Number of Actions Bound to a Key</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Key_Behavior">Key Behavior</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Radio_Groups_2">Radio Groups</a></span></dt><dt><span class="sect2"><a href="#The_XkbBehavior_Structure">The XkbBehavior Structure</a></span></dt><dt><span class="sect2"><a href="#Obtaining_Key_Behaviors_for_Keys_from_the_Server">Obtaining Key Behaviors for Keys from the Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server">Explicit Components—Avoiding Automatic Remapping by the Server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Obtaining_Explicit_Components_for_Keys_from_the_Server">Obtaining Explicit Components for Keys from the Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Virtual_Modifier_Mapping">Virtual Modifier Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Obtaining_Virtual_Modifier_Bindings_from_the_Server">Obtaining Virtual Modifier Bindings from the Server</a></span></dt><dt><span class="sect2"><a href="#Obtaining_Per_Key_Virtual_Modifier_Mappings_from_the_Server">Obtaining Per-Key Virtual Modifier Mappings from the Server</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#The_Xkb_Compatibility_Map">17. The Xkb Compatibility Map</a></span></dt><dd><dl><dt><span class="sect1"><a href="#The_XkbCompatMap_Structure">The XkbCompatMap Structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Xkb_State_to_Core_Protocol_State_Transformation">Xkb State to Core Protocol State Transformation</a></span></dt><dt><span class="sect2"><a href="#Core_Keyboard_Mapping_to_Xkb_Keyboard_Mapping_Transformation">Core Keyboard Mapping to Xkb Keyboard Mapping Transformation</a></span></dt><dt><span class="sect2"><a href="#Xkb_Keyboard_Mapping_to_Core_Keyboard_Mapping_Transformations">Xkb Keyboard Mapping to Core Keyboard Mapping Transformations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Compatibility_Map_Components_From_the_Server">Getting Compatibility Map Components From the Server</a></span></dt><dt><span class="sect1"><a href="#Using_the_Compatibility_Map">Using the Compatibility Map</a></span></dt><dt><span class="sect1"><a href="#Changing_the_Servers_Compatibility_Map">Changing the Server’s Compatibility Map</a></span></dt><dt><span class="sect1"><a href="#Tracking_Changes_to_the_Compatibility_Map">Tracking Changes to the Compatibility Map</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_the_Compatibility_Map">Allocating and Freeing the Compatibility Map</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Symbolic_Names">18. Symbolic Names</a></span></dt><dd><dl><dt><span class="sect1"><a href="#The_XkbNamesRec_Structure">The XkbNamesRec Structure</a></span></dt><dt><span class="sect1"><a href="#Symbolic_Names_Masks">Symbolic Names Masks</a></span></dt><dt><span class="sect1"><a href="#Getting_Symbolic_Names_From_the_Server">Getting Symbolic Names From the Server</a></span></dt><dt><span class="sect1"><a href="#Changing_Symbolic_Names_on_the_Server">Changing Symbolic Names on the Server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm15837"></a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Name_Changes">Tracking Name Changes</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Symbolic_Names">Allocating and Freeing Symbolic Names</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Replacing_a_Keyboard_On_the_Fly">19. Replacing a Keyboard <span class="quote">“<span class="quote">On the Fly</span>”</span></a></span></dt><dt><span class="chapter"><a href="#Server_Database_of_Keyboard_Components">20. Server Database of Keyboard Components</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Component_Names">Component Names</a></span></dt><dt><span class="sect1"><a href="#Listing_the_Known_Keyboard_Components">Listing the Known Keyboard Components</a></span></dt><dt><span class="sect1"><a href="#Component_Hints">Component Hints</a></span></dt><dt><span class="sect1"><a href="#Building_a_Keyboard_Description_Using_the_Server_Database">Building a Keyboard Description Using the Server Database</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Attaching_Xkb_Actions_to_X_Input_Extension_Devices">21. Attaching Xkb Actions to X Input Extension Devices</a></span></dt><dd><dl><dt><span class="sect1"><a href="#XkbDeviceInfoRec">XkbDeviceInfoRec</a></span></dt><dt><span class="sect1"><a href="#Querying_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices">Querying Xkb Features for Non-KeyClass Input Extension Devices</a></span></dt><dt><span class="sect1"><a href="#Allocating_Initializing_and_Freeing_the_XkbDeviceInfoRecStructure">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></span></dt><dt><span class="sect1"><a href="#Setting_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices">Setting Xkb Features for Non-KeyClass Input Extension Devices</a></span></dt><dt><span class="sect1"><a href="#XkbExtensionDeviceNotify_Event">XkbExtensionDeviceNotify Event</a></span></dt><dt><span class="sect1"><a href="#Tracking_Changes_to_Extension_Devices">Tracking Changes to Extension Devices</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Debugging_Aids">22. Debugging Aids</a></span></dt><dt><span class="glossary"><a href="#glossary">Glossary</a></span></dt><dt><span class="index"><a href="#index">Index</a></span></dt></dl></div><div class="list-of-figures"><p><strong>List of Figures</strong></p><dl><dt>1.1. <a href="#figure1.1">Overall Xkb Structure</a></dt><dt>5.1. <a href="#figure5.1">Xkb State</a></dt><dt>10.1. <a href="#figure10.1">MouseKeys Acceleration</a></dt><dt>13.1. <a href="#figure13.1">Rotated Keyboard Sections</a></dt><dt>13.2. <a href="#figure13.2">Keyboard with Four Sections</a></dt><dt>13.3. <a href="#figure13.3">Rows in a Section</a></dt><dt>13.4. <a href="#figure13.4">Xkb Geometry Data Structures</a></dt><dt>13.5. <a href="#figure13.5">Xkb Geometry Data Structures (Doodads)</a></dt><dt>13.6. <a href="#figure13.6">Xkb Geometry Data Structures (Overlays)</a></dt><dt>13.7. <a href="#figure13.7">Key Surface, Shape Outlines, and Bounding Box</a></dt><dt>14.1. <a href="#figure14.1">Shift Levels and Groups</a></dt><dt>15.1. <a href="#figure15.1">Xkb Client Map</a></dt><dt>16.1. <a href="#figure16.1">Server Map Relationships</a></dt><dt>16.2. <a href="#figure16.2">Virtual Modifier Relationships</a></dt><dt>17.1. <a href="#figure17.1">Server Interaction with Types of Clients</a></dt><dt>17.2. <a href="#figure17.2">Server Derivation of State and Keyboard Mapping Components</a></dt><dt>17.3. <a href="#figure17.3">Xkb Compatibility Data Structures</a></dt><dt>20.1. <a href="#figure20.1">Building a New Keyboard Description from the Server Database</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>1.1. <a href="#table1.1">Function Error Returns Due to Extension Problems</a></dt><dt>2.1. <a href="#table2.1">Xkb Protocol Errors</a></dt><dt>2.2. <a href="#table2.2"><span class="errorname">BadKeyboard</span> Protocol Error resource_id Values</a></dt><dt>4.1. <a href="#table4.1">Xkb Event Types</a></dt><dt>4.2. <a href="#table4.2">XkbSelectEvents Mask Constants</a></dt><dt>5.1. <a href="#table5.1">Real Modifier Masks</a></dt><dt>5.2. <a href="#table5.2">Symbolic Group Names</a></dt><dt>5.3. <a href="#table5.3">XkbStateNotify Event Detail Masks</a></dt><dt>6.1. <a href="#table6.1">XkbDescRec Component References</a></dt><dt>6.2. <a href="#table6.2">Mask Bits for XkbDescRec</a></dt><dt>8.1. <a href="#table8.1">XkbIndicatorMapRec flags Field</a></dt><dt>8.2. <a href="#table8.2">XkbIndicatorMapRec which_groups and groups, Keyboard Drives
Indicator</a></dt><dt>8.3. <a href="#table8.3">XkbIndicatorMapRec which_groups and groups, Indicator Drives
Keyboard</a></dt><dt>8.4. <a href="#table8.4">XkbIndicatorMapRec which_mods and mods, Keyboard Drives Indicator</a></dt><dt>8.5. <a href="#table8.5">XkbIndicatorMapRec which_mods and mods, Indicator Drives Keyboard</a></dt><dt>9.1. <a href="#table9.1">Predefined Bells</a></dt><dt>9.2. <a href="#table9.2">Bell Sounding and Bell Event Generating</a></dt><dt>10.1. <a href="#table10.1">Xkb Keyboard Controls</a></dt><dt>10.2. <a href="#table10.2">MouseKeysAccel Fields</a></dt><dt>10.3. <a href="#table10.3">AccessXFeedback Masks</a></dt><dt>10.4. <a href="#table10.4">AccessXNotify Events</a></dt><dt>10.5. <a href="#table10.5">AccessXNotify Event Details</a></dt><dt>10.6. <a href="#table10.6">Xkb Controls</a></dt><dt>10.7. <a href="#table10.7">Controls Mask Bits</a></dt><dt>10.8. <a href="#table10.8">GroupsWrap options (groups_wrap field)</a></dt><dt>10.9. <a href="#table10.9">Access X Enable/Disable Bits (ax_options field)</a></dt><dt>11.1. <a href="#table11.1">Library Control Masks</a></dt><dt>13.1. <a href="#table13.1">Doodad Types</a></dt><dt>14.1. <a href="#table14.1">Xkb Mapping Component Masks and Convenience Functions</a></dt><dt>14.2. <a href="#table14.2">XkbMapChangesRec Masks</a></dt><dt>14.3. <a href="#table14.3">XkbAllocClientMap Masks</a></dt><dt>14.4. <a href="#table14.4">XkbAllocServerMap Masks</a></dt><dt>15.1. <a href="#table15.1">Example Key Type</a></dt><dt>15.2. <a href="#table15.2">group_info Range Normalization</a></dt><dt>15.3. <a href="#table15.3">Group Index Constants</a></dt><dt>16.1. <a href="#table16.1">Action Types</a></dt><dt>16.2. <a href="#table16.2">Modifier Action Types</a></dt><dt>16.3. <a href="#table16.3">Modifier Action Flags</a></dt><dt>16.4. <a href="#table16.4">Group Action Types</a></dt><dt>16.5. <a href="#table16.5">Group Action Flags</a></dt><dt>16.6. <a href="#table16.6">Pointer Action Types</a></dt><dt>16.7. <a href="#table16.7">Pointer Button Action Types</a></dt><dt>16.8. <a href="#table16.8">Pointer Button Action Flags</a></dt><dt>16.9. <a href="#table16.9">Pointer Default Flags</a></dt><dt>16.10. <a href="#table16.10">ISO Action Flags when XkbSA_ISODfltIsGroup is Set</a></dt><dt>16.11. <a href="#table16.11">ISO Action Flags when XkbSA_ISODfltIsGroup is Not Set</a></dt><dt>16.12. <a href="#table16.12">ISO Action Affect Field Values</a></dt><dt>16.13. <a href="#table16.13">Switch Screen Action Flags</a></dt><dt>16.14. <a href="#table16.14">Controls Action Types</a></dt><dt>16.15. <a href="#table16.15">Control Action Flags</a></dt><dt>16.16. <a href="#table16.16">Message Action Flags</a></dt><dt>16.17. <a href="#table16.17">Device Button Action Types</a></dt><dt>16.18. <a href="#table16.18">Device Button Action Flags</a></dt><dt>16.19. <a href="#table16.19">Device Valuator v&lt;n&gt;_what High Bits Values</a></dt><dt>16.20. <a href="#table16.20">Key Behaviors</a></dt><dt>16.21. <a href="#table16.21">Explicit Component Masks</a></dt><dt>17.1. <a href="#table17.1">Symbol Interpretation Match Criteria</a></dt><dt>17.2. <a href="#table17.2">Compatibility Map Component Masks</a></dt><dt>18.1. <a href="#table18.1">Symbolic Names Masks</a></dt><dt>18.2. <a href="#table18.2">XkbNameChanges Fields</a></dt><dt>19.1. <a href="#table19.1">XkbNewKeyboardNotifyEvent Details</a></dt><dt>20.1. <a href="#table20.1">Server Database Keyboard Components</a></dt><dt>20.2. <a href="#table20.2">XkbComponentNameRec Flags Bits</a></dt><dt>20.3. <a href="#table20.3">Want and Need Mask Bits and Required Names Components</a></dt><dt>20.4. <a href="#table20.4">XkbDescRec Components Returned for Values of Want &amp; Needs</a></dt><dt>21.1. <a href="#table21.1">XkbDeviceInfoRec Mask Bits</a></dt><dt>22.1. <a href="#table22.1">Debug Control Masks</a></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a id="acknowledgement"></a>Acknowledgement</h1></div></div></div><p>
This document is the result of a great deal of hard work by a great
many people. Without Erik Fortune’s work as Architect of the X
Keyboard Extension and the longtime support of Silicon Graphics
Inc. there would not be a keyboard extension.
</p><p>
We gratefully thank Will Walker and George Sachs for their help and
expertise in providing some of the content for this document, and
Digital Equipment Corporation and Hewlett-Packard for allowing them
to participate in this project, and we are deeply indebted to IBM for
providing the funding to complete this library specification.
</p><p>
Most of all, we thank Gary Aitken and Amber J. Benson for their long
hours and late nights as ultimate authors of this specification, and
for serving as authors, document editors, and XKB protocol and
implementation reviewers. Their commitment to accuracy and completeness,
their attention to detail, their keen insight, and their good natures
when working under tremendous pressure are in some measure responsible
not only for the quality of this document, but for the quality of the
Keyboard extension itself.
</p><p>
</p><div class="literallayout"><p><br />
Matt Landau<br />
Manager, X Window System<br />
X Consortium Inc.<br />
</p></div><p>
</p><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm53"></a>X Version 11, Release 7 addendum</h2></div></div></div><p>
This document is made available to you in modern formats such as HTML and PDF
thanks to the efforts of Matt Dew, who converted the original troff sources to
DocBook/XML and edited them into shape; Fernando Carrijo, who converted the
images to SVG format; Gaetan Nadon, who set up the formatting machinery in
the libX11 builds and performed further editing of the DocBook markup; and
Alan Coopersmith, who converted the DocBook tags to semantic markup and
cleaned up other formatting issues.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Overview"></a>Chapter 1. Overview</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Core_X_Protocol_Support_for_Keyboards">Core X Protocol Support for Keyboards</a></span></dt><dt><span class="sect1"><a href="#Xkb_Keyboard_Extension_Support_for_Keyboards">Xkb Keyboard Extension Support for Keyboards</a></span></dt><dt><span class="sect1"><a href="#Xkb_Extension_Components">Xkb Extension Components</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Groups_and_Shift_Levels">Groups and Shift Levels</a></span></dt><dt><span class="sect2"><a href="#Radio_Groups">Radio Groups</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Client_Types">Client Types</a></span></dt><dt><span class="sect1"><a href="#Compatibility_With_the_Core_Protocol">Compatibility With the Core Protocol</a></span></dt><dt><span class="sect1"><a href="#Additional_Protocol_Errors">Additional Protocol Errors</a></span></dt><dt><span class="sect1"><a href="#Extension_Library_Functions">Extension Library Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Error_Indications">Error Indications</a></span></dt></dl></dd></dl></div><p>
The X Keyboard Extension provides capabilities that are lacking or are
cumbersome in the core X protocol.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Core_X_Protocol_Support_for_Keyboards"></a>Core X Protocol Support for Keyboards</h2></div></div></div><p>
The core X protocol specifies the ways that the
<span class="symbol">Shift</span>,
<span class="symbol">Control</span>, and
<span class="symbol">Lock</span>
modifiers and the modifiers bound to the
<span class="keysym">Mode_switch</span> or
<span class="keysym">Num_Lock</span>
keysyms interact to generate keysyms and characters. The core protocol also
allows users to specify that a key affects one or more modifiers. This behavior
is simple and fairly flexible, but it has a number of limitations that make it
difficult or impossible to properly support many common varieties of keyboard
behavior. The limitations of core protocol support for keyboards include:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Use of a single, uniform, four-symbol mapping for all keyboard keys makes it
difficult to properly support keyboard overlays, PC-style break keys, or
keyboards that comply with ISO9995, or a host of other national and
international standards.
    </p></li><li class="listitem"><p>
A second keyboard group may be specified using a modifier, but this has side
effects that wreak havoc with client grabs and X toolkit translations.
Furthermore, this approach limits the number of keyboard groups to two.
    </p></li><li class="listitem"><p>
Poorly specified locking key behavior requires X servers to look for a few
<span class="quote">“<span class="quote">magic</span>”</span> keysyms to determine that keys should lock when pressed. This leads to
incompatibilities between X servers with no way for clients to detect
implementation differences.
    </p></li><li class="listitem"><p>
Poorly specified capitalization and control behavior requires modifications to
X library source code to support new character sets or locales and can lead to
incompatibilities between system wide and X library capitalization behavior.
    </p></li><li class="listitem"><p>
Limited interactions between modifiers specified by the core protocol make many
common keyboard behaviors difficult or impossible to implement. For example,
there is no reliable way to indicate whether or not the shift modifier should
<span class="quote">“<span class="quote">cancel</span>”</span> the lock modifier.
    </p></li><li class="listitem"><p>
The lack of any explicit descriptions for indicators, most modifiers, and other
aspects of the keyboard appearance requires clients that wish to clearly
describe the keyboard to a user to resort to a mish-mash of prior knowledge and
heuristics.
    </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Xkb_Keyboard_Extension_Support_for_Keyboards"></a>Xkb Keyboard Extension Support for Keyboards</h2></div></div></div><p>
The X Keyboard Extension makes it possible to clearly and explicitly specify
most aspects of keyboard behavior on a per-key basis. It adds the notion of a
keyboard group to the global keyboard state and provides mechanisms to more
closely track the logical and physical state of the keyboard. For
keyboard-control clients, Xkb provides descriptions and symbolic names for many
aspects of keyboard appearance and behavior.
</p><p>
In addition, the X Keyboard Extension includes additional keyboard controls
designed to make keyboards more accessible to people with movement impairments.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Xkb_Extension_Components"></a>Xkb Extension Components</h2></div></div></div><p>
The Xkb extension is composed of two parts: a server extension, and a
client-side X library extension. These consist of a loadable module that may be
activated when an X server is started and a modified version of Xlib. Both
server and Xlib versions must be at least X11 R6.
</p><p>
<a class="link" href="#figure1.1" title="Figure 1.1. Overall Xkb Structure">Figure 1.1</a> shows the overall structure of the Xkb extension:
</p><div class="figure"><a id="figure1.1"></a><p class="title"><strong>Figure 1.1. Overall Xkb Structure</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-1.svg"></object></div></div></div><br class="figure-break" /><p><a id="keyboard_description"></a>
The server portion of the Xkb extension encompasses a database of named
keyboard components, in unspecified format, that may be used to configure a
keyboard. Internally, the server maintains a
<em class="firstterm">keyboard description</em>
<a id="idm98" class="indexterm"></a>
that includes the keyboard state and configuration (mapping). By
<span class="quote">“<span class="quote">keyboard</span>”</span> we
mean the logical keyboard device, which includes not only the physical keys,
but also potentially a set of up to 32 indicators (usually LEDs) and bells.
</p><p>
The keyboard description is a composite of several different data structures,
each of which may be manipulated separately. When manipulating the server
components, the design allows partial components to be transmitted between the
server and a client. The individual components are shown in <a class="link" href="#figure1.1" title="Figure 1.1. Overall Xkb Structure">Figure 1.1</a>.
</p><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term"><a class="link" href="#Xkb_Client_Keyboard_Mapping" title="Chapter 15. Xkb Client Keyboard Mapping">Client Map</a></span></p></td><td><p>
The key mapping information needed to convert arbitrary keycodes to symbols.
      </p></td></tr><tr><td><p><span class="term"><a class="link" href="#Xkb_Server_Keyboard_Mapping" title="Chapter 16. Xkb Server Keyboard Mapping">Server Map</a></span></p></td><td><p>
The key mapping information categorizing keys by functionality (which keys are
modifiers, how keys behave, and so on).
      </p></td></tr><tr><td><p><span class="term"><a class="link" href="#Keyboard_Controls" title="Chapter 10. Keyboard Controls">Controls</a></span></p></td><td><p>
Client configurable quantities effecting how the keyboard behaves, such as
repeat behavior and modifications for people with movement impairments.
      </p></td></tr><tr><td><p><span class="term"><a class="link" href="#Indicators" title="Chapter 8. Indicators">Indicators</a></span></p></td><td><p>
The mapping of behavior to indicators.
      </p></td></tr><tr><td><p><span class="term"><a class="link" href="#Keyboard_Geometry" title="Chapter 13. Keyboard Geometry">Geometry</a></span></p></td><td><p>
A complete description of the physical keyboard layout, sufficient to draw a
representation of the keyboard.
      </p></td></tr><tr><td><p><span class="term"><a class="link" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Names</a></span></p></td><td><p>
A mapping of names to various aspects of the keyboard such as individual
virtual modifiers, indicators, and bells.
      </p></td></tr><tr><td><p><span class="term"><a class="link" href="#The_Xkb_Compatibility_Map" title="Chapter 17. The Xkb Compatibility Map">Compatibility Map</a></span></p></td><td><p>
The definition of how to map core protocol keyboard state to Xkb keyboard state.
      </p></td></tr></tbody></table></div><p>
A client application interrogates and manipulates the keyboard by reading and
writing portions of the server description for the keyboard. In a typical
sequence a client would fetch the current information it is interested in,
modify it, and write it back. If a client wishes to track some portion of the
keyboard state, it typically maintains a local copy of the portion of the
server keyboard description dealing with the items of interest and updates this
local copy from events describing state transitions that are sent by the server.
</p><p>
A client may request the server to reconfigure the keyboard either by sending
explicit reconfiguration instructions to it, or by telling it to load a new
configuration from its database of named components. Partial reconfiguration
and incremental reconfiguration are both supported.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Groups_and_Shift_Levels"></a>Groups and Shift Levels</h3></div></div></div><p>
The graphic characters or control functions that may be accessed by one key are
logically arranged in groups and levels. See <a class="link" href="#Notation_and_Terminology" title="Notation and Terminology">section 14.1</a> for a complete
description of groups and levels.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Radio_Groups"></a>Radio Groups</h3></div></div></div><p>
<a id="idm148" class="indexterm"></a>
<a id="idm150" class="indexterm"></a>
A <em class="firstterm">radio group</em>
is a set of keys whose behavior simulates a set of radio buttons.
Once a key in a radio group is pressed, it stays logically depressed until
another key in the group is pressed, at which point the previously depressed
key is logically released. Consequently, at most one key in a radio group can
be logically depressed at one time. A radio group is defined by a radio group
index, an optional name, and by assigning each key in the radio group
<span class="symbol">XkbKB_RadioGroup</span>
behavior and the radio group index.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Client_Types"></a>Client Types</h2></div></div></div><p>
This specification differentiates between three different classes of client
applications:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Xkb-aware applications
    </p><p>
These applications make specific use of Xkb functionality and APIs not present
in the core protocol.
    </p></li><li class="listitem"><p>
Xkb-capable applications
    </p><p>
These applications make no use of Xkb extended functionality and Application
Programming Interfaces (APIs) directly. However, they are linked with a version
of Xlib that includes Xkb and indirectly benefit from some of Xkb’s
features.
    </p></li><li class="listitem"><p>
Xkb-unaware applications
    </p><p>
These applications make no use of Xkb extended functionality or APIs and
require Xkb’s functionality to be mapped to core Xlib functionality to
operate properly.
    </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Compatibility_With_the_Core_Protocol"></a>Compatibility With the Core Protocol</h2></div></div></div><p>
Because the Xkb extension allows a keyboard to be configured in ways not
foreseen by the core protocol, and because Xkb-unaware clients are allowed to
connect to a server using the Xkb extension, there must be a means of
converting between the Xkb domain and the core protocol. The Xkb server
extension maintains a compatibility map as part of its keyboard description;
this map controls the conversion of Xkb generated events to core protocol
events and the results of core protocol requests to appropriate Xkb state and
configuration.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Additional_Protocol_Errors"></a>Additional Protocol Errors</h2></div></div></div><p>
The Xkb extension adds a single protocol error,
<span class="errorname">BadKeyboard</span>,
to the core protocol error set. See <a class="link" href="#Protocol_Errors" title="Protocol Errors">section 2.6</a> for a discussion of the
<span class="errorname">BadKeyboard</span>
protocol error.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Extension_Library_Functions"></a>Extension Library Functions</h2></div></div></div><p>
The X Keyboard Extension replaces the core protocol definition of a keyboard
with a more comprehensive one. The X Keyboard Extension library interfaces are
included in Xlib.<a href="#ftn.idm180" class="footnote" id="idm180"><sup class="footnote">[1]</sup></a>
</p><p>
Xlib detects the presence of the X Keyboard server extension and uses Xkb
protocol to replace some standard X library functions related to the keyboard.
If an application uses only standard X library functions to examine the
keyboard or process key events, it should not need to be modified when linked
with an X library containing the X keyboard extension. All of the
keyboard-related X library functions have been modified to automatically use
Xkb protocol when the server extension is present.
</p><p>
The Xkb extension adds library interfaces to allow a client application to
directly manipulate the new capabilities.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Error_Indications"></a>Error Indications</h3></div></div></div><a id="idm186" class="indexterm"></a><p>
Xkb functions that communicate with the X server check to be sure the Xkb
extension has been properly initialized prior to doing any other operations. If
the extension has not been properly initialized or the application, library,
and server versions are incompatible, these functions return an error
indication as shown in <a class="link" href="#table1.1" title="Table 1.1. Function Error Returns Due to Extension Problems">Table 1.1</a>.
Because of this test,
<span class="errorname">BadAccess</span>
and
<span class="errorname">BadMatch</span>
(due to incompatible versions) protocol errors should normally not be
generated.
</p><div class="table"><a id="table1.1"></a><p class="title"><strong>Table 1.1. Function Error Returns Due to Extension Problems</strong></p><div class="table-contents"><table class="table" summary="Function Error Returns Due to Extension Problems" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Functions return type</th><th align="left">Return value</th></tr></thead><tbody><tr><td align="left">pointer to a structure</td><td align="left"><span class="symbol">NULL</span></td></tr><tr><td align="left">Bool</td><td align="left"><span class="symbol">False</span></td></tr><tr><td align="left">Status</td><td align="left"><span class="errorname">BadAccess</span></td></tr></tbody></table></div></div><br class="table-break" /><p>
Many Xkb functions do not actually communicate with the X server; they only
require processing in the client-side portion of the library. Furthermore, some
applications may never actually need to communicate with the server; they
simply use the Xkb library capabilities. The functions that do not communicate
with the server return either a pointer to a structure, a Bool, or a Status.
These functions check that the application has queried the Xkb library version
and return the values shown in <a class="link" href="#table1.1" title="Table 1.1. Function Error Returns Due to Extension Problems">Table 1.1</a>
if it has not.
</p></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm180" class="footnote"><p><a href="#idm180" class="para"><sup class="para">[1] </sup></a>
X11R6.1 is the first release by the X Consortium, Inc., that includes the X
Keyboard Extension in Xlib. X11R6 included work in progress on this extension
as nonstandard additions to the library.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Initialization_and_General_Programming_Information"></a>Chapter 2. Initialization and General Programming Information</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Extension_Header_Files">Extension Header Files</a></span></dt><dt><span class="sect1"><a href="#Extension_Name">Extension Name</a></span></dt><dt><span class="sect1"><a href="#Determining_Library_Compatibility">Determining Library Compatibility</a></span></dt><dt><span class="sect1"><a href="#Initializing_the_Keyboard_Extension">Initializing the Keyboard Extension</a></span></dt><dt><span class="sect1"><a href="#Disabling_the_Keyboard_Extension">Disabling the Keyboard Extension</a></span></dt><dt><span class="sect1"><a href="#Protocol_Errors">Protocol Errors</a></span></dt><dt><span class="sect1"><a href="#Display_and_Device_Specifications_in_Function_Calls">Display and Device Specifications in Function Calls</a></span></dt></dl></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Extension_Header_Files"></a>Extension Header Files</h2></div></div></div><p>
The following include files are part of the Xkb standard:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<code class="filename">&lt;X11/XKBlib.h&gt;</code>
    </p><p><code class="filename">XKBlib.h</code>
is the main header file for Xkb; it declares constants, types, and
functions.
    </p></li><li class="listitem"><p>
<code class="filename">&lt;X11/extensions/XKBstr.h&gt;</code>
    </p><p>
<code class="filename">XKBstr.h</code> declares types and
constants for Xkb. It is included automatically from
<code class="filename">&lt;X11/XKBlib.h&gt;</code>;
you should never need to reference it directly in your application code.
    </p></li><li class="listitem"><p>
<code class="filename">&lt;X11/extensions/XKB.h&gt;</code>
    </p><p>
<code class="filename">XKB.h</code>
defines constants for Xkb. It is included automatically from
<code class="filename">&lt;X11/XKBstr.h&gt;</code>;
you should never need to reference it directly in your application code.
    </p></li><li class="listitem"><p>
<code class="filename">&lt;X11/extensions/XKBgeom.h&gt;</code>
   </p><p><code class="filename">XKBgeom.h</code>
declares types, symbolic constants, and functions for manipulating
keyboard geometry descriptions.
    </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Extension_Name"></a>Extension Name</h2></div></div></div><a id="idm246" class="indexterm"></a><p>
The name of the Xkb extension is given in
<code class="filename">&lt;X11/extensions/Xkb.h&gt;</code>:

</p><pre class="programlisting">
#define XkbName "XKEYBOARD"
</pre><p>
</p><p>
Most extensions to the X protocol are initialized by calling
<code class="function">XInitExtension</code>
and passing the extension name. However, as explained in <a class="link" href="#Initializing_the_Keyboard_Extension" title="Initializing the Keyboard Extension">section 2.4</a>, Xkb
requires a more complex initialization sequence, and a client program should
not call
<code class="function">XInitExtension</code>
directly.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Determining_Library_Compatibility"></a>Determining Library Compatibility</h2></div></div></div><p>
If an application is dynamically linked, both the X server and the client-side
X library must contain the Xkb extension in order for the client to use the Xkb
extension capabilities. Therefore a dynamically linked application must check
both the library and the server for compatibility before using Xkb function
calls. A properly written program must check for compatibility between the
version of the Xkb library that is dynamically loaded and the one used when the
application was built. It must then check the server version for compatibility
with the version of Xkb in the library.
</p><p>
If your application is statically linked, you must still check for server
compatibility and may check library compatibility. (It is possible to compile
against one set of header files and link against a different, incompatible,
version of the library, although this should not normally occur.)
</p><p>
To determine the compatibility of a library at runtime, call
<code class="function">XkbLibraryVersion</code>.
</p><a id="idm262" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLibraryVersion"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbLibraryVersion</strong>(</code>int *<var class="pdparam">lib_major_in_out</var>, int *<var class="pdparam">lib_minor_in_out</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>lib_major_in_out</code></em>
    </span></p></td><td><p>
        specifies and returns the major Xkb library version.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>lib_minor_in_out</code></em>
    </span></p></td><td><p>
        specifies and returns the minor Xkb library version.
      </p></td></tr></tbody></table></div><p>
Pass the symbolic value
<span class="symbol">XkbMajorVersion</span>
in
<em class="parameter"><code>lib_major_in_out</code></em>
and
<span class="symbol">XkbMinorVersion</span>
in
<em class="parameter"><code>lib_minor_in_out</code></em>.
These arguments represent the version of the library used at compile time.
The
<code class="function">XkbLibraryVersion</code>
function backfills the major and minor version numbers of the library used at
run time in
<em class="parameter"><code>lib_major_in_out</code></em>
and
<em class="parameter"><code>lib_minor_in_out</code></em>.
If the versions of the compile time and run time libraries are compatible,
<code class="function">XkbLibraryVersion</code>
returns
<span class="symbol">True</span>,
otherwise, it returns
<span class="symbol">False</span>.
</p><p>
In addition, in order to use the Xkb extension, you must ensure that the
extension is present in the server and that the server supports the version of
the extension expected by the client. Use
<code class="function">XkbQueryExtension</code>
to do this, as described in the next section.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Initializing_the_Keyboard_Extension"></a>Initializing the Keyboard Extension</h2></div></div></div><p>
Call
<code class="function">XkbQueryExtension</code>
to check for the presence and compatibility of the extension in the server and
to initialize the extension. Because of potential version mismatches, you
cannot use the generic extension mechanism functions
(<code class="function">XQueryExtension</code>
and
<code class="function">XInitExtension</code>)
for checking for the presence of, and initializing the Xkb extension.
</p><p>
You must call
<code class="function">XkbQueryExtension</code>
or
<code class="function">XkbOpenDisplay</code>
before using any other Xkb library interfaces, unless such usage is explicitly
allowed in the interface description in this document. The exceptions are:
<code class="function">XkbIgnoreExtension</code>,
<code class="function">XkbLibraryVersion</code>,
and a handful of audible-bell functions. You should not use any other Xkb
functions if the extension is not present or is uninitialized. In general,
calls to Xkb library functions made prior to initializing the Xkb extension
cause
<span class="errorname">BadAccess</span>
protocol errors.
<a id="idm309" class="indexterm"></a>
<a id="idm313" class="indexterm"></a>
</p><p>
<code class="function">XkbQueryExtension</code>
both determines whether a compatible Xkb extension is present in the X server
and initializes the extension when it is present.
</p><a id="idm318" class="indexterm"></a><div class="funcsynopsis"><a id="XkbQueryExtension"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbQueryExtension</strong>(</code>Display *<var class="pdparam">dpy</var>, int *<var class="pdparam">opcode_rtrn</var>, int *<var class="pdparam">event_rtrn</var>, int *<var class="pdparam">error_rtrn</var>, int *<var class="pdparam">major_in_out</var>, int *<var class="pdparam">minor_in_out</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>opcode_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the major extension opcode
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>event_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the extension base event code
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>error_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the extension base error code
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>major_in_out</code></em>
    </span></p></td><td><p>
        compile time lib major version in, server major version out
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>minor_in_out</code></em>
    </span></p></td><td><p>
        compile time lib min version in, server minor version out
      </p></td></tr></tbody></table></div><p>
The
<code class="function">XkbQueryExtension</code>
function determines whether a compatible version of the X Keyboard Extension
is present in the server. If a compatible extension is present,
<code class="function">XkbQueryExtension</code>
returns
<span class="symbol">True</span>;
otherwise, it returns
<span class="symbol">False</span>.
</p><p>
If a compatible version of Xkb is present,
<code class="function">XkbQueryExtension</code>
initializes the extension. It backfills the major opcode for the keyboard
extension in
<em class="parameter"><code>opcode_rtrn</code></em>,
the base event code in
<em class="parameter"><code>event_rtrn</code></em>,
the base error code in
<em class="parameter"><code>error_rtrn</code></em>,
and the major and minor version numbers of the extension in
<em class="parameter"><code>major_in_out</code></em>
and
<em class="parameter"><code>minor_in_out</code></em>.
The major opcode is reported in the
<em class="structfield"><code>req_major</code></em>
fields of some Xkb events. For a discussion of the base event code, see
<a class="link" href="#Xkb_Event_Types" title="Xkb Event Types">section 4.1</a>.
</p><p>
As a convenience, you can use the function
<code class="function">XkbOpenDisplay</code>
to perform these three tasks at once: open a connection to an X server, check
for a compatible version of the Xkb extension in both the library and the
server, and initialize the extension for use.
</p><a id="idm384" class="indexterm"></a><div class="funcsynopsis"><a id="XkbOpenDisplay"></a><p><code class="funcdef">Display *<strong class="fsfunc">XkbOpenDisplay</strong>(</code>char *<var class="pdparam">display_name</var>, int *<var class="pdparam">event_rtrn</var>, int *<var class="pdparam">error_rtrn</var>, int *<var class="pdparam">major_in_out</var>, int *<var class="pdparam">minor_in_out</var>, int *<var class="pdparam">reason_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display_name</code></em>
    </span></p></td><td><p>
        hardware display name, which determines the display and
        communications domain to be used
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>event_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the extension base event code
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>error_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the extension base error code
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>major_in_out</code></em>
    </span></p></td><td><p>
        compile time lib major version in, server major version out
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>minor_in_out</code></em>
    </span></p></td><td><p>
        compile time lib minor version in, server minor version out
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>reason_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with a status code
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbOpenDisplay</code>
is a convenience function that opens an X display connection and initializes
the X keyboard extension. In all cases, upon return
<em class="parameter"><code>reason_rtrn</code></em>
contains a status value indicating success or the type of failure. If
<em class="parameter"><code>major_in_out</code></em>
and
<em class="parameter"><code>minor_in_out</code></em>
are not
<span class="symbol">NULL</span>,
<code class="function">XkbOpenDisplay</code>
first calls
<code class="function">XkbLibraryVersion</code>
to determine whether the client library is compatible, passing it the values
pointed to by
<em class="parameter"><code>major_in_out</code></em>
and
<em class="parameter"><code>minor_in_out</code></em>.
If the library is incompatible,
<code class="function">XkbOpenDisplay</code>
backfills
<em class="parameter"><code>major_in_out</code></em>
and
<em class="parameter"><code>minor_in_out</code></em>
with the major and minor extension versions of the library being used and
returns
<span class="symbol">NULL</span>.
If the library is compatible,
<code class="function">XkbOpenDisplay</code>
next calls
<code class="function">XOpenDisplay</code>
with the
<em class="parameter"><code>display_name</code></em>.
If this fails, the function returns
<span class="symbol">NULL</span>.
If successful,
<code class="function">XkbOpenDisplay</code>
calls
<code class="function">XkbQueryExtension</code>
and
backfills the major and minor Xkb server extension version numbers in
<em class="parameter"><code>major_in_out</code></em>
and
<em class="parameter"><code>minor_in_out</code></em>.
If the server extension version is not compatible with the library extension
version or if the server extension is not present,
<code class="function">XkbOpenDisplay</code>
closes the display and returns
<span class="symbol">NULL</span>.
When successful, the function returns the display connection.
</p><p>
The possible values for
<em class="parameter"><code>reason_rtrn</code></em> are:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="errorname">XkbOD_BadLibraryVersion</span>
indicates
<code class="function">XkbLibraryVersion</code>
returned
<span class="symbol">False</span>.
  </p></li><li class="listitem"><p>
<span class="errorname">XkbOD_ConnectionRefused</span>
indicates the display could not be opened.
  </p></li><li class="listitem"><p>
<span class="errorname">XkbOD_BadServerVersion</span>
indicates the library and the server have incompatible extension versions.
  </p></li><li class="listitem"><p>
<span class="errorname">XkbOD_NonXkbServer</span>
indicates the extension is not present in the X server.
  </p></li><li class="listitem"><p>
<span class="errorname">XkbOD_Success</span>
indicates that the function succeeded.
  </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Disabling_the_Keyboard_Extension"></a>Disabling the Keyboard Extension</h2></div></div></div><p>
If a server supports the Xkb extension, the X library normally implements
preXkb keyboard functions using the Xkb keyboard description and state. The
server Xkb keyboard state may differ from the preXkb keyboard state. This
difference does not affect most clients, but there are exceptions. To allow
these clients to work properly, you may instruct the extension not to use Xkb
functionality.
</p><p>
Call
<code class="function">XkbIgnoreExtension</code>
to prevent core X library keyboard functions from using the X Keyboard
Extension. You must call
<code class="function">XkbIgnoreExtension</code>
before you open a server connection; Xkb does not provide a way to enable or
disable use of the extension once a connection is established.
</p><a id="idm484" class="indexterm"></a><div class="funcsynopsis"><a id="XkbIgnoreExtension"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbIgnoreExtension</strong>(</code>Bool <var class="pdparam">ignore</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>ignore</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> means ignore the extension
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbIgnoreExtension</code>
tells the X library whether to use the X Keyboard Extension on any
subsequently opened X display connections. If ignore is
<span class="symbol">True</span>,
the library does not initialize the Xkb extension when it opens a new
display. This forces the X server to use compatibility mode and communicate
with the client using only core protocol requests and events. If ignore is
<span class="symbol">False</span>,
the library treats subsequent calls to
<code class="function">XOpenDisplay</code>
normally and uses Xkb extension requests, events, and state. Do not explicitly
use Xkb on a connection for which it is disabled.
<code class="function">XkbIgnoreExtension</code>
returns
<span class="symbol">False</span>
if it was unable to apply the ignore request.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Protocol_Errors"></a>Protocol Errors</h2></div></div></div><a id="idm509" class="indexterm"></a><p>
Many of the Xkb extension library functions described in this document can
cause the X server to report an error, referred to in this document as a
<span class="errorname">Bad<em class="replaceable"><code>Xxx</code></em></span>
protocol error, where
<em class="replaceable"><code>Xxx</code></em>
is some name. These errors are fielded in the normal manner, by the default
Xlib error handler or one replacing it. Note that X protocol errors are not
necessarily reported immediately because of the buffering of X protocol
requests in Xlib and the server.
</p><p>
<a class="link" href="#table2.1" title="Table 2.1. Xkb Protocol Errors">Table 2.1</a>
lists the protocol errors that can be generated, and their causes.
</p><div class="table"><a id="table2.1"></a><p class="title"><strong>Table 2.1. Xkb Protocol Errors</strong></p><div class="table-contents"><table class="table" summary="Xkb Protocol Errors" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Error</th><th align="left">Cause</th></tr></thead><tbody><tr><td align="left"><span class="errorname">BadAccess</span></td><td align="left">
<p>
The Xkb extension has not been properly initialized
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadKeyboard</span></td><td align="left">
<p>
The device specified was not a valid core or input extension device
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadImplementation</span></td><td align="left">
<p>
Invalid reply from server
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadAlloc</span></td><td align="left">
<p>
Unable to allocate storage
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadMatch</span></td><td align="left">
<p>
A compatible version of Xkb was not available in the server or an argument has
correct type and range, but is otherwise invalid
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadValue</span></td><td align="left">
<p>
An argument is out of range
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadAtom</span></td><td align="left">
<p>
A name is neither a valid Atom or
<span class="symbol">None</span>
</p>
    </td></tr><tr><td align="left"><span class="errorname">BadDevice</span></td><td align="left">
<p>
Device, Feedback Class, or Feedback ID invalid
</p>
    </td></tr></tbody></table></div></div><br class="table-break" /><p><a id="BadKeyboard"></a>
<a id="idm569" class="indexterm"></a>
<a id="idm573" class="indexterm"></a>
The Xkb extension adds a single protocol error,
<span class="errorname">BadKeyboard</span>,
to the core protocol error set. This error code will be reported as the
<em class="parameter"><code>error_rtrn</code></em>
when
<code class="function">XkbQueryExtension</code>
is called. When a
<span class="errorname">BadKeyboard</span>
error is reported in an
<span class="structname">XErrorEvent</span>,
additional information is reported in the
<em class="structfield"><code>resourceid</code></em>
field. The most significant byte of the
<em class="structfield"><code>resource_id</code></em>
is a further refinement of the error cause, as defined in
<a class="link" href="#table2.2" title="Table 2.2. BadKeyboard Protocol Error resource_id Values">Table 2.2</a>. The least
significant byte will contain the device, class, or feedback ID as indicated in
the table.
</p><div class="table"><a id="table2.2"></a><p class="title"><strong>Table 2.2. <span class="errorname">BadKeyboard</span> Protocol Error resource_id Values</strong></p><div class="table-contents"><table class="table" summary="BadKeyboard Protocol Error resource_id Values" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">high-order byte</th><th align="left">value</th><th align="left">meaning</th><th align="left">low-order byte</th></tr></thead><tbody><tr><td align="left"><span class="errorname">XkbErr_BadDevice</span></td><td align="left">0xff</td><td align="left">
<p>
device not found
</p>
    </td><td align="left">device ID</td></tr><tr><td align="left"><span class="errorname">XkbErr_BadClass</span></td><td align="left">0xfe</td><td align="left">
<p>
device found, but it is of the wrong class
</p>
    </td><td align="left">class ID</td></tr><tr><td align="left"><span class="errorname">XkbErr_BadId</span></td><td align="left">0xfd</td><td align="left">
<p>
device found, class ok, but device does not contain a feedback with the
indicated ID
</p>
    </td><td align="left">feedback ID</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Display_and_Device_Specifications_in_Function_Calls"></a>Display and Device Specifications in Function Calls</h2></div></div></div><p>
Where a connection to the server is passed as an argument (Display*) and an
<span class="type">XkbDescPtr</span>
is also passed as an argument, the Display* argument must match the
<em class="structfield"><code>dpy</code></em>
field of the
<span class="structname">XkbDescRec</span>
pointed to by the
<span class="type">XkbDescPtr</span>
argument, or else the
<em class="structfield"><code>dpy</code></em>
field of the
<span class="structname">XkbDescRec</span>
must be
<span class="symbol">NULL</span>.
If they don’t match or the
<em class="structfield"><code>dpy</code></em>
field is not
<span class="symbol">NULL</span>,
a
<span class="errorname">BadMatch</span>
error is returned (either in the return value or a backfilled
<span class="type">Status</span>
variable). Upon successful return, the
<em class="structfield"><code>dpy</code></em>
field of the
<span class="structname">XkbDescRec</span>
always contains the Display* value passed in.
</p><p>
The Xkb extension can communicate with the X input extension if it is present.
Consequently, there can potentially be more than one input device connected to
the server. Most Xkb library calls that require communicating with the server
involve both a server connection (Display *
<em class="structfield"><code>dpy</code></em>)
and a device identifier (unsigned int
<em class="structfield"><code>device_spec</code></em>).
In some cases, the device identifier is implicit and is taken as the
<em class="structfield"><code>device_spec</code></em>
field of an
<span class="structname">XkbDescRec</span>
structure passed as an argument.
</p><p><a id="XkbUseCoreKbd"></a>
<a id="idm642" class="indexterm"></a>
The device identifier can specify any X input extension device with a
<span class="symbol">KeyClass</span>
component, or it can specify the constant,
<span class="symbol">XkbUseCoreKbd</span>.
The use of
<span class="symbol">XkbUseCoreKbd</span>
allows applications to indicate the core keyboard without having to determine
its device identifier.
</p><p>
Where an Xkb device identifier is passed as an argument and an
<span class="type">XkbDescPtr</span>
is also passed as an argument, if either the argument or the
<span class="structname">XkbDescRec</span>
<em class="structfield"><code>device_spec</code></em>
field is
<span class="symbol">XkbUseCoreKbd</span>,
and if the function returns successfully, the
<span class="type">XkbDescPtr</span>
<em class="structfield"><code>device_spec</code></em>
field will have been converted from
<span class="symbol">XkbUseCoreKbd</span>
to a real Xkb device ID. If the function does not complete successfully, the
<em class="structfield"><code>device_spec</code></em>
field remains unchanged. Subsequently, the device id argument must match the
<em class="structfield"><code>device_spec</code></em>
field of the
<span class="type">XkbDescPtr</span>
argument. If they don’t match, a
<span class="errorname">BadMatch</span>
error is returned (either in the return value or a backfilled
<span class="type">Status</span>
variable).
</p><p>
When the Xkb extension in the server hands an application a device identifier
to use for the keyboard, that ID is the input extension identifier for the
device if the server supports the X Input Extension. If the server does not
support the input extension, the meaning of the identifier is undefined — the
only guarantee is that when you use
<span class="symbol">XkbUseCoreKbd</span>,
<span class="symbol">XkbUseCoreKbd</span>
will work and the identifier returned by the server will refer to the core
keyboard device.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Data_Structures"></a>Chapter 3. Data Structures</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Allocating_Xkb_Data_Structures">Allocating Xkb Data Structures</a></span></dt><dt><span class="sect1"><a href="#Adding_Data_and_Editing_Data_Structures">Adding Data and Editing Data Structures</a></span></dt><dt><span class="sect1"><a href="#Making_Changes_to_the_Servers_Keyboard_Description">Making Changes to the Server’s Keyboard Description</a></span></dt><dt><span class="sect1"><a href="#Tracking_Keyboard_Changes_in_the_Server">Tracking Keyboard Changes in the Server</a></span></dt><dt><span class="sect1"><a href="#Freeing_Data_Structures">Freeing Data Structures</a></span></dt></dl></div><p>
An Xkb keyboard description consists of a variety of data structures, each of
which describes some aspect of the keyboard. Although each data structure has
its own peculiarities, there are a number of features common to nearly all Xkb
structures. This chapter describes these common features and techniques for
manipulating them.
</p><p>
Many Xkb data structures are interdependent; changing a field in one might
require changes to others. As an additional complication, some Xkb library
functions allocate related components as a group to reduce fragmentation and
allocator overhead. In these cases, simply allocating and freeing fields of Xkb
structures might corrupt program memory. Creating and destroying such
structures or keeping them properly synchronized during editing is complicated
and error prone.
</p><p>
Xkb provides functions and macros to allocate and free all major data
structures. You should use them instead of allocating and freeing the
structures yourself.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_Xkb_Data_Structures"></a>Allocating Xkb Data Structures</h2></div></div></div><p>
Xkb provides functions, known as allocators, to create and initialize Xkb data
structures. In most situations, the Xkb functions that read a keyboard
description from the server call these allocators automatically. As a result,
you will seldom have to directly allocate or initialize Xkb data structures.
</p><p>
However, if you need to enlarge an existing structure or construct a keyboard
definition from scratch, you may need to allocate and initialize Xkb data
structures directly. Each major Xkb data structure has its own unique
allocator. The allocator functions share common features: allocator functions
for structures with optional components take as an input argument a mask of
subcomponents to be allocated. Allocators for data structures containing
variable-length data take an argument specifying the initial length of the data.
</p><p>
You may call an allocator to change the size of the space allocated for
variable-length data. When you call an allocator with an existing data
structure as a parameter, the allocator does not change the data in any of the
fields, with one exception: variable-length data might be moved. The allocator
resizes the allocated memory if the current size is too small. This normally
involves allocating new memory, copying existing data to the newly allocated
memory, and freeing the original memory. This possible reallocation is
important to note because local variables pointing into Xkb data structures
might be invalidated by calls to allocator functions.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Adding_Data_and_Editing_Data_Structures"></a>Adding Data and Editing Data Structures</h2></div></div></div><p>
You should edit most data structures via the Xkb-supplied helper functions and
macros, although a few data structures can be edited directly. The helper
functions and macros make sure everything is initialized and interdependent
values are properly updated for those Xkb structures that have
interdependencies. As a general rule, if there is a helper function or macro to
edit the data structure, use it. For example, increasing the width of a type
requires you to resize every key that uses that type. This is complicated and
ugly, which is why there’s an
<code class="function">XkbResizeKeyType</code>
function.
</p><p>
Many Xkb data structures have arrays whose size is reported by two fields. The
first field, whose name is usually prefixed by
<span class="emphasis"><em>sz_</em></span>,
represents the total number of elements that can be stored in the array. The
second field, whose name is usually prefixed by
<span class="emphasis"><em>num_</em></span>,
specifies the number of elements currently stored there. These arrays
typically represent data whose total size cannot always be determined when the
array is created. In these instances, the usual way to allocate space and add
data is as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Call the allocator function with some arbitrary size, as a hint.
    </p></li><li class="listitem"><p>
For those arrays that have an
<code class="function">Xkb...Add...</code>
function, call it each time you want to add new data to the array. The
function expands the array if necessary.
    </p></li></ul></div><p>
For example, call:

</p><pre class="programlisting">
XkbAllocGeomShapes(geom,4)
</pre><p>

to say <span class="quote">“<span class="quote">I’ll need space for four new shapes in this geometry.</span>”</span>
This makes sure that
<em class="structfield"><code>sz_shapes</code></em>
−
<em class="structfield"><code>num_shapes</code></em>
&gt;= 4, and resizes the shapes array if it isn’t. If this function
succeeds, you are guaranteed to have space for the number of shapes you need.
</p><p>
When you call an editing function for a structure, you do not need to check for
space, because the function automatically checks the
<span class="emphasis"><em>sz_</em></span>
and
<span class="emphasis"><em>num_</em></span>
fields of the array, resizes the array if necessary, adds the entry to the
array, and then updates the
<span class="emphasis"><em>num_</em></span>
field.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Making_Changes_to_the_Servers_Keyboard_Description"></a>Making Changes to the Server’s Keyboard Description</h2></div></div></div><p>
In Xkb, as in the core protocol, the client and server have independent copies
of the data structures that describe the keyboard. The recommended way to
change some aspect of the keyboard mapping in the X server is to edit a local
copy of the Xkb keyboard description and then send only the changes to the X
server. This method helps eliminate the need to transfer the entire keyboard
description or even an entire data structure for only minor changes.
</p><p>
To help you keep track of the changes you make to a local copy of the keyboard
description, Xkb provides separate special
<em class="firstterm">changes</em>
<a id="idm701" class="indexterm"></a>
data structures for each major Xkb data structure. These data structures do
not contain the actual changed values: they only indicate the changes that have
been made to the structures that actually describe the keyboard.
</p><p>
When you wish to change the keyboard description in the server, you first
modify a local copy of the keyboard description and then flag the modifications
in an appropriate changes data structure. When you finish editing the local
copy of the keyboard description, you pass your modified version of the
keyboard description and the modified changes data structure to an Xkb
function. This function uses the modified keyboard description and changes
structure to pass only the changed information to the server. Note that
modifying the keyboard description but not setting the appropriate flags in the
changes data structure causes indeterminate behavior.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Keyboard_Changes_in_the_Server"></a>Tracking Keyboard Changes in the Server</h2></div></div></div><p>
The server reports all changes in its keyboard description to any interested
clients via special Xkb events. Just as clients use special changes data
structures to change the keyboard description in the server, the server uses
special changes data structures to tell a client what changed in the server’s
keyboard description.
</p><p>
Unlike clients, however, the server does not always pass the new values when it
reports changes to its copy of the keyboard description. Instead, the server
only passes a changes data structure when it reports changes to its keyboard
description. This is done for efficiency reasons — some clients do not always
need to update their copy of the keyboard description with every report from
the server.
</p><p>
When your client application receives a report from the server indicating the
keyboard description has changed, you can determine the set of changes by
passing the event to an Xkb function that <span class="quote">“<span class="quote">notes</span>”</span> event
information in the corresponding changes data structure. These
<span class="quote">“<span class="quote">note changes</span>”</span> functions are
defined for all major Xkb components, and their names have the form
<code class="function">XkbNote</code>(<em class="replaceable"><code>{Component}</code></em>Changes),
where
<em class="replaceable"><code>Component</code></em>
is the name of a major Xkb component such as
<code class="literal">Map</code>
or
<code class="literal">Names</code>.
When you want to copy these changes from the server into a local copy of the
keyboard description, use the corresponding
<code class="function">XkbGet</code>(<em class="replaceable"><code>{Component}</code></em>Changes)
function,
passing it the changes structure. The function then retrieves only the changed
structures from the server and copies the modified pieces into the local
keyboard description.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Freeing_Data_Structures"></a>Freeing Data Structures</h2></div></div></div><p>
For the same reasons you should not directly use
<code class="function">malloc</code>
to allocate Xkb data structures, you should not free Xkb data structures or
components directly using
<code class="function">free</code>
or
<code class="function">Xfree</code>.
Xkb provides functions to free the various data structures and their
components. Always use the free functions supplied by Xkb. There is no
guarantee that any particular field can be safely freed by
<code class="function">free</code>
or
<code class="function">Xfree</code>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Xkb_Events"></a>Chapter 4. Xkb Events</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Xkb_Event_Types">Xkb Event Types</a></span></dt><dt><span class="sect1"><a href="#Xkb_Event_Data_Structures">Xkb Event Data Structures</a></span></dt><dt><span class="sect1"><a href="#Selecting_Xkb_Events">Selecting Xkb Events</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Event_Masks">Event Masks</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Unified_Xkb_Event_Type">Unified Xkb Event Type</a></span></dt></dl></div><a id="idm728" class="indexterm"></a><p>
The primary way the X server communicates with clients is by sending X events
to them. Some events are sent to all clients, while others are sent only to
clients that have requested them. Some of the events that can be requested are
associated with a particular window and are only sent to those clients who have
both requested the event and specified the window in which the event occurred.
</p><p>
The Xkb extension uses events to communicate the keyboard status to interested
clients. These events are not associated with a particular window. Instead, all
Xkb keyboard status events are reported to all interested clients, regardless
of which window currently has the keyboard focus and regardless of the grab
state of the keyboard.<a href="#ftn.idm732" class="footnote" id="idm732"><sup class="footnote">[2]</sup></a>
</p><p>
The X server reports the events defined by the Xkb extension to your client
application only if you have requested them. You may request Xkb events by
calling either
<code class="function">XkbSelectEvents</code>
or
<code class="function">XkbSelectEventDetails</code>.
<code class="function">XkbSelectEvents</code>
requests Xkb events by their event type and causes them to be reported to your
client application under all circumstances. You can specify a finer granularity
for event reporting by using
<code class="function">XkbSelectEventDetails</code>;
in this case events are reported only when the specific detail conditions you
specify have been met.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Xkb_Event_Types"></a>Xkb Event Types</h2></div></div></div><p>
The Xkb Extension adds new event types to the X protocol definition. An Xkb
event type is defined by two fields in the X event data structure. One is the
<em class="structfield"><code>type</code></em>
field, containing the
<span class="emphasis"><em>base event code</em></span>.
This base event code is a value the X server assigns to each X extension at
runtime and that identifies the extension that generated the event; thus, the
event code in the
<em class="structfield"><code>type</code></em>
field identifies the event as an Xkb extension event, rather than an event
from another extension or a core X protocol event. You can obtain the base
event code via a call to
<code class="function">XkbQueryExtension</code>
or
<code class="function">XkbOpenDisplay</code>.
The second field is the Xkb event type, which contains a value uniquely
identifying each different Xkb event type. Possible values are defined by
constants declared in the header file
<code class="filename">&lt;X11/extensions/Xkb.h&gt;</code>.
</p><p>
<a class="link" href="#table4.1" title="Table 4.1. Xkb Event Types">Table 4.1</a>
lists the categories of events defined by Xkb and their associated
event types, as defined in
<code class="filename">Xkb.h</code>.
Each event is described in more detail in the section referenced for that
event.
</p><div class="table"><a id="table4.1"></a><p class="title"><strong>Table 4.1. Xkb Event Types</strong></p><div class="table-contents"><table class="table" summary="Xkb Event Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Event Type</th><th align="left">Conditions Generating Event</th><th align="left">Section</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbNewKeyboardNotify</span></td><td align="left">Keyboard geometry; keycode range change</td><td align="left"><a class="link" href="#Replacing_a_Keyboard_On_the_Fly" title="Chapter 19. Replacing a Keyboard “On the Fly”">19</a></td></tr><tr><td align="left"><span class="symbol">XkbMapNotify</span></td><td align="left">Keyboard mapping change</td><td align="left"><a class="link" href="#Tracking_Changes_to_Map_Components" title="Tracking Changes to Map Components">14.4</a></td></tr><tr><td align="left"><span class="symbol">XkbStateNotify</span></td><td align="left">Keyboard state change</td><td align="left"><a class="link" href="#Tracking_Keyboard_State" title="Tracking Keyboard State">5.4</a></td></tr><tr><td align="left"><span class="symbol">XkbControlsNotify</span></td><td align="left">Keyboard controls state change</td><td align="left"><a class="link" href="#Tracking_Changes_to_Keyboard_Controls" title="Tracking Changes to Keyboard Controls">10.11</a></td></tr><tr><td align="left"><span class="symbol">XkbIndicatorStateNotify</span></td><td align="left">Keyboard indicators state change</td><td align="left"><a class="link" href="#Tracking_Changes_to_Indicator_State_or_Map" title="Tracking Changes to Indicator State or Map">8.5</a></td></tr><tr><td align="left"><span class="symbol">XkbIndicatorMapNotify</span></td><td align="left">Keyboard indicators map change</td><td align="left"><a class="link" href="#Tracking_Changes_to_Indicator_State_or_Map" title="Tracking Changes to Indicator State or Map">8.5</a></td></tr><tr><td align="left"><span class="symbol">XkbNamesNotify</span></td><td align="left">Keyboard name change</td><td align="left"><a class="link" href="#Tracking_Name_Changes" title="Tracking Name Changes">18.5</a></td></tr><tr><td align="left"><span class="symbol">XkbCompatMapNotify</span></td><td align="left">Keyboard compatibility map change</td><td align="left"><a class="link" href="#Tracking_Changes_to_the_Compatibility_Map" title="Tracking Changes to the Compatibility Map">17.5</a></td></tr><tr><td align="left"><span class="symbol">XkbBellNotify</span></td><td align="left">Keyboard bell generated</td><td align="left"><a class="link" href="#Detecting_Bells" title="Detecting Bells">9.4</a></td></tr><tr><td align="left"><span class="symbol">XkbActionMessage</span></td><td align="left">Keyboard action message</td><td align="left"><a class="link" href="#Actions_for_Generating_Messages" title="Actions for Generating Messages">16.1.11</a></td></tr><tr><td align="left"><span class="symbol">XkbAccessXNotify</span></td><td align="left">AccessX state change</td><td align="left"><a class="link" href="#AccessXNotify_Events" title="AccessXNotify Events">10.6.4</a></td></tr><tr><td align="left"><span class="symbol">XkbExtensionDeviceNotify</span></td><td align="left">Extension device change</td><td align="left"><a class="link" href="#Tracking_Changes_to_Extension_Devices" title="Tracking Changes to Extension Devices">21.6</a></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Xkb_Event_Data_Structures"></a>Xkb Event Data Structures</h2></div></div></div><p><a id="XkbAnyEvent"></a>
<a id="idm839" class="indexterm"></a>
<a id="idm843" class="indexterm"></a>
Xkb reports each event it generates in a unique structure holding the data
values needed to describe the conditions the event is reporting. However, all
Xkb events have certain things in common. These common features are contained
in the same fields at the beginning of all Xkb event structures and are
described in the
<span class="structname">XkbAnyEvent</span>
structure:

</p><pre class="programlisting">
typedef struct {
    int             type;        /* Xkb extension base event code */
    unsigned long   serial;      /* X server serial number for event */
    Bool            send_event;  /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *       display;     /* server connection where event generated */
    Time            time;        /* server time when event generated */
    int             xkb_type;    /* Xkb minor event code */
    unsigned int    device;      /* Xkb device ID, will not be <span class="symbol">XkbUseCoreKbd</span> */
} <span class="structname">XkbAnyEvent</span>;
</pre><p>
For any Xkb event, the
<em class="structfield"><code>type</code></em>
field is set to the base event code for the Xkb extension, assigned by the
server to all Xkb extension events. The
<em class="structfield"><code>serial</code></em>,
<em class="structfield"><code>send_event</code></em>,
and
<em class="structfield"><code>display</code></em>
fields are as described for all X11 events. The
<em class="structfield"><code>time</code></em>
field is set to the time when the event was generated and is expressed in
milliseconds. The
<em class="structfield"><code>xkb_type</code></em>
field contains the minor extension event code, which is the extension event
type, and is one of the values listed in
<a class="link" href="#table4.1" title="Table 4.1. Xkb Event Types">Table 4.1</a>. The
<em class="structfield"><code>device</code></em>
field contains the keyboard device identifier associated with the event. This
is never
<span class="symbol">XkbUseCoreKbd</span>,
even if the request that generated the event specified a device of
<span class="symbol">XkbUseCoreKbd</span>.
If the request that generated the event specified
<span class="symbol">XkbUseCoreKbd</span>,
<em class="structfield"><code>device</code></em>
contains a value assigned by the server to specify the core keyboard. If the
request that generated the event specified an X input extension device,
<em class="structfield"><code>device</code></em>
contains that same identifier.
</p><p>
Other data fields specific to individual Xkb events are described in subsequent
chapters where the events are described.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Selecting_Xkb_Events"></a>Selecting Xkb Events</h2></div></div></div><a id="idm868" class="indexterm"></a><a id="idm871" class="indexterm"></a><p>
Xkb events are selected using an event mask, much the same as normal core X
events are selected. However, unlike selecting core X events, where you must
specify the selection status (on or off) for all possible event types whenever
you wish to change the selection criteria for any one event, Xkb allows you to
restrict the specification to only the event types you wish to change. This
means that you do not need to remember the event selection values for all
possible types each time you want to change one of them.
</p><p>
Many Xkb event types are generated under several different circumstances. When
selecting to receive an Xkb event, you may specify either that you want it
delivered under all circumstances, or that you want it delivered only for a
subset of the possible circumstances.
</p><p>
You can also deselect an event type that was previously selected for, using the
same granularity.
</p><p>
Xkb provides two functions to select and deselect delivery of Xkb events.
<code class="function">XkbSelectEvents</code>
allows you to select or deselect delivery of more than one Xkb event type at
once. Events selected using
<code class="function">XkbSelectEvents</code>
are delivered to your program under all circumstances that generate the
events. To restrict delivery of an event to a subset of the conditions under
which it occurs, use
<code class="function">XkbSelectEventDetails</code>.
<code class="function">XkbSelectEventDetails</code>
only allows you to change the selection conditions for a single event at a
time, but it provides a means of fine-tuning the conditions under which the
event is delivered.
</p><p>
To select and / or deselect for delivery of one or more Xkb events and have
them delivered under all conditions, use
<code class="function">XkbSelectEvents</code>.
</p><a id="idm884" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSelectEvents"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSelectEvents</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned long int <var class="pdparam">bits_to_change</var>, unsigned long int <var class="pdparam">values_for_bits</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bits_to_change</code></em>
    </span></p></td><td><p>
        determines events to be selected / deselected
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values_for_bits</code></em>
    </span></p></td><td><p>
        1⇒select, 0→deselect; for events in <em class="parameter"><code>bits_to_change</code></em>
      </p></td></tr></tbody></table></div><p>
This request changes the Xkb event selection mask for the keyboard specified by
<em class="parameter"><code>device_spec</code></em>.
</p><p>
Each Xkb event that can be selected is represented by a bit in the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
masks. Only the event selection bits specified by the
<em class="parameter"><code>bits_to_change</code></em>
parameter are affected; any unspecified bits are left unchanged. To turn on
event selection for an event, set the bit for the event in the
<em class="parameter"><code>bits_to_change</code></em>
parameter and set the corresponding bit in the
<em class="parameter"><code>values_for_bits</code></em>
parameter. To turn off event selection for an event, set the bit for the event
in the
<em class="parameter"><code>bits_to_change</code></em>
parameter and do not set the corresponding bit in the
<em class="parameter"><code>values_for_bits</code></em>
parameter. The valid values for both of these parameters are an inclusive
bitwise OR of the masks shown in <a class="link" href="#table4.2" title="Table 4.2. XkbSelectEvents Mask Constants">Table 4.2</a>.
There is no interface to return
your client’s current event selection mask. Clients cannot set other
clients’ event selection masks.
</p><p>
If a bit is not set in the
<em class="parameter"><code>bits_to_change</code></em>
parameter, but the corresponding bit is set in the
<em class="parameter"><code>values_for_bits</code></em>
parameter, a
<span class="errorname">BadMatch</span>
protocol error results. If an undefined bit is set in either the
<em class="parameter"><code>bits_to_change</code></em>
or the
<em class="parameter"><code>values_for_bits</code></em>
parameter, a
<span class="errorname">BadValue</span>
protocol error results.
</p><p>
All event selection bits are initially zero for clients using the Xkb
extension. Once you set some bits, they remain set for your client until you
clear them via another call to
<code class="function">XkbSelectEvents</code>.
</p><p>
<code class="function">XkbSelectEvents</code>
returns
<span class="symbol">False</span>
if the Xkb extension has not been initialized and
<span class="symbol">True</span>
otherwise.
</p><p>
To select or deselect for a specific Xkb event and optionally place conditions
on when events of that type are reported to your client, use
<code class="function">XkbSelectEventDetails</code>.
This allows you to exercise a finer granularity of control over delivery of
Xkb events with
<code class="function">XkbSelectEvents</code>.
</p><a id="idm949" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSelectEventDetails"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSelectEventDetails</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">event_type</var>, unsigned long int <var class="pdparam">bits_to_change</var>, unsigned long int <var class="pdparam">values_for_bits</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>event_type</code></em>
    </span></p></td><td><p>
        Xkb event type of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bits_to_change</code></em>
    </span></p></td><td><p>
        event selection details
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values_for_bits</code></em>
    </span></p></td><td><p>
        values for bits selected by <em class="parameter"><code>bits_to_change</code></em>
      </p></td></tr></tbody></table></div><p>
While
<code class="function">XkbSelectEvents</code>
allows multiple events to be selected,
<code class="function">XkbSelectEventDetails</code>
changes the selection criteria for a single type of Xkb event. The
interpretation of the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
masks depends on the event type in question.
</p><p>
<code class="function">XkbSelectEventDetails</code>
changes the Xkb event selection mask for the keyboard specified by
<em class="parameter"><code>device_spec</code></em>
and the Xkb event specified by
<em class="parameter"><code>event_type</code></em>.
To turn on event selection for an event detail, set the bit for the detail in
the
<em class="parameter"><code>bits_to_change</code></em>
parameter and set the corresponding bit in the
<em class="parameter"><code>values_for_bits</code></em>
parameter. To turn off event detail selection for a detail, set the bit for
the detail in the
<em class="parameter"><code>bits_to_change</code></em>
parameter and do not set the corresponding bit in the
<em class="parameter"><code>values_for_bits</code></em>
parameter.
</p><p>
If an invalid event type is specified, a
<span class="errorname">BadValue</span>
protocol error results. If a bit is not set in the
<em class="parameter"><code>bits_to_change</code></em>
parameter, but the corresponding bit is set in the
<em class="parameter"><code>values_for_bits</code></em>
parameter, a
<span class="errorname">BadMatch</span>
protocol error results. If an undefined bit is set in either the
<em class="parameter"><code>bits_to_change</code></em>
or the
<em class="parameter"><code>values_for_bits</code></em>
parameter, a
<span class="errorname">BadValue</span>
protocol error results.
</p><p>
For each type of Xkb event, the legal event details that you can specify in the
<code class="function">XkbSelectEventDetails</code>
request are listed in the chapters that describe each event in detail.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Event_Masks"></a>Event Masks</h3></div></div></div><p>
The X server reports the events defined by Xkb to your client application only
if you have requested them via a call to
<code class="function">XkbSelectEvents</code>
or
<code class="function">XkbSelectEventDetails</code>.
Specify the event types in which you are interested in a mask, as described
in <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>.
</p><p>
<a class="link" href="#table4.2" title="Table 4.2. XkbSelectEvents Mask Constants">Table 4.2</a>
lists the event mask constants that can be specified with the
<code class="function">XkbSelectEvents</code>
request and the circumstances in which the mask should be specified.
</p><div class="table"><a id="table4.2"></a><p class="title"><strong>Table 4.2. XkbSelectEvents Mask Constants</strong></p><div class="table-contents"><table class="table" summary="XkbSelectEvents Mask Constants" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Event Mask</th><th align="left">Value</th><th align="left">Notification Wanted</th></tr></thead><tbody><tr><td align="left">
<span class="symbol">XkbNewKeyboardNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;0)</td><td align="left">Keyboard geometry change</td></tr><tr><td align="left">
      <span class="symbol">XkbMapNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;1)</td><td align="left">Keyboard mapping change</td></tr><tr><td align="left">
<p><span class="symbol">XkbStateNotifyMask</span></p>
    </td><td align="left">(1L&lt;&lt;2)</td><td align="left"><p>Keyboard state change</p></td></tr><tr><td align="left">
<p><span class="symbol">XkbControlsNotifyMask</span></p>
    </td><td align="left">(1L&lt;&lt;3)</td><td align="left">Keyboard control change</td></tr><tr><td align="left">
<span class="symbol">XkbIndicatorStateNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;4)</td><td align="left">Keyboard indicator state change</td></tr><tr><td align="left">
<span class="symbol">XkbIndicatorMapNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;5)</td><td align="left">Keyboard indicator map change</td></tr><tr><td align="left">
<span class="symbol">XkbNamesNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;6)</td><td align="left">Keyboard name change</td></tr><tr><td align="left">
<span class="symbol">XkbCompatMapNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;7)</td><td align="left">Keyboard compat map change</td></tr><tr><td align="left">
<span class="symbol">XkbBellNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;8)</td><td align="left">Bell</td></tr><tr><td align="left">
<span class="symbol">XkbActionMessageMask</span>
    </td><td align="left">(1L&lt;&lt;9)</td><td align="left">Action message</td></tr><tr><td align="left">
<span class="symbol">XkbAccessXNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;10)</td><td align="left">AccessX features</td></tr><tr><td align="left">
<span class="symbol">XkbExtensionDeviceNotifyMask</span>
    </td><td align="left">(1L&lt;&lt;11)</td><td align="left">Extension device</td></tr><tr><td align="left">
<span class="symbol">XkbAllEventsMask</span>
    </td><td align="left">(0xFFF)</td><td align="left">All Xkb events</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Unified_Xkb_Event_Type"></a>Unified Xkb Event Type</h2></div></div></div><a id="idm1108" class="indexterm"></a><a id="idm1112" class="indexterm"></a><p>
The
<span class="structname">XkbEvent</span>
structure is a union of the individual structures declared for each Xkb event
type and for the core protocol
<span class="structname">XEvent</span>
type. Given an
<span class="structname">XkbEvent</span>
structure, you may use the
<em class="structfield"><code>type</code></em>
field to determine if the event is an Xkb event
(<em class="structfield"><code>type</code></em>
equals the Xkb base event code; see <a class="link" href="#Initializing_the_Keyboard_Extension" title="Initializing the Keyboard Extension">section 2.4</a>). If the event is an Xkb
event, you may then use the
<em class="structfield"><code>any.xkb_type</code></em>
field to determine the type of Xkb event and thereafter access the
event-dependent components using the union member corresponding to the
particular Xkb event type.
</p><pre class="programlisting">
typedef union _XkbEvent {
      int                            type;
      XkbAnyEvent                    any;
      XkbStateNotifyEvent            state;
      XkbMapNotifyEvent              map;
      XkbControlsNotifyEvent         ctrls;
      XkbIndicatorNotifyEvent        indicators;
      XkbBellNotifyEvent             bell;
      XkbAccessXNotifyEvent          accessx;
      XkbNamesNotifyEvent            names;
      XkbCompatMapNotifyEvent        compat;
      XkbActionMessageEvent          message;
      XkbExtensionDeviceNotifyEvent  device;
      XkbNewKeyboardNotifyEvent      new_kbd;
      XEvent                         core;
} <span class="structname">XkbEvent</span>;
</pre><p>
This unified Xkb event type includes a normal
<span class="structname">XEvent</span>
as used by the core protocol, so it is straightforward for applications that
use Xkb events to call the X library event functions without having to cast
every reference. For example, to get the next event, you can simply declare a
variable of type
<span class="structname">XkbEvent</span>
and call:

</p><pre class="programlisting">XNextEvent(dpy,&amp;xkbev.core);</pre><p>
</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm732" class="footnote"><p><a href="#idm732" class="para"><sup class="para">[2] </sup></a>The one exception to this rule is the
XkbExtensionDeviceNotify event report that is sent when a client attempts to
use an unsupported feature of an X Input Extension device (see <a class="link" href="#Setting_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices" title="Setting Xkb Features for Non-KeyClass Input Extension Devices">section 21.4</a>).
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Keyboard_State"></a>Chapter 5. Keyboard State</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Keyboard_State_Description">Keyboard State Description</a></span></dt><dt><span class="sect1"><a href="#Changing_the_Keyboard_State">Changing the Keyboard State</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Changing_Modifiers">Changing Modifiers</a></span></dt><dt><span class="sect2"><a href="#Changing_Groups">Changing Groups</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Determining_Keyboard_State">Determining Keyboard State</a></span></dt><dt><span class="sect1"><a href="#Tracking_Keyboard_State">Tracking Keyboard State</a></span></dt></dl></div><p>
Keyboard state encompasses all of the transitory information necessary to map a physical key press or release to an appropriate event. The Xkb keyboard state consists of primitive components and additional derived components that are maintained for efficiency reasons. <a class="link" href="#figure5.1" title="Figure 5.1. Xkb State">Figure 5.1</a> shows the components of Xkb keyboard state and their relationships.
</p><div class="figure"><a id="figure5.1"></a><p class="title"><strong>Figure 5.1. Xkb State</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-2.svg"></object></div></div></div><br class="figure-break" /><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Keyboard_State_Description"></a>Keyboard State Description</h2></div></div></div><p>
The Xkb keyboard state is comprised of the state of all keyboard modifiers, the keyboard group, and the state of the pointer buttons. These are grouped into the following components:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The locked group and locked modifiers
  </p></li><li class="listitem"><p>
The latched group and latched modifiers
  </p></li><li class="listitem"><p>
The base group and base modifiers
  </p></li><li class="listitem"><p>
The effective group and effective modifiers
  </p></li><li class="listitem"><p>
The state of the core pointer buttons
  </p></li></ul></div><p><a id="modifiers"></a>
The
<em class="firstterm">modifiers</em>
<a id="idm1155" class="indexterm"></a>
are
<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>,
<span class="symbol">Control</span>,
and
<span class="symbol">Mod1</span>
–
<span class="symbol">Mod5</span>,
as defined by the core protocol. A modifier can be thought of as a toggle that is either set or unset. All modifiers are initially unset. When a modifier is locked, it is set and remains set for all future key events, until it is explicitly unset. A latched modifier is set, but automatically unsets after the next key event that does not change the keyboard state. Locked and latched modifier state can be changed by keyboard activity or via Xkb extension library functions.
</p><p><a id="keysym_groups"></a>
The Xkb extension provides support for
<em class="firstterm">keysym groups</em>,
<a id="idm1164" class="indexterm"></a>
<a id="idm1166" class="indexterm"></a>
<a id="idm1169" class="indexterm"></a>
as defined by ISO9995:
</p><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">Group</span></p></td><td><p>
A logical state of a keyboard providing access to a collection of characters.
A group usually contains a set of characters that logically belong together
and that may be arranged on several shift levels within that group.
      </p></td></tr></tbody></table></div><p>
The Xkb extension supports up to four keysym groups. Groups are named beginning with one and indexed beginning with zero. All group states are indicated using the group index. At any point in time, there is zero or one locked group, zero or one latched group, and one base group. When a group is locked, it supersedes any previous locked group and remains the locked group for all future key events, until a new group is locked. A latched group applies only to the next key event that does not change the keyboard state. The locked and latched group can be changed by keyboard activity or via Xkb extension library functions.
</p><p>
Changing to a different group changes the keyboard state to produce characters from a different group. Groups are typically used to switch between keysyms of different languages and locales.
</p><p>
The
<em class="firstterm">pointer buttons</em>
are
<span class="symbol">Button1</span>
–
<span class="symbol">Button5</span>,
as defined by the core protocol.
</p><p><a id="base_group"></a>
The
<em class="firstterm">base group</em>
<a id="idm1185" class="indexterm"></a>
<a id="idm1187" class="indexterm"></a>
and
<em class="firstterm">base modifiers</em>
<a id="idm1191" class="indexterm"></a>
<a id="idm1193" class="indexterm"></a>
represent keys that are physically or logically down. These
and the pointer buttons can be changed by keyboard activity and
not by Xkb requests. It is possible for a key to be logically
down, but not physically down, and neither latched nor locked.
<a href="#ftn.idm1196" class="footnote" id="idm1196"><sup class="footnote">[3]</sup></a>

</p><p><a id="effective_modifiers"></a>
The
<em class="firstterm">effective modifiers</em>
<a id="idm1200" class="indexterm"></a>
<a id="idm1202" class="indexterm"></a>
are the bitwise union of the locked, latched, and the base modifiers.
</p><p><a id="effective_group"></a>
The
<em class="firstterm">effective group</em>
<a id="idm1207" class="indexterm"></a>
<a id="idm1209" class="indexterm"></a>
is the arithmetic sum of the group indices of the latched group, locked group, and base group, which is then normalized by some function. The result is a meaningful group index.
</p><table border="0" summary="Simple list" class="simplelist"><tr><td>
n = number of keyboard groups, 1&lt;= n &lt;= 4
</td></tr><tr><td>
0 &lt;= any of locked, latched, or base group &lt; n
</td></tr><tr><td>
effective group = f(locked group + latched group + base group)
</td></tr></table><p>
The function f ensures that the effective group is within range. The precise function is specified for the keyboard and can be retrieved through the keyboard description. It may wrap around, clamp down, or default. Few applications will actually examine the effective group, and far fewer still will examine the locked, latched, and base groups.
</p><p>
There are two circumstances under which groups are normalized:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
The global locked or effective group changes. In this case, the changed group is normalized into range according to the settings of the
<em class="structfield"><code>groups_wrap</code></em>
field of the
<span class="structname">XkbControlsRec</span>
structure for the keyboard (see <a class="link" href="#The_GroupsWrap_Control" title="The GroupsWrap Control">section 10.7.1</a>).
  </p></li><li class="listitem"><p>

The Xkb library is interpreting an event with an effective group that is legal for the keyboard as a whole, but not for the key in question. In this case, the group to use for this event only is determined using the
<em class="structfield"><code>group_info</code></em>
field of the key symbol mapping
(<span class="structname">XkbSymMapRec</span>)
for the event key.
  </p></li></ol></div><p>
Each nonmodifier key on a keyboard has zero or more symbols, or keysyms, associated with it. These are the logical symbols that the key can generate when it is pressed. The set of all possible keysyms for a keyboard is divided into groups. Each key is associated with zero or more groups; each group contains one or more symbols. When a key is pressed, the determination of which symbol for the key is selected is based on the effective group and the shift level, which is determined by which modifiers are set.
</p><p><a id="Xkb-aware"></a>
A client that does not explicitly call Xkb functions, but that otherwise makes use of an X library containing the Xkb extension, will have keyboard state represented in bits 0 – 14 of the state field of events that report modifier and button state. Such a client is said to be
<em class="firstterm">Xkb-capable</em>.
<a id="idm1231" class="indexterm"></a>

A client that does explicitly call Xkb functions is an
<em class="firstterm">Xkb-aware</em>
<a id="idm1234" class="indexterm"></a>
client. The Xkb keyboard state includes information derived from the effective state and from two server parameters that can be set through the keyboard extension. The following components of keyboard state pertain to Xkb-capable and Xkb-aware clients:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
lookup state: lookup group and lookup modifiers
  </p></li><li class="listitem"><p>
grab state: grab group and grab modifiers
  </p></li></ul></div><p><a id="lookup_state"></a>
The
<em class="firstterm">lookup modifiers</em>
<a id="idm1243" class="indexterm"></a>
<a id="idm1245" class="indexterm"></a>
and
<em class="firstterm">lookup group</em>
<a id="idm1249" class="indexterm"></a>
<a id="idm1251" class="indexterm"></a>
are represented in the state field of core X events. The modifier state and keycode of a key event are used to determine the symbols associated with the event. For
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events, the lookup modifiers are computed as:

</p><div class="literallayout"><p>   ((base | latched | locked) &amp; ~<span class="emphasis"><em>server_internal_modifiers</em></span>)</p></div><p>
</p><p>
Otherwise the lookup modifiers are computed as:

</p><div class="literallayout"><p>   (((base | latched | (locked &amp; ~<span class="emphasis"><em>ignore_locks</em></span>)) &amp; ~<span class="emphasis"><em>server_internal_modifiers</em></span>)</p></div><p>
</p><p>
The lookup group is the same as the effective group.
</p><p>
When an Xkb-capable or Xkb-aware client wishes to map a keycode to a keysym, it should use the
<em class="firstterm">lookup state</em>
<a id="idm1265" class="indexterm"></a>
<a id="idm1267" class="indexterm"></a>
— the lookup group and the lookup modifiers.
</p><p><a id="grab_state"></a>
The
<em class="firstterm">grab state</em>
<a id="idm1272" class="indexterm"></a>
<a id="idm1274" class="indexterm"></a>
is the state used when matching events to passive grabs. If the event activates a grab, the
<em class="firstterm">grab modifiers</em>
<a id="idm1278" class="indexterm"></a>
<a id="idm1280" class="indexterm"></a>
and
<em class="firstterm">grab group</em>
<a id="idm1284" class="indexterm"></a>
<a id="idm1286" class="indexterm"></a>
are represented in the state field of core X events; otherwise, the lookup state is used. The grab modifiers are computed as:

</p><div class="literallayout"><p>   (((base | latched | (locked &amp; ~ignore_locks)) &amp; ~server_internal_modifiers)</p></div><p>
</p><p>
If the server’s
<span class="emphasis"><em>IgnoreGroupLock</em></span>
control (see <a class="link" href="#The_IgnoreGroupLock_Control" title="The IgnoreGroupLock Control">section 10.7.3</a>) is not set, the grab group is the same as the effective group. Otherwise, the grab group is computed from the base group and latched group, ignoring the locked group.
</p><p>
The final three components of Xkb state are applicable to clients that are not linked with an Xlib containing the X keyboard extension library and therefore are not aware of the keyboard extension
(<span class="emphasis"><em>Xkb-unaware</em></span>
clients):
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The compatibility modifier state
  </p></li><li class="listitem"><p>
The compatibility lookup modifier state
  </p></li><li class="listitem"><p>
The compatibility grab modifier state
  </p></li></ul></div><p>
The X11 protocol interpretation of modifiers does not include direct support for multiple groups. When an Xkb-extended X server connects to an Xkb-unaware client, the compatibility states remap the keyboard group into a core modifier whenever possible. The compatibility state corresponds to the effective modifier and effective group state, with the group remapped to a modifier. The compatibility lookup and grab states correspond to the lookup and grab states, respectively, with the group remapped to a modifier. The compatibility lookup state is reported in events that do not trigger passive grabs; otherwise, the compatibility grab state is reported.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Changing_the_Keyboard_State"></a>Changing the Keyboard State</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_Modifiers"></a>Changing Modifiers</h3></div></div></div><a id="idm1307" class="indexterm"></a><a id="idm1309" class="indexterm"></a><a id="idm1312" class="indexterm"></a><p>
The functions in this section that change the use of modifiers use a mask in the parameter
<em class="structfield"><code>affect</code></em>.
It is a bitwise inclusive OR of the legal modifier masks:
</p><div class="table"><a id="table5.1"></a><p class="title"><strong>Table 5.1. Real Modifier Masks</strong></p><div class="table-contents"><table class="table" summary="Real Modifier Masks" border="0"><colgroup><col align="left" class="c1" /></colgroup><tbody><tr><td align="left">Mask</td></tr><tr><td align="left">ShiftMask</td></tr><tr><td align="left">LockMask</td></tr><tr><td align="left">ControlMask</td></tr><tr><td align="left">Mod1Mask</td></tr><tr><td align="left">Mod2Mask</td></tr><tr><td align="left">Mod3Mask</td></tr><tr><td align="left">Mod4Mask</td></tr><tr><td align="left">Mod5Mask</td></tr></tbody></table></div></div><br class="table-break" /><p>
To lock and unlock any of the eight real keyboard modifiers, use
<code class="function">XkbLockModifiers</code>:
</p><a id="idm1342" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLockModifiers"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbLockModifiers</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">affect</var>, unsigned int <var class="pdparam">values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>affect</code></em>
    </span></p></td><td><p>
        mask of real modifiers whose lock state is to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values</code></em>
    </span></p></td><td><p>
        1 ⇒ lock, 0 ⇒ unlock; only for modifiers selected by <em class="parameter"><code>affect</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbLockModifiers</code>
sends a request to the server to lock the real modifiers selected by both
<em class="parameter"><code>affect</code></em>
and
<em class="parameter"><code>values</code></em>
and to unlock the real modifiers selected by
<em class="parameter"><code>affect</code></em>
but not selected by
<em class="parameter"><code>values</code></em>.
<code class="function">XkbLockModifiers</code>
does not wait for a reply from the server. It returns
<span class="symbol">True</span>
if the request was sent, and
<span class="symbol">False</span>
otherwise.
</p><p>
To latch and unlatch any of the eight real keyboard modifiers, use
<code class="function">XkbLatchModifiers</code>:
</p><a id="idm1391" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLatchModifiers"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbLatchModifiers</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">affect</var>, unsigned int <var class="pdparam">values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>affect</code></em>
    </span></p></td><td><p>
        mask of modifiers whose latch state is to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values</code></em>
    </span></p></td><td><p>
        1 ⇒ latch, 0 ⇒ unlatch; only for mods selected by <em class="parameter"><code>affect</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbLatchModifiers</code>
sends a request to the server to latch the real modifiers selected by both
<em class="parameter"><code>affect</code></em>
and
<em class="parameter"><code>values</code></em>
and to unlatch the real modifiers selected by
<em class="parameter"><code>affect</code></em>
but not selected by
<em class="parameter"><code>values</code></em>.
<code class="function">XkbLatchModifiers</code>
does not wait for a reply from the server. It returns
<span class="symbol">True</span>
if the request was sent, and
<span class="symbol">False</span>
otherwise.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_Groups"></a>Changing Groups</h3></div></div></div><a id="idm1440" class="indexterm"></a><a id="idm1442" class="indexterm"></a><p>
Reference the keysym group indices with these symbolic constants:
</p><div class="table"><a id="table5.2"></a><p class="title"><strong>Table 5.2. Symbolic Group Names</strong></p><div class="table-contents"><table class="table" summary="Symbolic Group Names" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><tbody><tr><td align="left">Symbolic Name</td><td align="left">Value</td></tr><tr><td align="left"><span class="symbol">XkbGroup1Index</span></td><td align="left">0</td></tr><tr><td align="left"><span class="symbol">XkbGroup2Index</span></td><td align="left">1</td></tr><tr><td align="left"><span class="symbol">XkbGroup3Index</span></td><td align="left">2</td></tr><tr><td align="left"><span class="symbol">XkbGroup4Index</span></td><td align="left">3</td></tr></tbody></table></div></div><br class="table-break" /><p>
To lock the keysym group, use
<code class="function">XkbLockGroup</code>.
</p><a id="idm1473" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLockGroup"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbLockGroup</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">group</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>group</code></em>
    </span></p></td><td><p>
        index of the keysym group to lock
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbLockGroup</code>
sends a request to the server to lock the specified
<em class="parameter"><code>group</code></em>
and does not wait for a reply. It returns
<span class="symbol">True</span>
if the request was sent and
<span class="symbol">False</span>
otherwise.
</p><p>
To latch the keysym group, use
<code class="function">XkbLatchGroup</code>.
</p><a id="idm1510" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLatchGroup"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbLatchGroup</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">group</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>group</code></em>
    </span></p></td><td><p>
        index of the keysym group to latch
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbLatchGroup</code>
sends a request to the server to latch the specified group and does not wait for a reply. It returns
<span class="symbol">True</span>
if the request was sent and
<span class="symbol">False</span>
otherwise.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Determining_Keyboard_State"></a>Determining Keyboard State</h2></div></div></div><a id="idm1546" class="indexterm"></a><p>
Xkb keyboard state may be represented in an
<span class="structname">XkbStateRec</span>
structure:

</p><pre class="programlisting">
typedef struct {
    unsigned char      group;                /* effective group index */
    unsigned char      base_group;           /* base group index */
    unsigned char      latched_group;        /* latched group index */
    unsigned char      locked_group;         /* locked group index */
    unsigned char      mods;                 /* effective modifiers */
    unsigned char      base_mods;            /* base modifiers */
    unsigned char      latched_mods;         /* latched modifiers */
    unsigned char      locked_mods;          /* locked modifiers */
    unsigned char      compat_state;         /* effective group ⇒ modifiers */
    unsigned char      grab_mods;            /* modifiers used for grabs */
    unsigned char      compat_grab_mods;     /* mods used for compatibility
                                                mode grabs */
    unsigned char      lookup_mods;          /* mods used to lookup symbols */
    unsigned char      compat_lookup_mods;   /* mods used for compatibility
                                                lookup */
    unsigned short     ptr_buttons;          /* 1 bit ⇒ corresponding
                                                pointer btn is down */
} <span class="structname">XkbStateRec</span>, *XkbStatePtr;
</pre><p>
To obtain the keyboard state, use
<code class="function">XkbGetState</code>.
</p><a id="idm1555" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetState"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetState</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, XkbStatePtr <var class="pdparam">state_return</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state_return</code></em>
    </span></p></td><td><p>
        backfilled with Xkb state
      </p></td></tr></tbody></table></div><p>
The
<code class="function">XkbGetState</code>
function queries the server for the current keyboard state, waits for a reply, and then backfills
<em class="parameter"><code>state_return</code></em>
with the results.
</p><p>
All group values are expressed as group indices in the range [0..3]. Modifiers and the compatibility modifier state values are expressed as the bitwise union of the core X11 modifier masks. The pointer button state is reported as in the core X11 protocol.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Keyboard_State"></a>Tracking Keyboard State</h2></div></div></div><a id="idm1591" class="indexterm"></a><a id="idm1595" class="indexterm"></a><p>
The Xkb extension reports
<span class="symbol">XkbStateNotify</span>
events to clients wanting notification whenever the Xkb state changes. The changes reported include changes to any aspect of the keyboard state: when a modifier is set or unset, when the current group changes, or when a pointer button is pressed or released. As with all Xkb events,
<span class="symbol">XkbStateNotify</span>
events are reported to all interested clients without regard to the current keyboard input focus or grab state.
</p><p>
There are many different types of Xkb state changes. Xkb defines an event
detail mask corresponding to each type of change. The event detail masks are
listed in <a class="link" href="#table5.3" title="Table 5.3. XkbStateNotify Event Detail Masks">Table 5.3</a>.
</p><div class="table"><a id="table5.3"></a><p class="title"><strong>Table 5.3. XkbStateNotify Event Detail Masks</strong></p><div class="table-contents"><table class="table" summary="XkbStateNotify Event Detail Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbModifierStateMask</span></td><td align="left">(1L &lt;&lt; 0)</td></tr><tr><td align="left"><span class="symbol">XkbModifierBaseMask</span></td><td align="left">(1L &lt;&lt; 1)</td></tr><tr><td align="left"><span class="symbol">XkbModifierLatchMask</span></td><td align="left">(1L &lt;&lt; 2)</td></tr><tr><td align="left"><span class="symbol">XkbModifierLockMask</span></td><td align="left">(1L &lt;&lt; 3)</td></tr><tr><td align="left"><span class="symbol">XkbGroupStateMask</span></td><td align="left">(1L &lt;&lt; 4)</td></tr><tr><td align="left"><span class="symbol">XkbGroupBaseMask</span></td><td align="left">(1L &lt;&lt; 5)</td></tr><tr><td align="left"><span class="symbol">XkbGroupLatchMask</span></td><td align="left">(1L &lt;&lt; 6)</td></tr><tr><td align="left"><span class="symbol">XkbGroupLockMask</span></td><td align="left">(1L &lt;&lt; 7)</td></tr><tr><td align="left"><span class="symbol">XkbCompatStateMask</span></td><td align="left">(1L &lt;&lt; 8)</td></tr><tr><td align="left"><span class="symbol">XkbGrabModsMask</span></td><td align="left">(1L &lt;&lt; 9)</td></tr><tr><td align="left"><span class="symbol">XkbCompatGrabModsMask</span></td><td align="left">(1L &lt;&lt; 10)</td></tr><tr><td align="left"><span class="symbol">XkbLookupModsMask</span></td><td align="left">(1L &lt;&lt; 11)</td></tr><tr><td align="left"><span class="symbol">XkbCompatLookupModsMask</span></td><td align="left">(1L &lt;&lt; 12)</td></tr><tr><td align="left"><span class="symbol">XkbPointerButtonMask</span></td><td align="left">(1L &lt;&lt; 13)</td></tr><tr><td align="left"><span class="symbol">XkbAllStateComponentsMask</span></td><td align="left">(0x3fff)</td></tr></tbody></table></div></div><br class="table-break" /><p>
To track changes in the keyboard state for a particular device, select to receive
<span class="symbol">XkbStateNotify</span>
events by calling either
<code class="function">XkbSelectEvents</code>
or
<code class="function">XkbSelectEventDetails</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>).
</p><p>
To receive
<span class="symbol">XkbStateNotify</span>
events under all possible conditions, use
<code class="function">XkbSelectEvents</code>
and pass
<span class="symbol">XkbStateNotifyMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
To receive
<span class="symbol">XkbStateNotify</span>
events only under certain conditions, use
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbStateNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying the desired state changes in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
using mask bits from <a class="link" href="#table5.3" title="Table 5.3. XkbStateNotify Event Detail Masks">Table 5.3</a>.
</p><p>
The structure for
<span class="symbol">XkbStateNotify</span>
events is:

</p><pre class="programlisting">
typedef struct {
    int            type;            /* Xkb extension base event code */
    unsigned long  serial;          /* X server serial number for event */
    Bool           send_event;      /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;         /* server connection where event generated */
    Time           time;            /* server time when event generated */
    int            xkb_type;        /* <span class="symbol">XkbStateNotify</span> */
    int            device;          /* Xkb device ID,
                                       will not be <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int   changed;         /* bits indicating what has changed */
    int            group;           /* group index of effective group */
    int            base_group;      /* group index of base group */
    int            latched_group;   /* group index of latched group */
    int            locked_group;    /* group index of locked group */
    unsigned int   mods;            /* effective modifiers */
    unsigned int   base_mods;       /* base modifiers */
    unsigned int   latched_mods;    /* latched modifiers */
    unsigned int   locked_mods;     /* locked modifiers */
    int            compat_state;    /* computed compatibility state */
    unsigned char  grab_mods;       /* modifiers used for grabs */
    unsigned char  compat_grab_mods; /* modifiers used for compatibility grabs */
    unsigned char  lookup_mods;     /* modifiers used to lookup symbols */
    unsigned char  compat_lookup_mods; /* mods used for compatibility look up */
    int            ptr_buttons;     /* core pointer buttons */
    KeyCode        keycode;         /* keycode causing event,
                                       0 if programmatic */
    char           event_type;      /* core event if <em class="structfield"><code>req_major</code></em> or <em class="structfield"><code>req_minor</code></em>
                                       non zero */
    char           req_major;       /* major request code if program trigger,
                                       else 0 */
    char           req_minor;       /* minor request code if program trigger,
                                       else 0 */
} <span class="structname">XkbStateNotifyEvent</span>;
</pre><p>
When you receive an
<span class="symbol">XkbStateNotify</span>
event, the
<em class="structfield"><code>changed</code></em>
field indicates which elements of keyboard state have changed.
This will be the bitwise inclusive OR of one or more of the
<span class="symbol">XkbStateNotify</span>
event detail masks shown in <a class="link" href="#table5.3" title="Table 5.3. XkbStateNotify Event Detail Masks">Table 5.3</a>.
All fields reported in the event are valid, but only those indicated in
<em class="structfield"><code>changed</code></em>
have changed values.
</p><p>
The
<em class="structfield"><code>group</code></em>
field is the group index of the effective keysym group. The
<em class="structfield"><code>base_group</code></em>,
<em class="structfield"><code>latched_group</code></em>,
and
<em class="structfield"><code>locked_group</code></em>
fields are set to a group index value representing the base group,
the latched group, and the locked group, respectively. The X
server can set the modifier and compatibility state fields to
a union of the core modifier mask bits; this union represents the
corresponding modifier states. The <em class="structfield"><code>ptr_buttons</code></em>
field gives the state of the core pointer buttons as a
mask composed of an inclusive OR of zero or more of the
core pointer button masks.
</p><p>
Xkb state changes can occur either in response to keyboard
activity or under application control. If a key event
caused the state change, the
<em class="structfield"><code>keycode</code></em>
field gives the keycode of the key event, and the
<em class="structfield"><code>event_type</code></em>
field is set to either <span class="symbol">KeyPress</span>
or
<span class="symbol">KeyRelease</span>.
If a pointer button event caused the state change, the
<em class="structfield"><code>keycode</code></em>
field is zero, and the <em class="structfield"><code>event_type</code></em>
field is set to either <span class="symbol">ButtonPress</span>
or <span class="symbol">ButtonRelease</span>.
Otherwise, the major and minor codes of the request that caused the
state change are given in the
<em class="structfield"><code>req_major</code></em>
and
<em class="structfield"><code>req_minor</code></em>
fields, and the
<em class="structfield"><code>keycode</code></em>
field is zero. The
<em class="structfield"><code>req_major</code></em>
value is the same as the major extension opcode.
</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm1196" class="footnote"><p><a href="#idm1196" class="para"><sup class="para">[3] </sup></a>
Keys may be logically down when they are physically up because
of their electrical properties or because of the keyboard extension
in the X server having filtered the key release, for esoteric reasons.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Complete_Keyboard_Description"></a>Chapter 6. Complete Keyboard Description</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#The_XkbDescRec_Structure">The XkbDescRec Structure</a></span></dt><dt><span class="sect1"><a href="#Obtaining_a_Keyboard_Description_from_the_Server">Obtaining a Keyboard Description from the Server</a></span></dt><dt><span class="sect1"><a href="#Tracking_Changes_to_the_Keyboard_Description_in_the_Server">Tracking Changes to the Keyboard Description in the Server</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_a_Keyboard_Description">Allocating and Freeing a Keyboard Description</a></span></dt></dl></div><p>
The complete Xkb description for a keyboard device is accessed using a single
structure containing pointers to major Xkb components. This chapter describes
this single structure and provides references to other sections of this
document that discuss the major Xkb components in detail.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_XkbDescRec_Structure"></a>The XkbDescRec Structure</h2></div></div></div><a id="idm1731" class="indexterm"></a><p>
The complete description of an Xkb keyboard is given by an
<span class="structname">XkbDescRec</span>.
The component structures in the
<span class="structname">XkbDescRec</span>
represent the major Xkb components outlined in <a class="link" href="#figure1.1" title="Figure 1.1. Overall Xkb Structure">Figure 1.1</a>.
</p><pre class="programlisting">
typedef struct {
    struct _XDisplay *  display;        /* connection to X server */
    unsigned short      flags;          /* private to Xkb, do not modify */
    unsigned short      device_spec;    /* device of interest */
    KeyCode             min_key_code;   /* minimum keycode for device */
    KeyCode             max_key_code;   /* maximum keycode for device */
    XkbControlsPtr      ctrls;          /* controls */
    XkbServerMapPtr     server;         /* server keymap */
    XkbClientMapPtr     map;            /* client keymap */
    XkbIndicatorPtr     indicators;     /* indicator map */
    XkbNamesPtr         names;          /* names for all components */
    XkbCompatMapPtr     compat;         /* compatibility map */
    XkbGeometryPtr      geom;           /* physical geometry of keyboard */
} <span class="structname">XkbDescRec</span>, *XkbDescPtr;
</pre><p>
The
<em class="parameter"><code>display</code></em>
field points to an X display structure. The
<em class="structfield"><code>flags</code></em>
field is private to the library: modifying
<em class="structfield"><code>flags</code></em>
may yield unpredictable results. The
<em class="parameter"><code>device_spec</code></em>
field specifies the device identifier of the keyboard input device, or
<span class="symbol">XkbUseCoreKbd</span>,
which specifies the core keyboard device. The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields specify the least and greatest keycode that can be returned by the
keyboard.
</p><p>
The other fields specify structure components of the keyboard description and
are described in detail in other sections of this document.
<a class="link" href="#table6.1" title="Table 6.1. XkbDescRec Component References">Table 6.1</a>
identifies the subsequent sections of this document that discuss the individual
components of the
<span class="structname">XkbDescRec</span>.
</p><div class="table"><a id="table6.1"></a><p class="title"><strong>Table 6.1. XkbDescRec Component References</strong></p><div class="table-contents"><table class="table" summary="XkbDescRec Component References" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">XkbDescRec Field</th><th align="left">For more info</th></tr></thead><tbody><tr><td align="left">ctrls</td><td align="left"><a class="xref" href="#Keyboard_Controls" title="Chapter 10. Keyboard Controls">Chapter 10, <em>Keyboard Controls</em></a></td></tr><tr><td align="left">server</td><td align="left"><a class="xref" href="#Xkb_Server_Keyboard_Mapping" title="Chapter 16. Xkb Server Keyboard Mapping">Chapter 16, <em>Xkb Server Keyboard Mapping</em></a></td></tr><tr><td align="left">map</td><td align="left"><a class="xref" href="#Xkb_Client_Keyboard_Mapping" title="Chapter 15. Xkb Client Keyboard Mapping">Chapter 15, <em>Xkb Client Keyboard Mapping</em></a></td></tr><tr><td align="left">indicators</td><td align="left"><a class="xref" href="#Indicators" title="Chapter 8. Indicators">Chapter 8, <em>Indicators</em></a></td></tr><tr><td align="left">names</td><td align="left"><a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a></td></tr><tr><td align="left">compat</td><td align="left"><a class="xref" href="#The_Xkb_Compatibility_Map" title="Chapter 17. The Xkb Compatibility Map">Chapter 17, <em>The Xkb Compatibility Map</em></a></td></tr><tr><td align="left">geom</td><td align="left"><a class="xref" href="#Keyboard_Geometry" title="Chapter 13. Keyboard Geometry">Chapter 13, <em>Keyboard Geometry</em></a></td></tr></tbody></table></div></div><br class="table-break" /><p>
Each structure component has a corresponding mask bit that is used in function
calls to indicate that the structure should be manipulated in some manner, such
as allocating it or freeing it. These masks and their relationships to the
fields in the
<span class="structname">XkbDescRec</span>
are shown in <a class="link" href="#table6.2" title="Table 6.2. Mask Bits for XkbDescRec">Table 6.2</a>.
</p><div class="table"><a id="table6.2"></a><p class="title"><strong>Table 6.2. Mask Bits for XkbDescRec</strong></p><div class="table-contents"><table class="table" summary="Mask Bits for XkbDescRec" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Mask Bit</th><th align="left">XkbDescRec Field</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbControlsMask</span></td><td align="left">ctrls</td><td align="left">(1L&lt;&lt;0)</td></tr><tr><td align="left"><span class="symbol">XkbServerMapMask</span></td><td align="left">server</td><td align="left">(1L&lt;&lt;1)</td></tr><tr><td align="left">XkbIClientMapMask</td><td align="left">map</td><td align="left">(1L&lt;&lt;2)</td></tr><tr><td align="left"><span class="symbol">XkbIndicatorMapMask</span></td><td align="left">indicators</td><td align="left">(1L&lt;&lt;3)</td></tr><tr><td align="left"><span class="symbol">XkbNamesMask</span></td><td align="left">names</td><td align="left">(1L&lt;&lt;4)</td></tr><tr><td align="left"><span class="symbol">XkbCompatMapMask</span></td><td align="left">compat</td><td align="left">(1L&lt;&lt;5)</td></tr><tr><td align="left"><span class="symbol">XkbGeometryMask</span></td><td align="left">geom</td><td align="left">(1L&lt;&lt;6)</td></tr><tr><td align="left"><span class="symbol">XkbAllComponentsMask</span></td><td align="left">All Fields</td><td align="left">(0x7f)</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Obtaining_a_Keyboard_Description_from_the_Server"></a>Obtaining a Keyboard Description from the Server</h2></div></div></div><p>
To retrieve one or more components of a keyboard device description, use
<code class="function">XkbGetKeyboard</code>
(see also
<a class="link" href="#XkbGetKeyboardByName"><code class="function">XkbGetKeyboardByName</code></a>).

</p><a id="idm1850" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyboard"></a><p><code class="funcdef">XkbDescPtr <strong class="fsfunc">XkbGetKeyboard</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">device_spec</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask indicating components to return
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device for which to fetch description, or
<span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyboard</code>
allocates and returns a pointer to a keyboard description. It queries the
server for those components specified in the
<em class="parameter"><code>which</code></em>
parameter for device
<em class="parameter"><code>device_spec</code></em>
and copies the results to the
<span class="structname">XkbDescRec</span>
it allocated. The remaining fields in the keyboard description are set to
<span class="symbol">NULL</span>.
The valid masks for
<em class="parameter"><code>which</code></em>
are those listed in <a class="link" href="#table6.2" title="Table 6.2. Mask Bits for XkbDescRec">Table 6.2</a>.
</p><p>
<code class="function">XkbGetKeyboard</code>
can generate
<span class="errorname">BadAlloc</span>
protocol errors.
</p><p>
To free the returned keyboard description, use
<code class="function">XkbFreeKeyboard</code>
(see <a class="link" href="#Allocating_and_Freeing_a_Keyboard_Description" title="Allocating and Freeing a Keyboard Description">section 6.4</a>).
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Changes_to_the_Keyboard_Description_in_the_Server"></a>Tracking Changes to the Keyboard Description in the Server</h2></div></div></div><p>
The server can generate events whenever its copy of the keyboard description
for a device changes. Refer to <a class="link" href="#Tracking_Changes_to_Map_Components" title="Tracking Changes to Map Components">section 14.4</a> for detailed information on
tracking changes to the keyboard description.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_a_Keyboard_Description"></a>Allocating and Freeing a Keyboard Description</h2></div></div></div><p>
Applications seldom need to directly allocate a keyboard description; calling
<code class="function">XkbGetKeyboard</code>
usually suffices. In the event you need to create a keyboard description from
scratch, however, use
<code class="function">XkbAllocKeyboard</code>
rather than directly calling
<code class="function">malloc</code>
or
<code class="function">Xmalloc</code>.
</p><a id="idm1905" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocKeyboard"></a><p><code class="funcdef">XkbDescRec *<strong class="fsfunc">XkbAllocKeyboard</strong>(</code><code>void)</code>;</p></div><p>
If
<code class="function">XkbAllocKeyboard</code>
fails to allocate the keyboard description, it returns
<span class="symbol">NULL</span>.
Otherwise, it returns a pointer to an empty keyboard description structure.
The
<em class="structfield"><code>device_spec</code></em>
field will have been initialized to
<span class="symbol">XkbUseCoreKbd</span>.
You may then either fill in the structure components or use Xkb functions to
obtain values for the structure components from a keyboard device.
</p><p>
To destroy either an entire an
<span class="structname">XkbDescRec</span>
or just some of its members, use
<code class="function">XkbFreeKeyboard</code>.
</p><a id="idm1921" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeKeyboard"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeKeyboard</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description with components to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask selecting components to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ free all components and <em class="parameter"><code>xkb</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbFreeKeyboard</code>
frees the components of
<em class="parameter"><code>xkb</code></em>
specified by
<em class="parameter"><code>which</code></em>
and sets the corresponding values to
<span class="symbol">NULL</span>.
If
<em class="parameter"><code>free_all</code></em>
is
<span class="symbol">True</span>,
<code class="function">XkbFreeKeyboard</code>
frees every non-
<span class="symbol">NULL</span>
component of
<em class="parameter"><code>xkb</code></em>
and then frees the
<em class="parameter"><code>xkb</code></em>
structure itself.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Virtual_Modifiers"></a>Chapter 7. Virtual Modifiers</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Virtual_Modifier_Names_and_Masks">Virtual Modifier Names and Masks</a></span></dt><dt><span class="sect1"><a href="#Modifier_Definitions">Modifier Definitions</a></span></dt><dt><span class="sect1"><a href="#Binding_Virtual_Modifiers_to_Real_Modifiers">Binding Virtual Modifiers to Real Modifiers</a></span></dt><dt><span class="sect1"><a href="#Virtual_Modifier_Key_Mapping">Virtual Modifier Key Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Inactive_Modifier_Sets">Inactive Modifier Sets</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Conventions">Conventions</a></span></dt><dt><span class="sect1"><a href="#Example">Example</a></span></dt></dl></div><p>
The core protocol specifies that certain keysyms, when bound to modifiers,
affect the rules of keycode to keysym interpretation for all keys; for example,
when the
<span class="keysym">Num_Lock</span>
keysym is bound to some modifier, that modifier is used to select between
shifted and unshifted state for the numeric keypad keys. The core protocol does
not provide a convenient way to determine the mapping of modifier bits (in
particular
<span class="symbol">Mod1</span>
through
<span class="symbol">Mod5</span>)
to keysyms such as
<span class="keysym">Num_Lock</span>
and
<span class="keysym">Mode_switch</span>.
Using the core protocol only, a client application must retrieve and search
the modifier map to determine the keycodes bound to each modifier, and then
retrieve and search the keyboard mapping to determine the keysyms bound to the
keycodes. It must repeat this process for all modifiers whenever any part of
the modifier mapping is changed.
</p><p>
Xkb alleviates these problems by defining virtual modifiers. In addition to the
eight core modifiers, referred to as the
<em class="firstterm">real modifiers</em>,
<a id="idm1973" class="indexterm"></a>
<a id="idm1975" class="indexterm"></a>
Xkb provides a set of sixteen named
<em class="firstterm">virtual modifiers</em>.
<a id="idm1979" class="indexterm"></a>
<a id="idm1981" class="indexterm"></a>
Each virtual modifier can be bound to any set of the real modifiers
(
<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>,
<span class="symbol">Control</span>,
and
<span class="symbol">Mod1</span>
–
<span class="symbol">Mod5</span>).

</p><p>
The separation of function from physical modifier bindings makes it easier to
specify more clearly the intent of a binding. X servers do not all assign
modifiers the same way — for example,
<span class="keysym">Num_Lock</span>
might be bound to
<span class="symbol">Mod2</span>
for one vendor and to
<span class="symbol">Mod4</span>
for another. This makes it cumbersome to automatically remap the keyboard to a
desired configuration without some kind of prior knowledge about the keyboard
layout and bindings. With XKB, applications can use virtual modifiers to
specify the desired behavior, without regard for the actual physical bindings
in effect.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Virtual_Modifier_Names_and_Masks"></a>Virtual Modifier Names and Masks</h2></div></div></div><p>
Virtual modifiers are named by converting their string name to an X
<span class="type">Atom</span>
and storing the Atom in the
<em class="structfield"><code>names.vmods</code></em>
array in an
<span class="structname">XkbDescRec</span>
structure (see <a class="link" href="#The_XkbDescRec_Structure" title="The XkbDescRec Structure">section 6.1</a>). The position of a name Atom in the
<em class="structfield"><code>names.vmods</code></em>
array defines the bit position used to represent the virtual modifier and also
the index used when accessing virtual modifier information in arrays: the name
in the i-th (0 relative) entry of
<em class="structfield"><code>names.vmods</code></em>
is the i-th virtual modifier, represented by the mask (1&lt;&lt;i). Throughout
Xkb, various functions have a parameter that is a mask representing virtual
modifier choices. In each case, the i-th bit (0 relative) of the mask
represents the i-th virtual modifier.
</p><p>
To set the name of a virtual modifier, use
<code class="function">XkbSetNames</code>,
using
<span class="symbol">XkbVirtualModNamesMask</span>
in
<em class="parameter"><code>which</code></em>
and the name in the
<em class="parameter"><code>xkb</code></em>
argument; to retrieve indicator names, use
<code class="function">XkbGetNames</code>.
These functions are discussed in <a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Modifier_Definitions"></a>Modifier Definitions</h2></div></div></div><a id="idm2011" class="indexterm"></a><p>
An Xkb
<em class="firstterm">modifier definition</em>
<a id="idm2016" class="indexterm"></a>
enumerates a collection of real and virtual modifiers but does not in itself
bind those modifiers to any particular key or to each other. Modifier
definitions are included in a number of structures in the keyboard description
to define the collection of modifiers that affect or are affected by some other
entity. A modifier definition is relevant only in the context of some other
entity such as an indicator map, a control, or a key type. (See
<a class="link" href="#XkbIndicatorMapRec" title="XkbIndicatorMapRec">section 8.2.2</a>,
<a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>, and
<a class="link" href="#Key_Types" title="Key Types">section 15.2</a>.)
</p><pre class="programlisting">
typedef struct _XkbMods {
    unsigned char   mask;       /* real_mods | vmods mapped to real modifiers */
    unsigned char   real_mods;  /* real modifier bits */
    unsigned short  vmods;      /* virtual modifier bits */
} <span class="structname">XkbModsRec</span>, *XkbModsPtr;
</pre><p>
An Xkb modifier definition consists of a set of bit masks corresponding to the
eight real modifiers
(<em class="structfield"><code>real_mods</code></em>);
a similar set of bitmasks corresponding to the 16 named virtual modifiers
(<em class="structfield"><code>vmods</code></em>);
and an effective mask
(<em class="structfield"><code>mask</code></em>).
The effective mask represents the set of all real modifiers that can
logically be set either by setting any of the real modifiers or by setting any
of the virtual modifiers in the definition.
<em class="structfield"><code>mask</code></em>
is derived from the real and virtual modifiers and should never be explicitly
changed — it contains all of the real modifiers specified in the definition
(<em class="structfield"><code>real_mods</code></em>)
<span class="emphasis"><em>plus</em></span>
any real modifiers that are bound to the virtual modifiers specified in the
definition
(<em class="structfield"><code>vmods</code></em>).
The binding of the virtual modifiers to real modifiers is exterior to the
modifier definition. Xkb automatically recomputes the mask field of modifier
definitions as necessary. Whenever you access a modifier definition that has
been retrieved using an Xkb library function, the mask field will be correct
for the keyboard mapping of interest.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Binding_Virtual_Modifiers_to_Real_Modifiers"></a>Binding Virtual Modifiers to Real Modifiers</h2></div></div></div><p>
The binding of virtual modifiers to real modifiers is defined by the
<em class="structfield"><code>server.vmods</code></em>
array in an
<span class="structname">XkbDescRec</span>
structure. Each entry contains the real modifier bits that are bound to the
virtual modifier corresponding to the entry. The overall relationship of fields
dealing with virtual modifiers in the server keyboard description are shown in
<a class="link" href="#figure16.2" title="Figure 16.2. Virtual Modifier Relationships">Figure 16.2</a>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Virtual_Modifier_Key_Mapping"></a>Virtual Modifier Key Mapping</h2></div></div></div><p>
Xkb maintains a
<em class="firstterm">virtual modifier mapping</em>,
<a id="idm2042" class="indexterm"></a>
<a id="idm2044" class="indexterm"></a>
which lists the virtual modifiers associated with, or bound to, each key. The
real modifiers bound to a virtual modifier always include all of the modifiers
bound to any of the keys that specify that virtual modifier in their virtual
modifier mapping. The
<em class="structfield"><code>server.vmodmap</code></em>
array indicates which virtual modifiers are bound to each key; each entry is a
bitmask for the virtual modifier bits. The
<em class="structfield"><code>server.vmodmap</code></em>
array is indexed by keycode.
</p><p>
The
<em class="structfield"><code>vmodmap</code></em>
and
<em class="structfield"><code>vmods</code></em>
members of the server map are the <span class="quote">“<span class="quote">master</span>”</span> virtual modifier definitions. Xkb
automatically propagates any changes to these fields to all other fields that
use virtual modifier mappings (see <a class="link" href="#Virtual_Modifier_Mapping" title="Virtual Modifier Mapping">section 16.4</a>).
</p><p>
For example, if
<span class="symbol">Mod3</span>
is bound to the
<span class="keysym">Num_Lock</span>
key by the core protocol modifier mapping, and the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier is bound to they
<span class="keysym">Num_Lock</span>
key by the virtual modifier mapping,
<span class="symbol">Mod3</span>
is added to the set of modifiers associated with
<span class="emphasis"><em>NumLock</em></span>.
</p><p>
The virtual modifier mapping is normally updated whenever actions are
automatically applied to symbols (see <a class="link" href="#Virtual_Modifier_Mapping" title="Virtual Modifier Mapping">section 16.4</a> for details), and few
applications should need to change the virtual modifier mapping explicitly.
</p><p>
Use
<code class="function">XkbGetMap</code>
(see <a class="link" href="#Getting_Map_Components_from_the_Server" title="Getting Map Components from the Server">section 14.2</a>) to get the virtual modifiers from the server or use
<code class="function">XkbGetVirtualMods</code>
(see <a class="link" href="#Obtaining_Virtual_Modifier_Bindings_from_the_Server" title="Obtaining Virtual Modifier Bindings from the Server">section 16.4.1</a>) to update a local copy of the virtual modifiers bindings
from the server. To set the binding of a virtual modifier to a real modifier,
use
<code class="function">XkbSetMap</code>
(see
<a class="link" href="#Changing_Map_Components_in_the_Server" title="Changing Map Components in the Server">section 14.3</a>).
</p><p>
To determine the mapping of virtual modifiers to core X protocol modifiers, use
<code class="function">XkbVirtualModsToReal</code>.
</p><a id="idm2072" class="indexterm"></a><div class="funcsynopsis"><a id="XkbVirtualModsToReal"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbVirtualModsToReal</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">virtual_mask</var>, unsigned int *<var class="pdparam">mask_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description for input device
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>virtual_mask</code></em>
    </span></p></td><td><p>
        virtual modifier mask to translate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mask_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with real modifiers
      </p></td></tr></tbody></table></div><p>
If the keyboard description defined by
<em class="parameter"><code>xkb</code></em>
includes bindings for virtual modifiers,
<code class="function">XkbVirtualModsToReal</code>
uses those bindings to determine the set of real modifiers that correspond to
the set of virtual modifiers specified in
<em class="parameter"><code>virtual_mask</code></em>.
The
<em class="parameter"><code>virtual_mask</code></em>
parameter is a mask specifying the virtual modifiers to translate; the i-th
bit (0 relative) of the mask represents the i-th virtual modifier. If
<em class="parameter"><code>mask_rtrn</code></em>
is non-
<span class="symbol">NULL</span>,
<code class="function">XkbVirtualModsToReal</code>
backfills it with the resulting real modifier mask. If the keyboard
description in
<em class="parameter"><code>xkb</code></em>
does not include virtual modifier bindings,
<code class="function">XkbVirtualModsToReal</code>
returns
<span class="symbol">False</span>;
otherwise, it returns
<span class="symbol">True</span>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is possible for a local (client-side) keyboard description (the
<em class="parameter"><code>xkb</code></em>
parameter) to not contain any virtual modifier information (simply because the
client has not requested it) while the server’s corresponding definition may
contain virtual modifier information. </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Inactive_Modifier_Sets"></a>Inactive Modifier Sets</h3></div></div></div><p>
An unbound virtual modifier is one that is not bound to any real modifier
(
<em class="structfield"><code>server</code></em>-&gt;<em class="structfield"><code>vmods</code></em>
[virtual_modifier_index] is zero).
</p><p>
Some Xkb operations ignore modifier definitions in which the virtual modifiers
are unbound. Consider this example:

</p><div class="literallayout"><p>        if (state matches {Shift}) Do OneThing;<br />
        if (state matches {Shift+NumLock}) Do Another;<br />
</p></div><p>
</p><p>
If the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier is not bound to any real modifiers, the effective masks for
these two cases are identical (that is, contain only
<span class="symbol">Shift</span>).
When it is essential to distinguish between
<span class="emphasis"><em>OneThing</em></span>
and Another, Xkb considers only those modifier definitions for which all
virtual modifiers are bound.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Conventions"></a>Conventions</h2></div></div></div><a id="idm2129" class="indexterm"></a><p>
The Xkb extension does not require any specific virtual modifier names.
However, everyone benefits if the same names are used for common modifiers. The
following names are suggested:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="emphasis"><em>NumLock</em></span></td></tr><tr><td><span class="emphasis"><em>ScrollLock</em></span></td></tr><tr><td><span class="emphasis"><em>Alt</em></span></td></tr><tr><td><span class="emphasis"><em>Meta</em></span></td></tr><tr><td><span class="emphasis"><em>AltGr</em></span></td></tr><tr><td><span class="emphasis"><em>LevelThree</em></span></td></tr></table><p>
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Example"></a>Example</h2></div></div></div><p>
If the second (0-relative) entry in
<em class="structfield"><code>names.vmods</code></em>
contains the Atom for "NumLock", then 0x4 (1&lt;&lt;2) is the virtual modifier
bit for the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier. If
<em class="structfield"><code>server.vmods</code></em>
[2] contains
<span class="symbol">Mod3Mask</span>,
then the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier is bound to the
<span class="symbol">Mod3</span>
real modifier.
</p><p>
A virtual modifier definition for this example would have:
</p><pre class="literallayout">
     real_mods = 0
     vmods = 0x4 (NumLock named virtual modifier)
     mask = 0x20 (Mod3Mask)
</pre><p>
Continuing the example, if the keyboard has a
<span class="keysym">Num_Lock</span>
keysym bound to the key with keycode 14, and the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier is bound to this key,
<em class="structfield"><code>server.vmodmap[14]</code></em>
contains 0x4.
</p><p>
Finally, if the keyboard also used the real
<span class="symbol">Mod1</span>
modifier for numeric lock operations, the modifier definition below would
represent the situation where either the key bound to
<span class="symbol">Mod1</span>
or the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier could be used for this purpose:
</p><pre class="literallayout">
     real_mods = 0x8 (Mod1Mask)
     vmods = 0x4 (NumLock named virtual modifier)
     mask = 0x28 (Mod1Mask | Mod3Mask)
</pre></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Indicators"></a>Chapter 8. Indicators</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Indicator_Names">Indicator Names</a></span></dt><dt><span class="sect1"><a href="#Indicator_Data_Structures">Indicator Data Structures</a></span></dt><dd><dl><dt><span class="sect2"><a href="#XkbIndicatorRec">XkbIndicatorRec</a></span></dt><dt><span class="sect2"><a href="#XkbIndicatorMapRec">XkbIndicatorMapRec</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Information_About_Indicators">Getting Information About Indicators</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Getting_Indicator_State">Getting Indicator State</a></span></dt><dt><span class="sect2"><a href="#Getting_Indicator_Information_by_Index">Getting Indicator Information by Index</a></span></dt><dt><span class="sect2"><a href="#Getting_Indicator_Information_by_Name">Getting Indicator Information by Name</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Changing_Indicator_Maps_and_State">Changing Indicator Maps and State</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Effects_of_Explicit_Changes_on_Indicators">Effects of Explicit Changes on Indicators</a></span></dt><dt><span class="sect2"><a href="#Changing_Indicator_Maps_by_Index">Changing Indicator Maps by Index</a></span></dt><dt><span class="sect2"><a href="#Changing_Indicator_Maps_by_Name">Changing Indicator Maps by Name</a></span></dt><dt><span class="sect2"><a href="#XkbIndicatorChangesRec">The XkbIndicatorChangesRec Structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Changes_to_Indicator_State_or_Map">Tracking Changes to Indicator State or Map</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Indicator_Maps">Allocating and Freeing Indicator Maps</a></span></dt></dl></div><a id="idm2168" class="indexterm"></a><p>
Although the core X implementation supports up to 32 LEDs on an input device,
it does not provide any linkage between the state of the LEDs and the logical
state of the input device. For example, most keyboards have a
<span class="guilabel">CapsLock</span>
LED, but X does not provide a mechanism to make the LED automatically follow
the logical state of the
<span class="keycap"><strong>CapsLock</strong></span>
key.
</p><p>
Furthermore, the core X implementation does not provide clients with the
ability to determine what bits in the
<em class="structfield"><code>led_mask</code></em>
field of the
<span class="structname">XKeyboardState</span>
map to the particular LEDs on the keyboard. For example, X does not provide a
method for a client to determine what bit to set in the
<em class="structfield"><code>led_mask</code></em>
field to turn on the
<span class="guilabel">Scroll Lock</span>
LED or whether the keyboard even has a
<span class="guilabel">Scroll Lock</span>
LED.
</p><p>
Xkb provides indicator names and programmable indicators to help solve these
problems. Using Xkb, clients can determine the names of the various indicators,
determine and control the way that the individual indicators should be updated
to reflect keyboard changes, and determine which of the 32 keyboard indicators
reported by the protocol are actually present on the keyboard. Clients may also
request immediate notification of changes to the state of any subset of the
keyboard indicators, which makes it straightforward to provide an on-screen
<span class="quote">“<span class="quote">virtual</span>”</span> LED panel.
This chapter describes Xkb indicators and the functions
used for manipulating them.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Indicator_Names"></a>Indicator Names</h2></div></div></div><p>
Xkb provides the capability of symbolically naming indicators. Xkb itself
doesn’t use these symbolic names for anything; they are there only to help
make the keyboard description comprehensible to humans. To set the names of
specific indicators, use
<code class="function">XkbSetNames</code>
as discussed in <a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a>. Then set the map using
<code class="function">XkbSetMap</code>
(see <a class="link" href="#Changing_Map_Components_in_the_Server" title="Changing Map Components in the Server">section 14.3</a>)
or
<code class="function">XkbSetNamedIndicator</code>
(below). To retrieve indicator names, use
<code class="function">XkbGetNames</code>
(<a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a>).
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Indicator_Data_Structures"></a>Indicator Data Structures</h2></div></div></div><p>
Use the indicator description record,
<span class="structname">XkbIndicatorRec</span>,
and its indicator map,
<span class="structname">XkbIndicatorMapRec</span>,
to inquire about and control most indicator properties and behaviors.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="XkbIndicatorRec"></a>XkbIndicatorRec</h3></div></div></div><a id="idm2198" class="indexterm"></a><p>
The description for all the Xkb indicators is held in the
<em class="structfield"><code>indicators</code></em>
field of the complete keyboard description (see <a class="xref" href="#Complete_Keyboard_Description" title="Chapter 6. Complete Keyboard Description">Chapter 6, <em>Complete Keyboard Description</em></a>), which is defined
as follows:

</p><pre class="programlisting">
#define      XkbNumIndicators      32

typedef struct {
    unsigned long           phys_indicators;            /* LEDs existence */
    XkbIndicatorMapRec      maps[XkbNumIndicators];     /* indicator maps */
} <span class="structname">XkbIndicatorRec</span>, *XkbIndicatorPtr;
</pre><p>
This structure contains the
<em class="structfield"><code>phys_indicators</code></em>
field, which relates some information about the correspondence between
indicators and physical LEDs on the keyboard, and an array of indicator
<em class="structfield"><code>maps</code></em>,
one map per indicator.
</p><p>
The
<em class="structfield"><code>phys_indicators</code></em>
field indicates which indicators are bound to physical LEDs on the keyboard;
if a bit is set in
<em class="structfield"><code>phys_indicators</code></em>,
then the associated indicator has a physical LED associated with it. This
field is necessary because some indicators may not have corresponding physical
LEDs on the keyboard. For example, most keyboards have an LED for indicating
the state of
<span class="keycap"><strong>CapsLock</strong></span>,
but most keyboards do not have an LED that indicates the current group.
Because
<em class="structfield"><code>phys_indicators</code></em>
describes a physical characteristic of the keyboard, you cannot directly
change it under program control. However, if a client program loads a
completely new keyboard description via
<code class="function">XkbGetKeyboardByName</code>,
or if a new keyboard is attached and the X implementation notices,
<em class="structfield"><code>phys_indicators</code></em>
changes if the indicators for the new keyboard are different.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="XkbIndicatorMapRec"></a>XkbIndicatorMapRec</h3></div></div></div><a id="idm2218" class="indexterm"></a><p>
Each indicator has its own set of attributes that specify whether clients can
explicitly set its state and whether it tracks the keyboard state. The
attributes of each indicator are held in the
<em class="structfield"><code>maps</code></em>
array, which is an array of
<span class="structname">XkbIndicatorRec</span>
structures:

</p><pre class="programlisting">
typedef struct {
    unsigned char  flags;         /* how the indicator can be changed */
    unsigned char  which_groups;  /* match criteria for groups */
    unsigned char  groups;        /* which keyboard groups the indicator watches */
    unsigned char  which_mods;    /* match criteria for modifiers */
    XkbModsRec     mods;          /* which modifiers the indicator watches */
    unsigned int   ctrls;         /* which controls the indicator watches */
} <span class="structname">XkbIndicatorMapRec</span>, *XkbIndicatorMapPtr;
</pre><p>
This indicator map specifies for each indicator:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The conditions under which the keyboard modifier state affects the indicator
  </p></li><li class="listitem"><p>
The conditions under which the keyboard group state affects the indicator
  </p></li><li class="listitem"><p>
The conditions under which the state of the boolean controls affects the
indicator
  </p></li><li class="listitem"><p>
The effect (if any) of attempts to explicitly change the state of the indicator
using the functions
<code class="function">XkbSetControls</code>
or
<code class="function">XChangeKeyboardControl</code>

  </p></li></ul></div><p>
For more information on the effects of explicit changes to indicators and the
relationship to the indicator map, see <a class="link" href="#Effects_of_Explicit_Changes_on_Indicators" title="Effects of Explicit Changes on Indicators">section 8.4.1</a>.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="XkbIndicatorMapRec_flags_field"></a>XkbIndicatorMapRec flags field</h4></div></div></div><p>
The
<em class="structfield"><code>flags</code></em>
field specifies the conditions under which the indicator can be changed and
the effects of changing the indicator. The valid values for
<em class="structfield"><code>flags</code></em>
and their effects are shown in <a class="link" href="#table8.1" title="Table 8.1. XkbIndicatorMapRec flags Field">Table 8.1</a>.
</p><div class="table"><a id="table8.1"></a><p class="title"><strong>Table 8.1. XkbIndicatorMapRec flags Field</strong></p><div class="table-contents"><table class="table" summary="XkbIndicatorMapRec flags Field" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Value</th><th align="left"> </th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbIM_NoExplicit</span></td><td align="left">(1L&lt;&lt;7)</td><td align="left">Client applications cannot change the state of the indicator.</td></tr><tr><td align="left"><span class="symbol">XkbIM_NoAutomatic</span></td><td align="left">(1L&lt;&lt;6)</td><td align="left">Xkb does not automatically change the value of the indicator based
upon a change in the keyboard state, regardless of the values for the other
fields of the indicator map.</td></tr><tr><td align="left"><span class="symbol">XkbIM_LEDDrivesKB</span></td><td align="left">(1L&lt;&lt;5)</td><td align="left">A client application changing the state of the indicator causes the
state of the keyboard to change.</td></tr></tbody></table></div></div><br class="table-break" /><p>
Note that if
<span class="symbol">XkbIM_NoAutomatic</span>
is not set, by default the indicator follows the keyboard state.
</p><p>
If
<span class="symbol">XkbIM_LEDDrivesKB</span>
is set and
<span class="symbol">XkbIM_NoExplicit</span>
is not, and if you call a function which updates the server’s image of the
indicator map (such as
<code class="function">XkbSetIndicatorMap</code>
or
<code class="function">XkbSetNamedIndicator</code>),
Xkb changes the keyboard state and controls to reflect the other fields of
the indicator map, as described in the remainder of this section. If you
attempt to explicitly change the value of an indicator for which
<span class="symbol">XkbIM_LEDDrivesKB</span>
is absent or for which
<span class="symbol">XkbIM_NoExplicit</span>
is present, keyboard state or controls are unaffected.
</p><p>
For example, a keyboard designer may want to make the
<span class="guilabel">CapsLock</span>
LED controllable only by the server, but allow the
<span class="guilabel">Scroll Lock</span>
LED to be controlled by client applications. To do so, the keyboard designer
could set the
<span class="symbol">XkbIM_NoExplicit</span>
flag for the
<span class="guilabel">CapsLock</span>
LED, but not set it for the
<span class="guilabel">Scroll Lock</span>
LED. Or the keyboard designer may wish to allow the
<span class="guilabel">CapsLock</span>
LED to be controlled by both the server and client applications and also have
the server to automatically change the
<span class="emphasis"><em>CapsLock</em></span>

modifier state whenever a client application changes the
<span class="guilabel">CapsLock</span>
LED. To do so, the keyboard designer would not set the
<span class="symbol">XkbIM_NoExplicit</span>
flag, but would instead set the
<span class="symbol">XkbIM_LEDDrivesKB</span>
flag.
</p><p>
The remaining fields in the indicator map specify the conditions under which
Xkb automatically turns an indicator on or off (only if
<span class="symbol">XkbIM_NoAutomatic</span>
is not set). If these conditions match the keyboard state, Xkb turns the
indicator on. If the conditions do not match, Xkb turns the indicator off.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="XkbIndicatorMapRec_which_groups_and_groups_fields"></a>XkbIndicatorMapRec which_groups and groups fields</h4></div></div></div><p>
The
<em class="structfield"><code>which_groups</code></em>
and the
<em class="structfield"><code>groups</code></em>
fields of an indicator map determine how the keyboard group state affects the
corresponding indicator. The
<em class="structfield"><code>which_groups</code></em>
field controls the interpretation of
<em class="structfield"><code>groups</code></em>
and may contain any one of the following values:

</p><pre class="programlisting">
#define XkbIM_UseNone             0
#define XkbIM_UseBase             (1L &lt;&lt; 0)
#define XkbIM_UseLatched          (1L &lt;&lt; 1)
#define XkbIM_UseLocked           (1L &lt;&lt; 2)
#define XkbIM_UseEffective        (1L &lt;&lt; 3)
#define XkbIM_UseAnyGroup         XkbIM_UseLatched | XkbIM_UseLocked |
                                  XkbIM_UseEffective
</pre><p>
The
<em class="structfield"><code>groups</code></em>
field specifies what keyboard groups an indicator watches and is the bitwise
inclusive OR of the following valid values:

</p><pre class="programlisting">
#define XkbGroup1Mask            (1&lt;&lt;0)
#define XkbGroup2Mask            (1&lt;&lt;1)
#define XkbGroup3Mask            (1&lt;&lt;2)
#define XkbGroup4Mask            (1&lt;&lt;3)
#define XkbAnyGroupMask          (1&lt;&lt;7)
#define XkbAllGroupsMask         (0xf)
</pre><p>
If
<span class="symbol">XkbIM_NoAutomatic</span>
is not set (the keyboard drives the indicator), the effect of
<em class="structfield"><code>which_groups</code></em>
and
<em class="structfield"><code>groups</code></em>
is shown in <a class="link" href="#table8.2" title="Table 8.2. XkbIndicatorMapRec which_groups and groups, Keyboard Drives Indicator">Table 8.2</a>.
</p><div class="table"><a id="table8.2"></a><p class="title"><strong>Table 8.2. XkbIndicatorMapRec which_groups and groups, Keyboard Drives
Indicator</strong></p><div class="table-contents"><table class="table" summary="XkbIndicatorMapRec which_groups and groups, Keyboard Drives&#10;Indicator" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">which_groups</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbIM_UseNone</span></td><td align="left">
The
<em class="structfield"><code>groups</code></em>
field and the current keyboard group state are ignored.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseBase</span></td><td align="left">
If
<em class="structfield"><code>groups</code></em>
is nonzero, the indicator is lit whenever the base keyboard group is nonzero.
If
<em class="structfield"><code>groups</code></em>
is zero, the indicator is lit whenever the base keyboard group is zero.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLatched</span></td><td align="left">
If
<em class="structfield"><code>groups</code></em>
is nonzero, the indicator is lit whenever the latched keyboard group is
nonzero. If
<em class="structfield"><code>groups</code></em>
is zero, the indicator is lit whenever the latched keyboard group is zero.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLocked</span></td><td align="left">
The
<em class="structfield"><code>groups</code></em>
field is interpreted as a mask. The indicator is lit when the current locked
keyboard group matches one of the bits that are set in
<em class="structfield"><code>groups</code></em>.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseEffective</span></td><td align="left">
The
<em class="structfield"><code>groups</code></em>
field is interpreted as a mask. The indicator is lit when the current
effective keyboard group matches one of the bits that are set in
<em class="structfield"><code>groups</code></em>.
</td></tr></tbody></table></div></div><br class="table-break" /><p>
The effect of
<em class="structfield"><code>which_groups</code></em>
and
<em class="structfield"><code>groups</code></em>
when you change an indicator for which
<span class="symbol">XkbIM_LEDDrivesKB</span>
is set (the indicator drives the keyboard) is shown in
<a class="link" href="#table8.3" title="Table 8.3. XkbIndicatorMapRec which_groups and groups, Indicator Drives Keyboard">Table 8.3</a>. The <span class="quote">“<span class="quote">New State</span>”</span>
column refers to the new state to which you set the indicator.
</p><div class="table"><a id="table8.3"></a><p class="title"><strong>Table 8.3. XkbIndicatorMapRec which_groups and groups, Indicator Drives
Keyboard</strong></p><div class="table-contents"><table class="table" summary="XkbIndicatorMapRec which_groups and groups, Indicator Drives&#10;Keyboard" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">which_groups</th><th align="left">New State</th><th align="left">Effect on Keyboard Group State</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbIM_UseNone</span></td><td align="left">On or Off</td><td align="left">No effect</td></tr><tr><td align="left"><span class="symbol">XkbIM_UseBase</span></td><td align="left">On or Off</td><td align="left">No effect</td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLatched</span></td><td align="left">On</td><td align="left">
The
<em class="structfield"><code>groups</code></em>
field is treated as a group mask. The keyboard group latch is changed to the
lowest numbered group specified in
<em class="structfield"><code>groups</code></em>;
if
<em class="structfield"><code>groups</code></em>
is empty, the keyboard group latch is changed to zero.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLatched</span></td><td align="left">Off</td><td align="left">
The
<em class="structfield"><code>groups</code></em>
field is treated as a group mask. If the indicator is explicitly extinguished,
keyboard group latch is changed to the lowest numbered group not specified in
<em class="structfield"><code>groups</code></em>;
if
<em class="structfield"><code>groups</code></em>
is zero, the keyboard group latch is set to the index of the highest legal
keyboard group.
    </td></tr><tr><td align="left">XkbIM_UseLocked or XkbIM_UseEffective</td><td align="left">On</td><td align="left">
If the
<em class="structfield"><code>groups</code></em>
mask is empty, group is not changed; otherwise, the locked keyboard group is
changed to the lowest numbered group specified in
<em class="structfield"><code>groups</code></em>.
    </td></tr><tr><td align="left">XkbIM_UseLocked or XkbIM_UseEffective</td><td align="left">Off</td><td align="left">
Locked keyboard group is changed to the lowest numbered group that is not
specified in the
<em class="structfield"><code>groups</code></em>
mask, or to
<span class="emphasis"><em>Group1</em></span>
if the
<em class="structfield"><code>groups</code></em>
mask contains all keyboard groups.
    </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="XkbIndicatorMapRec_which_mods_and_mods_fields"></a>XkbIndicatorMapRec which_mods and mods fields</h4></div></div></div><p>
The
<em class="structfield"><code>mods</code></em>
field specifies what modifiers an indicator watches. The
<em class="structfield"><code>mods</code></em>
field is an Xkb modifier definition,
<span class="structname">XkbModsRec</span>,
as described in <a class="link" href="#Modifier_Definitions" title="Modifier Definitions">section 7.2</a>, which can specify both real and virtual
modifiers. The
<em class="structfield"><code>mods</code></em>
field takes effect even if some or all of the virtual indicators specified in
<em class="structfield"><code>mods</code></em>
are unbound. To specify the mods field, in general, assign the modifiers of
interest to
<em class="structfield"><code>mods.real_mods</code></em>
and the virtual modifiers of interest to
<em class="structfield"><code>mods.vmods</code></em>.
You can disregard the
<em class="structfield"><code>mods.mask</code></em>
field unless your application needs to interpret the indicator map directly
(that is, to simulate automatic indicator behavior on its own). Relatively few
applications need to do so, but if you find it necessary, you can either read
the indicator map back from the server after you update it (the server
automatically updates the mask field whenever any of the real or virtual
modifiers are changed in the modifier definition) or you can use
<code class="function">XkbVirtualModsToReal</code>
to determine the proper contents for the mask field, assuming that the
<span class="structname">XkbDescRec</span>
contains the virtual modifier definitions.
</p><p>
<em class="structfield"><code>which_mods</code></em>
specifies what criteria Xkb uses to determine a match with the corresponding
<em class="structfield"><code>mods</code></em>
field by specifying one or more components of the Xkb keyboard state. If
<span class="symbol">XkbIM_NoAutomatic</span>
is not set (the keyboard drives the indicator), the indicator is lit whenever
any of the modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of the
<em class="structfield"><code>mods</code></em>
modifier definition are also set in any of the current keyboard state
components specified by
<em class="structfield"><code>which_mods</code></em>.
Remember that the
<em class="structfield"><code>mask</code></em>
field is comprised of all of the real modifiers specified in the definition
plus any real modifiers that are bound to the virtual modifiers specified in
the definition. (See <a class="xref" href="#Keyboard_State" title="Chapter 5. Keyboard State">Chapter 5, <em>Keyboard State</em></a> for more information on the keyboard state and
<a class="xref" href="#Virtual_Modifiers" title="Chapter 7. Virtual Modifiers">Chapter 7, <em>Virtual Modifiers</em></a> for more information on virtual modifiers.) Use a bitwise inclusive
OR of the following values to compose a value for
<em class="structfield"><code>which_mods</code></em>:

</p><pre class="programlisting">
#define XkbIM_UseNone             0
#define XkbIM_UseBase             (1L &lt;&lt; 0)
#define XkbIM_UseLatched          (1L &lt;&lt; 1)
#define XkbIM_UseLocked           (1L &lt;&lt; 2)
#define XkbIM_UseEffective        (1L &lt;&lt; 3)
#define XkbIM_UseCompat           (1L &lt;&lt; 4)
#define XkbIM_UseAnyMods          XkbIM_UseBase | XkbIM_UseLatched |
                                  XkbIM_UseLocked | XkbIM_UseEffective |
                                  XkbIM_UseCompat
</pre><p>
If
<span class="symbol">XkbIM_NoAutomatic</span>
is not set (the keyboard drives the indicator), the effect of
<em class="structfield"><code>which_mods</code></em>
and
<em class="structfield"><code>mods</code></em>
is shown in <a class="link" href="#table8.4" title="Table 8.4. XkbIndicatorMapRec which_mods and mods, Keyboard Drives Indicator">Table 8.4</a>
</p><div class="table"><a id="table8.4"></a><p class="title"><strong>Table 8.4. XkbIndicatorMapRec which_mods and mods, Keyboard Drives Indicator</strong></p><div class="table-contents"><table class="table" summary="XkbIndicatorMapRec which_mods and mods, Keyboard Drives Indicator" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">which_mods</th><th align="left">Effect on Keyboard Modifiers</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbIM_UseNone</span></td><td align="left">The mods field and the current keyboard modifier state are
ignored.</td></tr><tr><td align="left"><span class="symbol">XkbIM_UseBase</span></td><td align="left">
The indicator is lit when any of the modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are on in the keyboard base state. If both
<em class="structfield"><code>mods.real_mods</code></em>
and
<em class="structfield"><code>mods.vmods</code></em>
are zero, the indicator is lit when the base keyboard state contains no
modifiers.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLatched</span></td><td align="left">
The indicator is lit when any of the modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are latched. If both
<em class="structfield"><code>mods.real_mods</code></em>
and
<em class="structfield"><code>mods.vmods</code></em>
are zero, the indicator is lit when none of the modifier keys are latched.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLocked</span></td><td align="left">
The indicator is lit when any of the modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are locked. If both
<em class="structfield"><code>mods.real_mods</code></em>
and
<em class="structfield"><code>mods.vmods</code></em>
are zero, the indicator is lit when none of the modifier keys are locked.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseEffective</span></td><td align="left">
The indicator is lit when any of the modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are in the effective keyboard state. If both
<em class="structfield"><code>mods.real_mods</code></em>
and
<em class="structfield"><code>mods.vmods</code></em>
are zero, the indicator is lit when the effective keyboard state contains no
modifiers.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseCompat</span></td><td align="left">
The indicator is lit when any of the modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are in the keyboard compatibility state. If both
<em class="structfield"><code>mods.real_mods</code></em>
and
<em class="structfield"><code>mods.vmods</code></em>
are zero, the indicator is lit when the keyboard compatibility state contains
no modifiers.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The effect on the keyboard modifiers of
<em class="structfield"><code>which_mods</code></em>
and
<em class="structfield"><code>mods</code></em>
when you change an indicator for which
<span class="symbol">XkbIM_LEDDrivesKB</span>
is set (the indicator drives the keyboard) is shown in
<a class="link" href="#table8.5" title="Table 8.5. XkbIndicatorMapRec which_mods and mods, Indicator Drives Keyboard">Table 8.5</a>. The <span class="quote">“<span class="quote">New State</span>”</span>
column refers to the new state to which you set the indicator.
</p><div class="table"><a id="table8.5"></a><p class="title"><strong>Table 8.5. XkbIndicatorMapRec which_mods and mods, Indicator Drives Keyboard</strong></p><div class="table-contents"><table class="table" summary="XkbIndicatorMapRec which_mods and mods, Indicator Drives Keyboard" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">which_mods</th><th align="left">New State</th><th align="left">Effect on Keyboard Modifiers</th></tr></thead><tbody><tr><td align="left">XkbIM_UseNone or XkbIM_UseBase</td><td align="left">On or Off</td><td align="left">No Effect</td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLatched</span></td><td align="left">On</td><td align="left">
Any modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are added to the latched modifiers.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLatched</span></td><td align="left">Off</td><td align="left">
Any modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are removed from the latched modifiers.
    </td></tr><tr><td align="left">XkbIM_UseLocked, XkbIM_UseCompat, or XkbIM_UseEffective</td><td align="left">On</td><td align="left">
Any modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are added to the locked modifiers.
    </td></tr><tr><td align="left"><span class="symbol">XkbIM_UseLocked</span></td><td align="left">Off</td><td align="left">
Any modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are removed from the locked modifiers.
    </td></tr><tr><td align="left">XkbIM_UseCompat or XkbIM_UseEffective</td><td align="left">Off</td><td align="left">
Any modifiers specified in the
<em class="structfield"><code>mask</code></em>
field of
<em class="structfield"><code>mods</code></em>
are removed from both the locked and latched modifiers.
    </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="XkbIndicatorMapRec_ctrls_field"></a>XkbIndicatorMapRec ctrls field</h4></div></div></div><p>
The
<em class="structfield"><code>ctrls</code></em>
field specifies what controls (see <a class="xref" href="#Keyboard_Controls" title="Chapter 10. Keyboard Controls">Chapter 10, <em>Keyboard Controls</em></a>) the indicator watches and is
composed using the bitwise inclusive OR of the following values:

</p><pre class="programlisting">
#define XkbRepeatKeysMask           (1L &lt;&lt; 0)
#define XkbSlowKeysMask             (1L &lt;&lt; 1)
#define XkbBounceKeysMask           (1L &lt;&lt; 2)
#define XkbStickyKeysMask           (1L &lt;&lt; 3)
#define XkbMouseKeysMask            (1L &lt;&lt; 4)
#define XkbMouseKeysAccelMask       (1L &lt;&lt; 5)
#define XkbAccessXKeysMask          (1L &lt;&lt; 6)
#define XkbAccessXTimeoutMask       (1L &lt;&lt; 7)
#define XkbAccessXFeedbackMask      (1L &lt;&lt; 8)
#define XkbAudibleBellMask          (1L &lt;&lt; 9)
#define XkbOverlay1Mask             (1L &lt;&lt; 10)
#define XkbOverlay2Mask             (1L &lt;&lt; 11)
#define XkbAllBooleanCtrlsMask      (0x00001FFF)
</pre><p>
Xkb lights the indicator whenever any of the boolean controls specified in
<em class="structfield"><code>ctrls</code></em>
is enabled.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Getting_Information_About_Indicators"></a>Getting Information About Indicators</h2></div></div></div><p>
Xkb allows applications to obtain information about indicators using two
different methods. The first method, which is similar to the core X
implementation, uses a mask to specify the indicators. The second method, which
is more suitable for applications concerned with interoperability, uses
indicator names. The correspondence between the indicator name and the bit
position in masks is as follows: one of the parameters returned from
<code class="function">XkbGetNamedIndicator</code>
is an index that is the bit position to use in any function call that requires
a mask of indicator bits, as well as the indicator’s index into the
<span class="structname">XkbIndicatorRec</span>
array of indicator maps.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Getting_Indicator_State"></a>Getting Indicator State</h3></div></div></div><p>
Because the state of the indicators is relatively volatile, the keyboard
description does not hold the current state of the indicators. To obtain the
current state of the keyboard indicators, use
<code class="function">XkbGetIndicatorState</code>.
</p><a id="idm2564" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetIndicatorState"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetIndicatorState</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int *<var class="pdparam">state_return</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state_return</code></em>
    </span></p></td><td><p>
        backfilled with a mask of the indicator state
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetIndicatorState</code>
queries the
<em class="parameter"><code>display</code></em>
for the state of the indicators on the device specified by the
<em class="parameter"><code>device_spec</code></em>.
For each indicator that is <span class="quote">“<span class="quote">turned on</span>”</span> on the device,
the associated bit is set in
<em class="parameter"><code>state_return</code></em>.
If a compatible version of the Xkb extension is not available in the server,
<code class="function">XkbGetIndicatorState</code>
returns a
<span class="errorname">BadMatch</span>
error. Otherwise, it sends the request to the X server, places the state of
the indicators into
<em class="parameter"><code>state_return</code></em>,
and returns
<span class="symbol">Success</span>.
Thus the value reported by
<code class="function">XkbGetIndicatorState</code>
is identical to the value reported by the core protocol.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Getting_Indicator_Information_by_Index"></a>Getting Indicator Information by Index</h3></div></div></div><p>
To get the map for one or more indicators, using a mask to specify the
indicators, use
<code class="function">XkbGetIndicatorMap</code>.
</p><a id="idm2609" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetIndicatorMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetIndicatorMap</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">desc</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of indicators for which maps should be returned
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>desc</code></em>
    </span></p></td><td><p>
        keyboard description to be updated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetIndicatorMap</code>
obtains the maps from the server for only those indicators specified by the
<em class="parameter"><code>which</code></em>
mask and copies the values into the keyboard description specified by
<em class="parameter"><code>desc</code></em>.
If the
<em class="structfield"><code>indicators</code></em>
field of the
<em class="parameter"><code>desc</code></em>
parameter is
<span class="symbol">NULL</span>,
<code class="function">XkbGetIndicatorMap</code>
allocates and initializes it.
</p><p>
<code class="function">XkbGetIndicatorMap</code>
can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadLength</span>,
<span class="errorname">BadMatch</span>,
and
<span class="errorname">BadImplementation</span>
errors.
</p><p>
To free the indicator maps, use
<code class="function">XkbFreeIndicatorMaps</code>
(see <a class="link" href="#Allocating_and_Freeing_Indicator_Maps" title="Allocating and Freeing Indicator Maps">section 8.6</a>).
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Getting_Indicator_Information_by_Name"></a>Getting Indicator Information by Name</h3></div></div></div><p>
Xkb also allows applications to refer to indicators by name. Use
<code class="function">XkbGetNames</code>
to get the indicator names (see <a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a>). Using names eliminates the need
for hard-coding bitmask values for particular keyboards. For example, instead
of using vendor-specific constants such as
<span class="symbol">WSKBLed_ScrollLock</span>
mask on Digital workstations or
<span class="symbol">XLED_SCROLL_LOCK</span>
on Sun workstations, you can instead use
<code class="function">XkbGetNamedIndicator</code>
to look up information on the indicator named <span class="quote">“<span class="quote">Scroll Lock.</span>”</span>
</p><p>
Use
<code class="function">XkbGetNamedIndicator</code>
to look up the indicator map and other information for an indicator by name.
</p><a id="idm2666" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetNamedIndicator"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetNamedIndicator</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">device_spec</var>, Atom <var class="pdparam">name</var>, int *<var class="pdparam">ndx_rtrn</var>, Bool *<var class="pdparam">state_rtrn</var>, XkbIndicatorMapPtr <var class="pdparam">map_rtrn</var>, Bool *<var class="pdparam">real_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        keyboard device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the indicator to be retrieved
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ndx_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the index of the retrieved indicator
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the current state of the retrieved indicator
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>map_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the mapping for the retrieved indicator
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>real_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with <span class="symbol">True</span>
         if the named indicator is real (physical)
      </p></td></tr></tbody></table></div><p>
If the device specified by
<em class="parameter"><code>device_spec</code></em>
has an indicator named
<em class="parameter"><code>name</code></em>,
<code class="function">XkbGetNamedIndicator</code>
returns
<span class="symbol">True</span>
and populates the rest of the parameters with information about the indicator.
Otherwise,
<code class="function">XkbGetNamedIndicator</code>
returns
<span class="symbol">False</span>.
</p><p>
The
<em class="parameter"><code>ndx_rtrn</code></em>
field returns the zero-based index of the named indicator. This index is the
bit position to use in any function call that requires a mask of indicator
bits, as well as the indicator’s index into the
<span class="structname">XkbIndicatorRec</span>
array of indicator maps.
<em class="parameter"><code>state_rtrn</code></em>
returns the current state of the named indicator
(<span class="symbol">True</span>
= on,
<span class="symbol">False</span>
= off).
<em class="parameter"><code>map_rtrn</code></em>
returns the indicator map for the named indicator. In addition, if the
indicator is mapped to a physical LED, the
<em class="parameter"><code>real_rtrn</code></em>
parameter is set to
<span class="symbol">True</span>.
</p><p>
Each of the "<em class="parameter"><code>_rtrn</code></em>" arguments is optional; you can pass
<span class="symbol">NULL</span>
for any unneeded "<em class="parameter"><code>_rtrn</code></em>" arguments.
</p><p>
<code class="function">XkbGetNamedIndicator</code>
can generate
<span class="errorname">BadAtom</span>
and
<span class="errorname">BadImplementation</span>
errors.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Changing_Indicator_Maps_and_State"></a>Changing Indicator Maps and State</h2></div></div></div><p>
Just as you can get the indicator map using a mask or using an indicator name,
so you can change it using a mask or a name.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You cannot change the
<em class="structfield"><code>phys_indicators</code></em>
field of the indicators structure. The only way to change the
<em class="structfield"><code>phys_indicators</code></em>
field is to change the keyboard map.</p></div><p>
There are two ways to make changes to indicator maps and state: either change a
local copy of the indicator maps and use
<code class="function">XkbSetIndicatorMap</code>
or
<code class="function">XkbSetNamedIndicator</code>,
or, to reduce network traffic, use an
<span class="structname">XkbIndicatorChangesRec</span>
structure and use
<code class="function">XkbChangeIndicators</code>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Effects_of_Explicit_Changes_on_Indicators"></a>Effects of Explicit Changes on Indicators</h3></div></div></div><p>
This section discusses the effects of explicitly changing indicators depending
upon different settings in the indicator map. See
<a class="link" href="#table8.3" title="Table 8.3. XkbIndicatorMapRec which_groups and groups, Indicator Drives Keyboard">Table 8.3</a> and
<a class="link" href="#table8.5" title="Table 8.5. XkbIndicatorMapRec which_mods and mods, Indicator Drives Keyboard">Table 8.5</a> for
information on the effects of the indicator map fields when explicit changes
are made.
</p><p>
If
<span class="symbol">XkbIM_LEDDrivesKB</span>
is set and
<span class="symbol">XkbIM_NoExplicit</span>
is not, and if you call a function that updates the server’s image of the
indicator map (such as
<code class="function">XkbSetIndicatorMap</code>
or
<code class="function">XkbSetNamedIndicator</code>),
Xkb changes the keyboard state and controls to reflect the other fields of
the indicator map. If you attempt to explicitly change the value of an
indicator for which
<span class="symbol">XkbIM_LEDDrivesKB</span>
is absent or for which
<span class="symbol">XkbIM_NoExplicit</span>
is present, keyboard state or controls are unaffected.
</p><p>
If neither
<span class="symbol">XkbIM_NoAutomatic</span>
nor
<span class="symbol">XkbIM_NoExplicit</span>
is set in an indicator map, Xkb honors any request to change the state of the
indicator, but the new state might be immediately superseded by automatic
changes to the indicator state if the keyboard state or controls change.
</p><p>
The effects of changing an indicator that drives the keyboard are cumulative;
it is possible for a single change to affect keyboard group, modifiers, and
controls simultaneously.
</p><p>
If you change an indicator for which both the
<span class="symbol">XkbIM_LEDDrivesKB</span>
and
<span class="symbol">XkbIM_NoAutomatic</span>
flags are specified, Xkb applies the keyboard changes specified in the other
indicator map fields and changes the indicator to reflect the state that was
explicitly requested. The indicator remains in the new state until it is
explicitly changed again.
</p><p>
If the
<span class="symbol">XkbIM_NoAutomatic</span>
flag is not set and
<span class="symbol">XkbIM_LEDDrivesKB</span>
is set, Xkb applies the changes specified in the other indicator map fields
and sets the state of the indicator to the values specified by the indicator
map. Note that it is possible in this case for the indicator to end up in a
different state than the one that was explicitly requested. For example, Xkb
does not extinguish an indicator with
<em class="structfield"><code>which_mods</code></em>
of
<span class="symbol">XkbIM_UseBase</span>
and
<em class="structfield"><code>mods</code></em>
of
<span class="symbol">Shift</span>
if, at the time Xkb processes the request to extinguish the indicator, one of
the
<span class="symbol">Shift</span>
keys is physically depressed.
</p><p>
If you explicitly light an indicator for which
<span class="symbol">XkbIM_LEDDrivesKB</span>
is set, Xkb enables all of the boolean controls specified in the
<em class="structfield"><code>ctrls</code></em>
field of its indicator map. Explicitly extinguishing such an indicator causes
Xkb to disable all of the boolean controls specified in
<em class="structfield"><code>ctrls</code></em>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_Indicator_Maps_by_Index"></a>Changing Indicator Maps by Index</h3></div></div></div><p>
To update the maps for one or more indicators, first modify a local copy of the
keyboard description, then use
<code class="function">XkbSetIndicatorMap</code>
to download the changes to the server:
</p><a id="idm2796" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetIndicatorMap"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetIndicatorMap</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">desc</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of indicators to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>desc</code></em>
    </span></p></td><td><p>
        keyboard description from which the maps are taken
      </p></td></tr></tbody></table></div><p>
For each
bit set in the
<em class="parameter"><code>which</code></em>
parameter,
<code class="function">XkbSetIndicatorMap</code>
sends the corresponding indicator map from the
<em class="parameter"><code>desc</code></em>
parameter to the server.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_Indicator_Maps_by_Name"></a>Changing Indicator Maps by Name</h3></div></div></div><p>
<code class="function">XkbSetNamedIndicator</code>
can do several related things:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Name an indicator if it is not already named
  </p></li><li class="listitem"><p>
Toggle the state of the indicator
  </p></li><li class="listitem"><p>
Set the indicator to a specified state
  </p></li><li class="listitem"><p>
Set the indicator map for the indicator
  </p></li></ul></div><a id="idm2842" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetNamedIndicator"></a><p><code class="funcdef">Bool<strong class="fsfunc">XkbSetNamedIndicator</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">device_spec</var>, Atom <var class="pdparam">name</var>, Bool <var class="pdparam">change_state</var>, Bool <var class="pdparam">state</var>, Bool <var class="pdparam">create_new</var>, XkbIndicatorMapPtr <var class="pdparam">map</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the indicator to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>change_state</code></em>
    </span></p></td><td><p>
        whether to change the indicator state or not
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state</code></em>
    </span></p></td><td><p>
        desired new state for the indicator
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>create_new</code></em>
    </span></p></td><td><p>
        whether a new indicator with the specified name should be
        created when necessary
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>map</code></em>
    </span></p></td><td><p>
        new map for the indicator
      </p></td></tr></tbody></table></div><p>
If a compatible version of the Xkb extension is not available in the server,
<code class="function">XkbSetNamedIndicator</code>
returns
<span class="symbol">False</span>.
Otherwise, it sends a request to the X server to change the indicator
specified by
<em class="parameter"><code>name</code></em>
and returns
<span class="symbol">True</span>.
</p><p>
If
<em class="parameter"><code>change_state</code></em>
is
<span class="symbol">True</span>,
and the optional parameter,
<em class="parameter"><code>state</code></em>,
is not
<span class="symbol">NULL</span>,
<code class="function">XkbSetNamedIndicator</code>
tells the server to change the state of the named indicator to the value
specified by
<em class="parameter"><code>state</code></em>.
</p><p>
If an indicator with the name specified by
<em class="parameter"><code>name</code></em>
does not already exist, the
<em class="parameter"><code>create_new</code></em>
parameter tells the server whether it should create a new named indicator. If
<em class="parameter"><code>create_new</code></em>
is
<span class="symbol">True</span>,
the server finds the first indicator that doesn’t have a name and gives it
the name specified by
<em class="parameter"><code>name</code></em>.
</p><p>
If the optional parameter,
<em class="parameter"><code>map</code></em>,
is not
<span class="symbol">NULL</span>,
<code class="function">XkbSetNamedIndicator</code>
tells the server to change the indicator’s map to the values specified
in <em class="parameter"><code>map</code></em>.
</p><p>
<code class="function">XkbSetNamedIndicator</code>
can generate
<span class="errorname">BadAtom</span>
and
<span class="errorname">BadImplementation</span>
errors. In addition, it can also generate
<span class="symbol">XkbIndicatorStateNotify</span>
(see <a class="link" href="#Tracking_Changes_to_Indicator_State_or_Map" title="Tracking Changes to Indicator State or Map">section 8.5</a>),
<span class="symbol">XkbIndicatorMapNotify</span>,
and
<span class="symbol">XkbNamesNotify</span>
events (see <a class="link" href="#Tracking_Name_Changes" title="Tracking Name Changes">section 18.5</a>).
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="XkbIndicatorChangesRec"></a>The XkbIndicatorChangesRec Structure</h3></div></div></div><a id="idm2934" class="indexterm"></a><p>
The
<span class="structname">XkbIndicatorChangesRec</span>
identifies small modifications to the indicator map. Use it with the function
<code class="function">XkbChangeIndicators</code>
to reduce the amount of traffic sent to the server.
</p><pre class="programlisting">
typedef struct _XkbIndicatorChanges {
    unsigned int             state_changes;
    unsigned int             map_changes;
} <span class="structname">XkbIndicatorChangesRec</span>,*XkbIndicatorChangesPtr;
</pre><p>
The
<em class="structfield"><code>state_changes</code></em>
field is a mask that specifies the indicators that have changed state, and
<em class="structfield"><code>map_changes</code></em>
is a mask that specifies the indicators whose maps have changed.
</p><p>
To change indicator maps or state without passing the entire keyboard
description, use
<code class="function">XkbChangeIndicators</code>.
</p><a id="idm2948" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeIndicators"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbChangeIndicators</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbIndicatorChangesPtr <var class="pdparam">changes</var>, unsigned int <var class="pdparam">state</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description from which names are to be  taken.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        indicators to be updated on the server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state</code></em>
    </span></p></td><td><p>
        new state of indicators listed in <em class="parameter"><code>changes</code></em>-&gt;<em class="structfield"><code>state_changes</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbChangeIndicators</code>
copies any maps specified by
<em class="parameter"><code>changes</code></em>
from the keyboard description,
<em class="parameter"><code>xkb</code></em>,
to the server specified by
<em class="parameter"><code>dpy</code></em>.
If any bits are set in the
<em class="structfield"><code>state_changes</code></em>
field of
<em class="parameter"><code>changes</code></em>,
<code class="function">XkbChangeIndicators</code>
also sets the state of those indicators to the values specified in the
<em class="parameter"><code>state</code></em>
mask. A 1 bit in
<em class="parameter"><code>state</code></em>
turns the corresponding indicator on, a 0 bit turns it off.
</p><p>
<code class="function">XkbChangeIndicators</code>
can generate
<span class="errorname">BadAtom</span>
and
<span class="errorname">BadImplementation</span>
errors. In addition, it can also generate
<span class="symbol">XkbIndicatorStateNotify</span>
and
<span class="symbol">XkbIndicatorMapNotify</span>
events (see <a class="link" href="#Tracking_Changes_to_Indicator_State_or_Map" title="Tracking Changes to Indicator State or Map">section 8.5</a>).
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Changes_to_Indicator_State_or_Map"></a>Tracking Changes to Indicator State or Map</h2></div></div></div><a id="idm3005" class="indexterm"></a><a id="idm3009" class="indexterm"></a><a id="idm3012" class="indexterm"></a><a id="idm3016" class="indexterm"></a><p>
Whenever an indicator changes state, the server sends
<span class="symbol">XkbIndicatorStateNotify</span>
events to all interested clients. Similarly, whenever an indicator’s map
changes, the server sends
<span class="symbol">XkbIndicatorMapNotify</span>
events to all interested clients.
</p><p>
To receive
<span class="symbol">XkbIndicatorStateNotify</span>
events, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) with both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
parameters containing
<span class="symbol">XkbIndicatorStateNotifyMask</span>.
To receive
<span class="symbol">XkbIndicatorMapNotify</span>
events, use
<code class="function">XkbSelectEvents</code>
with
<span class="symbol">XkbIndicatorMapNotifyMask</span>.
</p><p>
To receive events for only specific indicators, use
<code class="function">XkbSelectEventDetails</code>.
Set the
<em class="structfield"><code>event_type</code></em>
parameter to
<span class="symbol">XkbIndicatorStateNotify</span>
or
<span class="symbol">XkbIndicatorMapNotify</span>,
and set both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
detail parameters to a mask where each bit specifies one indicator, turning on
those bits that specify the indicators for which you want to receive events.
</p><p>
Both types of indicator events use the same structure:

</p><pre class="programlisting">
typedef struct _XkbIndicatorNotify {
    int            type;        /* Xkb extension base event code */
    unsigned long  serial;      /* X server serial number for event */
    Bool           send_event;  /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;     /* server connection where event generated */
    Time           time;        /* server time when event generated */
    int            xkb_type;    /* specifies state or map notify */
    int            device;      /* Xkb device ID, will not be <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int   changed;     /* mask of indicators with new state or map */
    unsigned int   state;       /* current state of all indicators */
} <span class="structname">XkbIndicatorNotifyEvent</span>;
</pre><p>
<em class="structfield"><code>xkb_type</code></em>
is either
<span class="symbol">XkbIndicatorStateNotify</span>
or
<span class="symbol">XkbIndicatorMapNotify</span>,
depending on whether the event is a
<span class="symbol">XkbIndicatorStateNotify</span>
event or
<span class="symbol">XkbIndicatorMapNotify</span>,
event.
</p><p>
The
<em class="structfield"><code>changed</code></em>
parameter is a mask that is the bitwise inclusive OR of the indicators that
have changed. If the event is of type
<span class="symbol">XkbIndicatorMapNotify</span>,
<em class="structfield"><code>changed</code></em>
reports the maps that changed. If the event is of type
<span class="symbol">XkbIndicatorStateNotify</span>,
<em class="structfield"><code>changed</code></em>
reports the indicators that have changed state.
<em class="parameter"><code>state</code></em>
is a mask that specifies the current state of all indicators, whether they
have changed or not, for both
<span class="symbol">XkbIndicatorStateNotify</span>
and <span class="symbol">XkbIndicatorMapNotify</span> events.
</p><p>
When your client application receives either a
<span class="symbol">XkbIndicatorStateNotify</span>
event or
<span class="symbol">XkbIndicatorMapNotify</span>
event, you can note the changes in a changes structure by calling
<code class="function">XkbNoteIndicatorChanges</code>.
</p><a id="idm3063" class="indexterm"></a><div class="funcsynopsis"><a id="XkbNoteIndicatorChanges"></a><p><code class="funcdef">void <strong class="fsfunc">XkbNoteIndicatorChanges</strong>(</code>XkbIndicatorChangesPtr <var class="pdparam">old</var>, XkbIndicatorNotifyEvent *<var class="pdparam">new</var>, unsigned int <var class="pdparam">wanted</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>old</code></em>
    </span></p></td><td><p>
        XkbIndicatorChanges structure to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new</code></em>
    </span></p></td><td><p>
        event from which changes are to be copied
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>wanted</code></em>
    </span></p></td><td><p>
        which changes are to be noted
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>wanted</code></em>
parameter is the bitwise inclusive OR of
<span class="symbol">XkbIndicatorMapMask</span>
and
<span class="emphasis"><em>XkbIndicatorStateMask</em></span>.
<code class="function">XkbNoteIndicatorChanges</code>
copies any changes reported in
<em class="parameter"><code>new</code></em>
and specified in
<em class="parameter"><code>wanted</code></em>
into the changes record specified by
<em class="parameter"><code>old</code></em>.
</p><p>
To update a local copy of the keyboard description with the actual values, pass
the results of one or more calls to
<code class="function">XkbNoteIndicatorChanges</code>
to
<code class="function">XkbGetIndicatorChanges</code>:
</p><a id="idm3103" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetIndicatorChanges"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetIndicatorChanges</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbIndicatorChangesPtr <var class="pdparam">changes</var>, unsigned int *<var class="pdparam">state</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to hold the new values
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        indicator maps/state to be obtained from the server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state</code></em>
    </span></p></td><td><p>
        backfilled with the state of the indicators
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetIndicatorChanges</code>
examines the
<em class="parameter"><code>changes</code></em>
parameter, pulls over the necessary information from the server, and copies
the results into the
<em class="parameter"><code>xkb</code></em>
keyboard description. If any bits are set in the
<em class="structfield"><code>state_changes</code></em>
field of
<em class="parameter"><code>changes</code></em>,
<code class="function">XkbGetIndicatorChanges</code>
also places the state of those indicators in
<em class="parameter"><code>state</code></em>.
If the
<em class="structfield"><code>indicators</code></em>
field of
<em class="parameter"><code>xkb</code></em>
is
<span class="symbol">NULL</span>,
<code class="function">XkbGetIndicatorChanges</code>
allocates and initializes it. To free the
<em class="structfield"><code>indicators</code></em>
field, use
<code class="function">XkbFreeIndicatorMaps</code>
(see <a class="link" href="#Allocating_and_Freeing_Indicator_Maps" title="Allocating and Freeing Indicator Maps">section 8.6</a>).
</p><p>
<code class="function">XkbGetIndicatorChanges</code>
can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadImplementation</span>,
and
<span class="errorname">BadMatch</span>
errors.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_Indicator_Maps"></a>Allocating and Freeing Indicator Maps</h2></div></div></div><p>
Most applications do not need to directly allocate the
<em class="structfield"><code>indicators</code></em>
member of the keyboard description record (the keyboard description record is
described in <a class="xref" href="#Complete_Keyboard_Description" title="Chapter 6. Complete Keyboard Description">Chapter 6, <em>Complete Keyboard Description</em></a>). If the need arises, however, use
<code class="function">XkbAllocIndicatorMaps</code>.
</p><a id="idm3165" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocIndicatorMaps"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocIndicatorMaps</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description structure
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>xkb</code></em>
parameter must point to a valid keyboard description. If it doesn’t,
<code class="function">XkbAllocIndicatorMaps</code>
returns a
<span class="errorname">BadMatch</span>
error. Otherwise,
<code class="function">XkbAllocIndicatorMaps</code>
allocates and initializes the
<em class="structfield"><code>indicators</code></em>
member of the keyboard description record and returns
<span class="symbol">Success</span>.
If
<code class="function">XkbAllocIndicatorMaps</code>
was unable to allocate the indicators record, it reports a
<span class="errorname">BadAlloc</span>
error.
</p><p>
To free memory used by the
<em class="structfield"><code>indicators</code></em>
member of an
<span class="structname">XkbDescRec</span>
structure, use
<code class="function">XkbFreeIndicatorMaps</code>.
</p><a id="idm3193" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeIndicatorMaps"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeIndicatorMaps</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description structure
      </p></td></tr></tbody></table></div><p>
If the <em class="structfield"><code>indicators</code></em>
member of the keyboard description record
pointed to by <em class="parameter"><code>xkb</code></em>
is not <span class="symbol">NULL</span>,
<code class="function">XkbFreeIndicatorMaps</code>
frees the memory associated with
the <em class="structfield"><code>indicators</code></em>
member of <em class="parameter"><code>xkb</code></em>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Bells"></a>Chapter 9. Bells</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Bell_Names">Bell Names</a></span></dt><dt><span class="sect1"><a href="#Audible_Bells">Audible Bells</a></span></dt><dt><span class="sect1"><a href="#Bell_Functions">Bell Functions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Generating_Named_Bells">Generating Named Bells</a></span></dt><dt><span class="sect2"><a href="#Generating_Named_Bell_Events">Generating Named Bell Events</a></span></dt><dt><span class="sect2"><a href="#Forcing_a_Server_Generated_Bell">Forcing a Server-Generated Bell</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Detecting_Bells">Detecting Bells</a></span></dt></dl></div><a id="idm3217" class="indexterm"></a><p>
The core X protocol allows only applications to explicitly sound the system
bell with a given duration, pitch, and volume. Xkb extends this capability by
allowing clients to attach symbolic names to bells, disable audible bells, and
receive an event whenever the keyboard bell is rung. For the purposes of this
document, the
<em class="firstterm">audible</em>
<a id="idm3221" class="indexterm"></a>
<a id="idm3223" class="indexterm"></a>
bell is defined to be the system bell, or the default keyboard bell, as
opposed to any other audible sound generated elsewhere in the system.
</p><p>
You can ask to receive
<span class="symbol">XkbBellNotify</span>
events (see <a class="link" href="#Detecting_Bells" title="Detecting Bells">section 9.4</a>) when any client rings any one of the following:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The default bell
  </p></li><li class="listitem"><p>
Any bell on an input device that can be specified by a
<em class="structfield"><code>bell_class</code></em>
and
<em class="structfield"><code>bell_id</code></em>
pair
  </p></li><li class="listitem"><p>
Any bell specified only by an arbitrary name. (This is, from the server’s
point of view, merely a name, and not connected with any physical
sound-generating device. Some client application must generate the sound, or
visual feedback, if any, that is associated with the name.)
  </p></li></ul></div><p>
You can also ask to receive
<span class="symbol">XkbBellNotify</span>
events when the server rings the default bell or if any client has requested
events only (without the bell sounding) for any of the bell types previously
listed.
</p><p>
You can disable audible bells on a global basis (to set the
<span class="emphasis"><em>AudibleBell</em></span>
control, see <a class="xref" href="#Keyboard_Controls" title="Chapter 10. Keyboard Controls">Chapter 10, <em>Keyboard Controls</em></a>). For example, a client that replaces the keyboard
bell with some other audible cue might want to turn off the
<span class="emphasis"><em>AudibleBell</em></span>
control to prevent the server from also generating a sound and avoid
cacophony. If you disable audible bells and request to receive
<span class="symbol">XkbBellNotify</span>
events, you can generate feedback different from the default bell.
</p><p>
You can, however, override the
<span class="emphasis"><em>AudibleBell</em></span>
control by calling one of the functions that force the ringing of a bell in
spite of the setting of the
<span class="emphasis"><em>AudibleBell</em></span>
control —
<code class="function">XkbForceDeviceBell</code>
or
<code class="function">XkbForceBell</code>
(see <a class="link" href="#Forcing_a_Server_Generated_Bell" title="Forcing a Server-Generated Bell">section 9.3.3</a>). In this case the server does not generate a bell event.
</p><p>
Just as some keyboards can produce keyclicks to indicate when a key is pressed
or repeating, Xkb can provide feedback for the controls by using special beep
codes. The
<span class="emphasis"><em>AccessXFeedback</em></span>
control is used to configure the specific types of operations that generate
feedback. See <a class="link" href="#The_AccessXFeedback_Control" title="The AccessXFeedback Control">section 10.6.3</a> for a discussion on
<span class="emphasis"><em>AccessXFeedback</em></span>
control.
</p><p>
This chapter describes bell names, the functions used to generate named bells,
and the events the server generates for bells.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Bell_Names"></a>Bell Names</h2></div></div></div><p>
You can associate a name to an act of ringing a bell by converting the name to
an Atom and then using this name when you call the functions listed in this
chapter. If an event is generated as a result, the name is then passed to all
other clients interested in receiving
<span class="symbol">XkbBellNotify</span>
events. Note that these are arbitrary names and that there is no binding to
any sounds. Any sounds or other effects (such as visual bells on the screen)
must be generated by a client application upon receipt of the bell event
containing the name. There is no default name for the default keyboard bell.
The server does generate some predefined bells for the AccessX controls (see
<a class="link" href="#The_AccessXFeedback_Control" title="The AccessXFeedback Control">section 10.6.3</a>).
These named bells are shown in <a class="link" href="#table9.1" title="Table 9.1. Predefined Bells">Table 9.1</a>;
the name is included
in any bell event sent to clients that have requested to receive
<span class="symbol">XkbBellNotify</span>
events.
</p><div class="table"><a id="table9.1"></a><p class="title"><strong>Table 9.1. Predefined Bells</strong></p><div class="table-contents"><table class="table" summary="Predefined Bells" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Action</th><th align="left">Named Bell</th></tr></thead><tbody><tr><td align="left">Indicator turned on</td><td align="left">AX_IndicatorOn</td></tr><tr><td align="left">Indicator turned off</td><td align="left">AX_IndicatorOff</td></tr><tr><td align="left">More than one indicator changed state</td><td align="left">AX_IndicatorChange</td></tr><tr><td align="left">Control turned on</td><td align="left">AX_FeatureOn</td></tr><tr><td align="left">Control turned off</td><td align="left">AX_FeatureOff</td></tr><tr><td align="left">More than one control changed state</td><td align="left">AX_FeatureChange</td></tr><tr><td align="left">SlowKeys and BounceKeys about to be turned on or off</td><td align="left">AX_SlowKeysWarning</td></tr><tr><td align="left">SlowKeys key pressed</td><td align="left">AX_SlowKeyPress</td></tr><tr><td align="left">SlowKeys key accepted</td><td align="left">AX_SlowKeyAccept</td></tr><tr><td align="left">SlowKeys key rejected</td><td align="left">AX_SlowKeyReject</td></tr><tr><td align="left">Accepted SlowKeys key released</td><td align="left">AX_SlowKeyRelease</td></tr><tr><td align="left">BounceKeys key rejected</td><td align="left">AX_BounceKeyReject</td></tr><tr><td align="left">StickyKeys key latched</td><td align="left">AX_StickyLatch</td></tr><tr><td align="left">StickyKeys key locked</td><td align="left">AX_StickyLock</td></tr><tr><td align="left">StickyKeys key unlocked</td><td align="left">AX_StickyUnlock</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Audible_Bells"></a>Audible Bells</h2></div></div></div><p>
Using Xkb you can generate bell events that do not necessarily ring the system
bell. This is useful if you need to use an audio server instead of the system
beep. For example, when an audio client starts, it could disable the audible
bell (the system bell) and then listen for
<span class="symbol">XkbBellNotify</span>
events (see <a class="link" href="#Detecting_Bells" title="Detecting Bells">section 9.4</a>). When it receives a
<span class="symbol">XkbBellNotify</span>
event, the audio client could then send a request to an audio server to play a
sound.
</p><p>
You can control the audible bells feature by passing the
<span class="symbol">XkbAudibleBellMask</span>
to
<code class="function">XkbChangeEnabledControls</code>
(see <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>). If you set
<span class="symbol">XkbAudibleBellMask</span>
on, the server rings the system bell when a bell event occurs. This is the
default. If you set
<span class="symbol">XkbAudibleBellMask</span>
off and a bell event occurs, the server does not ring the system bell unless
you call
<code class="function">XkbForceDeviceBell</code>
or
<code class="function">XkbForceBell</code>
(see <a class="link" href="#Forcing_a_Server_Generated_Bell" title="Forcing a Server-Generated Bell">section 9.3.3</a>).
</p><p>
Audible bells are also part of the per-client auto-reset controls. For more
information on auto-reset controls, see <a class="link" href="#The_AutoReset_Control" title="The AutoReset Control">section 10.1.2</a>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Bell_Functions"></a>Bell Functions</h2></div></div></div><p>
Use the functions described in this section to ring bells and to generate bell
events.
</p><p>
The input extension has two types of feedbacks that can generate bells — bell
feedback and keyboard feedback. Some of the functions in this section have
<em class="structfield"><code>bell_class</code></em>
and
<em class="structfield"><code>bell_id</code></em>
parameters; set them as follows: Set
<em class="structfield"><code>bell_class</code></em>
to
<span class="symbol">BellFeedbackClass</span>
or
<span class="symbol">KbdFeedbackClass</span>.
A device can have more than one feedback of each type; set
<em class="structfield"><code>bell_id</code></em>
to the particular bell feedback of
<em class="structfield"><code>bell_class</code></em>
type.
</p><p>
<a class="link" href="#table9.2" title="Table 9.2. Bell Sounding and Bell Event Generating">Table 9.2</a> shows the conditions that cause
a bell to sound or an <span class="structname">XkbBellNotifyEvent</span>
to be generated when a bell function is called.
</p><div class="table"><a id="table9.2"></a><p class="title"><strong>Table 9.2. Bell Sounding and Bell Event Generating</strong></p><div class="table-contents"><table class="table" summary="Bell Sounding and Bell Event Generating" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Function called</th><th align="left">AudibleBell</th><th align="left">Server sounds a bell</th><th align="left">Server sends an XkbBellNotifyEvent</th></tr></thead><tbody><tr><td align="left">XkbDeviceBell</td><td align="left">On</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">XkbDeviceBell</td><td align="left">Off</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">XkbBell</td><td align="left">On</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">XkbBell</td><td align="left">Off</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">XkbDeviceBellEvent</td><td align="left">On or Off</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">XkbBellEvent</td><td align="left">On or Off</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">XkbDeviceForceBell</td><td align="left">On or Off</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">XkbForceBell</td><td align="left">On or Off</td><td align="left">Yes</td><td align="left">No</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Generating_Named_Bells"></a>Generating Named Bells</h3></div></div></div><p>
To ring the bell on an X input extension device or the default keyboard, use
<code class="function">XkbDeviceBell</code>.
</p><a id="idm3407" class="indexterm"></a><div class="funcsynopsis"><a id="XkbDeviceBell"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbDeviceBell</strong>(</code>Display *<var class="pdparam">display</var>, Window <var class="pdparam">window</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">bell_class</var>, unsigned int <var class="pdparam">bell_id</var>, int <var class="pdparam">percent</var>, Atom <var class="pdparam">name</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>window</code></em>
    </span></p></td><td><p>
        window for which the bell is generated, or None
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bell_class</code></em>
    </span></p></td><td><p>
        X input extension bell class of the bell to be rung
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bell_id</code></em>
    </span></p></td><td><p>
        X input extension bell ID of the bell to be rung
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>percent</code></em>
    </span></p></td><td><p>
        bell volume, from −100 to 100 inclusive
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        a name for the bell, or <span class="symbol">NULL</span>
      </p></td></tr></tbody></table></div><p>
Set
<em class="parameter"><code>percent</code></em>
to be the volume relative to the base volume for the keyboard as described for
<code class="function">XBell</code>.
</p><p>
Note that
<em class="parameter"><code>bell_class</code></em>
and
<em class="parameter"><code>bell_id</code></em>
indicate the bell to physically ring.
<em class="parameter"><code>name</code></em>
is simply an arbitrary moniker for the client application’s use.
</p><p>
To determine the current feedback settings of an extension input device, use
<code class="function">XGetFeedbackControl</code>.
See <span class="olink">the
X input extension documentation</span> for more information on
<code class="function">XGetFeedbackControl</code>
and related data structures.
</p><p>
If a compatible keyboard extension is not present in the X server,
<code class="function">XkbDeviceBell</code>
immediately returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbDeviceBell</code>
rings the bell as specified for the display and keyboard device and returns
<span class="symbol">True</span>.
If you have disabled the audible bell, the server does not ring the system
bell, although it does generate a
<span class="symbol">XkbBellNotify</span>
event.
</p><p>
You can call
<code class="function">XkbDeviceBell</code>
without first initializing the keyboard extension.
</p><p>
As a convenience function, Xkb provides a function to ring the bell on the
default keyboard:
<code class="function">XkbBell</code>.
</p><a id="idm3487" class="indexterm"></a><div class="funcsynopsis"><a id="XkbBell"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbBell</strong>(</code>Display *<var class="pdparam">display</var>, Window <var class="pdparam">window</var>, int <var class="pdparam">percent</var>, Atom <var class="pdparam">name</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>window</code></em>
    </span></p></td><td><p>
        event window, or None
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>percent</code></em>
    </span></p></td><td><p>
        relative volume, which can range from −100 to 100 inclusive
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        a bell name, or <span class="symbol">NULL</span>
      </p></td></tr></tbody></table></div><p>
If a compatible keyboard extension isn’t present in the X server,
<code class="function">XkbBell</code>
calls
<code class="function">XBell</code>
with the specified
<em class="parameter"><code>display</code></em>
and
<em class="parameter"><code>percent</code></em>,
and returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbBell</code>
calls
<code class="function">XkbDeviceBell</code>
with the specified
<em class="parameter"><code>display</code></em>,
<em class="parameter"><code>window</code></em>,
<em class="parameter"><code>percent</code></em>,
and
<em class="parameter"><code>name</code></em>,
a
<em class="structfield"><code>device_spec</code></em>
of
<span class="symbol">XkbUseCoreKbd</span>,
a
<em class="structfield"><code>bell_class</code></em>
of
<span class="symbol">XkbDfltXIClass</span>,
and a
<em class="structfield"><code>bell_id</code></em>
of
<span class="symbol">XkbDfltXIId</span>,
and returns
<span class="symbol">True</span>.
</p><p>
If you have disabled the audible bell, the server does not ring the system
bell, although it does generate a
<span class="symbol">XkbBellNotify</span>
event.
</p><p>
You can call
<code class="function">XkbBell</code>
without first initializing the keyboard extension.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Generating_Named_Bell_Events"></a>Generating Named Bell Events</h3></div></div></div><p>
Using Xkb, you can also generate a named bell event that does not ring any
bell. This allows you to do things such as generate events when your
application starts.
</p><p>
For example, if an audio client listens for these types of bells, it can
produce a <span class="quote">“<span class="quote">whoosh</span>”</span> sound when it receives a named bell event to indicate a
client just started. In this manner, applications can generate start-up
feedback and not worry about producing annoying beeps if an audio server is not
running.
</p><p>
To cause a bell event for an X input extension device or for the keyboard,
without ringing the corresponding bell, use
<code class="function">XkbDeviceBellEvent</code>.
</p><a id="idm3554" class="indexterm"></a><div class="funcsynopsis"><a id="XkbDeviceBellEvent"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbDeviceBellEvent</strong>(</code>Display *<var class="pdparam">display</var>, Window <var class="pdparam">window</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">bell_class</var>, unsigned int <var class="pdparam">bell_id</var>, int <var class="pdparam">percent</var>, Atom <var class="pdparam">name</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>window</code></em>
    </span></p></td><td><p>
        event window, or None
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bell_class</code></em>
    </span></p></td><td><p>
        input extension bell class for the event
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bell_id</code></em>
    </span></p></td><td><p>
        input extension bell ID for the event
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>percent</code></em>
    </span></p></td><td><p>
        volume for the bell, which can range from −100 to 100 inclusive
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        a bell name, or <span class="symbol">NULL</span>
      </p></td></tr></tbody></table></div><p>
If a compatible keyboard extension isn’t present in the X server,
<code class="function">XkbDeviceBellEvent</code>
immediately returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbDeviceBellEvent</code>
causes an
<span class="symbol">XkbBellNotify</span>
event to be sent to all interested clients and returns
<span class="symbol">True</span>.
Set
<em class="parameter"><code>percent</code></em>
to be the volume relative to the base volume for the keyboard as described for
<code class="function">XBell</code>.
</p><p>
In addition,
<code class="function">XkbDeviceBellEvent</code>
may generate
<span class="type">Atom</span>
protocol errors as well as
<span class="symbol">XkbBellNotify</span>
events. You can call
<code class="function">XkbBell</code>
without first initializing the keyboard extension.
</p><p>
As a convenience function, Xkb provides a function to cause a bell event for
the keyboard without ringing the bell:
<code class="function">XkbBellEvent</code>.
</p><a id="idm3628" class="indexterm"></a><div class="funcsynopsis"><a id="XkbBellEvent"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbBellEvent</strong>(</code>Display *<var class="pdparam">display</var>, Window <var class="pdparam">window</var>, int <var class="pdparam">percent</var>, Atom <var class="pdparam">name</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>window</code></em>
    </span></p></td><td><p>
        the event window, or None
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>percent</code></em>
    </span></p></td><td><p>
        relative volume, which can range from −100 to 100 inclusive
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        a bell name, or <span class="symbol">NULL</span>
      </p></td></tr></tbody></table></div><p>
If a compatible keyboard extension isn’t present in the X server,
<code class="function">XkbBellEvent</code>
immediately returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbBellEvent</code>
calls
<code class="function">XkbDeviceBellEvent</code>
with the specified
<em class="parameter"><code>display</code></em>,
<em class="parameter"><code>window</code></em>,
<em class="parameter"><code>percent</code></em>,
and
<em class="parameter"><code>name</code></em>,
a
<em class="structfield"><code>device_spec</code></em>
of
<span class="symbol">XkbUseCoreKbd</span>,
a
<em class="structfield"><code>bell_class</code></em>
of
<span class="symbol">XkbDfltXIClass</span>,
and a
<em class="structfield"><code>bell_id</code></em>
of
<span class="symbol">XkbDfltXIId</span>,
and returns what
<code class="function">XkbDeviceBellEvent</code>
returns.
</p><p>
<code class="function">XkbBellEvent</code>
generates a <span class="symbol">XkbBellNotify</span>
event.
</p><p>
You can call
<code class="function">XkbBellEvent</code>
without first initializing the keyboard extension.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Forcing_a_Server_Generated_Bell"></a>Forcing a Server-Generated Bell</h3></div></div></div><p>
To ring the bell on any keyboard, overriding user preference settings for
audible bells, use <code class="function">XkbForceDeviceBell</code>.
</p><a id="idm3690" class="indexterm"></a><div class="funcsynopsis"><a id="XkbForceDeviceBell"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbForceDeviceBell</strong>(</code>Display *<var class="pdparam">display</var>, Window <var class="pdparam">window</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">bell_class</var>, unsigned int <var class="pdparam">bell_id</var>, int <var class="pdparam">percent</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>window</code></em>
    </span></p></td><td><p>
        event window, or None
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bell_class</code></em>
    </span></p></td><td><p>
        input extension class of the bell to be rung
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bell_id</code></em>
    </span></p></td><td><p>
        input extension ID of the bell to be rung
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>percent</code></em>
    </span></p></td><td><p>
        relative volume, which can range from −100 to 100 inclusive
      </p></td></tr></tbody></table></div><p>
If a compatible keyboard extension isn’t present in the X server,
<code class="function">XkbForceDeviceBell</code>
immediately returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbForceDeviceBell</code>
rings the bell as specified for the display and keyboard device and returns
<span class="symbol">True</span>.
Set
<em class="parameter"><code>percent</code></em>
to be the volume relative to the base volume for the keyboard as described for
<code class="function">XBell</code>.
There is no
<em class="structfield"><code>name</code></em>
parameter because
<code class="function">XkbForceDeviceBell</code>
does not cause an
<span class="symbol">XkbBellNotify</span>
event.
</p><p>
You can call
<code class="function">XkbBell</code>
without first initializing the keyboard extension.
</p><p>
To ring the bell on the default keyboard, overriding user preference settings
for audible bells, use
<code class="function">XkbForceBell</code>.
</p><a id="idm3755" class="indexterm"></a><div class="funcsynopsis"><a id="XkbForceBell"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbForceBell</strong>(</code>Display *<var class="pdparam">display</var>, int <var class="pdparam">percent</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>percent</code></em>
    </span></p></td><td><p>
        volume for the bell, which can range from −100 to 100 inclusive
      </p></td></tr></tbody></table></div><p>
If a compatible keyboard extension isn’t present in the X server,
<code class="function">XkbForceBell</code>
calls
<code class="function">XBell</code>
with the specified
<em class="parameter"><code>display</code></em>
and
<em class="parameter"><code>percent</code></em>
and returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbForceBell</code>
calls
<code class="function">XkbForceDeviceBell</code>
with the specified
<em class="parameter"><code>display</code></em>
and
<em class="parameter"><code>percent</code></em>,
<em class="structfield"><code>device_spec</code></em>
=
<span class="symbol">XkbUseCoreKbd</span>,
<em class="structfield"><code>bell_class</code></em>
=
<span class="symbol">XkbDfltXIClass</span>,
<em class="structfield"><code>bell_id</code></em>
=
<span class="symbol">XkbDfltXIId</span>,
<em class="structfield"><code>window</code></em>
= None, and
<em class="structfield"><code>name</code></em>
=
<span class="symbol">NULL</span>,
and returns what
<code class="function">XkbForceDeviceBell</code>
returns.
</p><p>
<code class="function">XkbForceBell</code>
does not cause an
<span class="symbol">XkbBellNotify</span>
event.
</p><p>
You can call
<code class="function">XkbBell</code>
without first initializing the keyboard extension.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Detecting_Bells"></a>Detecting Bells</h2></div></div></div><p>
Xkb generates
<span class="symbol">XkbBellNotify</span>
events for all bells except for those resulting from calls to
<code class="function">XkbForceDeviceBell</code>
and
<code class="function">XkbForceBell</code>.
To receive
<span class="symbol">XkbBellNotify</span>
events under all possible conditions, pass
<span class="symbol">XkbBellNotifyMask</span>
in both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
parameters to
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>).
</p><p>
The
<span class="symbol">XkbBellNotify</span>
event has no event details. It is either selected or it is not. However, you
can call
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbBellNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying
<span class="symbol">XkbAllBellEventsMask</span>
in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
This has the same effect as a call to
<code class="function">XkbSelectEvents</code>.
</p><p>
The structure for the
<span class="symbol">XkbBellNotify</span>
event type contains:

</p><pre class="programlisting">
typedef struct _XkbBellNotify {
    int             type;        /* Xkb extension base event code */
    unsigned long   serial;      /* X server serial number for event */
    Bool            send_event;  /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *       display;     /* server connection where event generated */
    Time            time;        /* server time when event generated */
    int             xkb_type;    /* <span class="symbol">XkbBellNotify</span> */
    unsigned int    device;      /* Xkb device ID, will not be <span class="symbol">XkbUseCoreKbd</span> */
    int             percent;     /* requested volume as % of max */
    int             pitch;       /* requested pitch in Hz */
    int             duration;    /* requested duration in microseconds */
    unsigned int    bell_class;  /* X input extension feedback class */
    unsigned int    bell_id;     /* X input extension feedback ID */
    Atom            name;        /* "name" of requested bell */
    Window          window;      /* window associated with event */
    Bool            event_only;  /* <span class="symbol">False</span> → the server did not produce a beep */
} <span class="structname">XkbBellNotifyEvent</span>;
</pre><p>
If your application needs to generate visual bell feedback on the screen when
it receives a bell event, use the window ID in the
<span class="structname">XkbBellNotifyEvent</span>,
if present.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Keyboard_Controls"></a>Chapter 10. Keyboard Controls</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Controls_that_Enable_and_Disable_Other_Controls">Controls that Enable and Disable Other Controls</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_EnabledControls_Control">The EnabledControls Control</a></span></dt><dt><span class="sect2"><a href="#The_AutoReset_Control">The AutoReset Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Control_for_Bell_Behavior">Control for Bell Behavior</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_AudibleBell_Control">The AudibleBell Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_Repeat_Key_Behavior">Controls for Repeat Key Behavior</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_PerKeyRepeat_Control">The PerKeyRepeat Control</a></span></dt><dt><span class="sect2"><a href="#The_RepeatKeys_Control">The RepeatKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_DetectableAutorepeat_Control">The DetectableAutorepeat Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls">Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)</a></span></dt><dt><span class="sect1"><a href="#Controls_for_Using_the_Mouse_from_the_Keyboard">Controls for Using the Mouse from the Keyboard</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_MouseKeys_Control">The MouseKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_MouseKeysAccel_Control">The MouseKeysAccel Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_Better_Keyboard_Access_by_Physically_ImpairedPersons">Controls for Better Keyboard Access by Physically Impaired
Persons</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_AccessXKeys_Control">The AccessXKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_AccessXTimeout_Control">The AccessXTimeout Control</a></span></dt><dt><span class="sect2"><a href="#The_AccessXFeedback_Control">The AccessXFeedback Control</a></span></dt><dt><span class="sect2"><a href="#AccessXNotify_Events">AccessXNotify Events</a></span></dt><dt><span class="sect2"><a href="#StickyKeys_RepeatKeys_and_MouseKeys_Events">StickyKeys, RepeatKeys, and MouseKeys Events</a></span></dt><dt><span class="sect2"><a href="#The_SlowKeys_Control">The SlowKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_BounceKeys_Control">The BounceKeys Control</a></span></dt><dt><span class="sect2"><a href="#The_StickyKeys_Control">The StickyKeys Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_for_General_Keyboard_Mapping">Controls for General Keyboard Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_GroupsWrap_Control">The GroupsWrap Control</a></span></dt><dt><span class="sect2"><a href="#The_IgnoreLockMods_Control">The IgnoreLockMods Control</a></span></dt><dt><span class="sect2"><a href="#The_IgnoreGroupLock_Control">The IgnoreGroupLock Control</a></span></dt><dt><span class="sect2"><a href="#The_InternalMods_Control">The InternalMods Control</a></span></dt></dl></dd><dt><span class="sect1"><a href="#The_XkbControlsRec_Structure">The XkbControlsRec Structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm6021"></a></span></dt></dl></dd><dt><span class="sect1"><a href="#Querying_Controls">Querying Controls</a></span></dt><dt><span class="sect1"><a href="#Changing_Controls">Changing Controls</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_XkbControlsChangesRec_Structure">The XkbControlsChangesRec Structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Changes_to_Keyboard_Controls">Tracking Changes to Keyboard Controls</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_an_XkbControlsRec">Allocating and Freeing an XkbControlsRec</a></span></dt><dt><span class="sect1"><a href="#The_Miscellaneous_Per_client_Controls">The Miscellaneous Per-client Controls</a></span></dt></dl></div><a id="idm3835" class="indexterm"></a><a id="idm3837" class="indexterm"></a><a id="idm3839" class="indexterm"></a><p>
The Xkb extension is composed of two parts: a server extension, and a
client-side X library extension. This chapter discusses functions used to
modify controls effecting the behavior of the server portion of the Xkb
extension. <a class="xref" href="#X_Library_Controls" title="Chapter 11. X Library Controls">Chapter 11, <em>X Library Controls</em></a> discusses functions used to modify controls that affect
only the behavior of the client portion of the extension; those controls are
known as Library Controls.
</p><p>
Xkb contains control features that affect the entire keyboard, known as global
keyboard controls. Some of the controls may be selectively enabled and
disabled; these controls are known as the
<em class="firstterm">Boolean Controls</em>.
<a id="idm3846" class="indexterm"></a>
<a id="idm3848" class="indexterm"></a>
Boolean Controls can be turned on or off under program control and can also
be automatically set to an on or off condition when a client program exits. The
remaining controls, known as the
<em class="firstterm">Non-Boolean Controls</em>,
<a id="idm3852" class="indexterm"></a>
<a id="idm3854" class="indexterm"></a>
are always active. The
<span class="structname">XkbControlsRec</span>
structure describes the current state of most of the global controls and the
attributes effecting the behavior of each of these Xkb features. This chapter
describes the Xkb controls and how to manipulate them.
</p><p>
There are two possible components for each of the Boolean Controls: attributes
describing how the control should work, and a state describing whether the
behavior as a whole is enabled or disabled. The attributes and state for most
of these controls are held in the
<span class="structname">XkbControlsRec</span>
structure (see <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>).
</p><p>
You can manipulate the Xkb controls individually, via convenience functions, or
as a whole. To treat them as a group, modify an
<span class="structname">XkbControlsRec</span>
structure to describe all of the changes to be made, and then pass that
structure and appropriate flags to an Xkb library function, or use a
<span class="structname">XkbControlsChangesRec</span>
(see <a class="link" href="#The_XkbControlsChangesRec_Structure" title="The XkbControlsChangesRec Structure">section 10.10.1</a>) to reduce network traffic. When using a convenience
function to manipulate one control individually, you do not use an
<span class="structname">XkbControlsRec</span>
structure directly.
</p><p>
The Xkb controls are grouped as shown in
<a class="link" href="#table10.1" title="Table 10.1. Xkb Keyboard Controls">Table 10.1</a>.
</p><div class="table"><a id="table10.1"></a><p class="title"><strong>Table 10.1. Xkb Keyboard Controls</strong></p><div class="table-contents"><table class="table" summary="Xkb Keyboard Controls" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Type of Control</th><th align="left">Control Name</th><th align="left">Boolean Control?</th></tr></thead><tbody><tr><td align="left">Controls for enabling and disabling other controls</td><td align="left">EnabledControls</td><td align="left">No</td></tr><tr><td align="left"> </td><td align="left">AutoReset</td><td align="left">No</td></tr><tr><td align="left">Control for bell behavior</td><td align="left">AudibleBell</td><td align="left">Boolean</td></tr><tr><td align="left">Controls for repeat key behavior</td><td align="left">PerKeyRepeat</td><td align="left">No</td></tr><tr><td align="left"> </td><td align="left">RepeatKeys</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">DetectableAutorepeat</td><td align="left">Boolean</td></tr><tr><td align="left">Controls for keyboard overlays</td><td align="left">Overlay1</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">Overlay2</td><td align="left">Boolean</td></tr><tr><td align="left">Controls for using the mouse from the keyboard</td><td align="left">MouseKeys</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">MouseKeysAccel</td><td align="left">Boolean</td></tr><tr><td align="left">Controls for better keyboard access by </td><td align="left">AccessXFeedback</td><td align="left">Boolean</td></tr><tr><td align="left">physically impaired persons</td><td align="left">AccessXKeys</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">AccessXTimeout</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">BounceKeys</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">SlowKeys</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">StickyKeys</td><td align="left">Boolean</td></tr><tr><td align="left">Controls for general keyboard mapping</td><td align="left">GroupsWrap</td><td align="left">No</td></tr><tr><td align="left"> </td><td align="left">IgnoreGroupLock</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">IgnoreLockMods</td><td align="left">No</td></tr><tr><td align="left"> </td><td align="left">InternalMods</td><td align="left">No</td></tr><tr><td align="left">Miscellaneous per-client controls</td><td align="left">GrabsUseXKBState</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">LookupStateWhenGrabbed</td><td align="left">Boolean</td></tr><tr><td align="left"> </td><td align="left">SendEventUsesXKBState</td><td align="left">Boolean</td></tr></tbody></table></div></div><br class="table-break" /><p>
The individual categories and controls are described first, together with
functions for manipulating them. A description of the
<span class="structname">XkbControlsRec</span>
structure and the general functions for dealing with all of the controls at
once follow at the end of the chapter.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_that_Enable_and_Disable_Other_Controls"></a>Controls that Enable and Disable Other Controls</h2></div></div></div><p>
Enable and disable the boolean controls under program control by using the
<span class="emphasis"><em>EnabledControls</em></span>
control; enable and disable them upon program exit by configuring the
<span class="emphasis"><em>AutoReset</em></span>
control.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_EnabledControls_Control"></a>The EnabledControls Control</h3></div></div></div><p>
The
<span class="emphasis"><em>EnabledControls</em></span>
control is a bit mask where each bit that is turned on means the corresponding
control is enabled, and when turned off, disabled. It corresponds to the
<em class="structfield"><code>enabled_ctrls</code></em>
field of an
<span class="structname">XkbControlsRec</span>
structure (see <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>). The bits describing which controls are turned on
or off are defined in <a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>.
</p><p>
Use
<code class="function">XkbChangeEnabledControls</code>
to manipulate the
<span class="emphasis"><em>EnabledControls</em></span>
control.
</p><a id="idm3990" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeEnabledControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbChangeEnabledControls</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">mask</var>, unsigned int <var class="pdparam">values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        keyboard device to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mask</code></em>
    </span></p></td><td><p>
        1 bit → controls to enable / disable
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values</code></em>
    </span></p></td><td><p>
        1 bit ⇒ enable, 0 bit ⇒ disable
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>mask</code></em>
parameter specifies the boolean controls to be enabled or disabled, and the
<em class="parameter"><code>values</code></em>
mask specifies the new state for those controls. Valid values for both of
these masks are composed of a bitwise inclusive OR of bits taken from the set
of mask bits in <a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>,
using only those masks with <span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="structfield"><code>enabled_ctrls</code></em>
column.
</p><p>
If the X server does not support a compatible version of Xkb or the Xkb
extension has not been properly initialized,
<code class="function">XkbChangeEnabledControls</code>
returns
<span class="symbol">False</span>;
otherwise, it sends the request to the X server and returns
<span class="symbol">True</span>.
</p><p>
Note that the
<span class="emphasis"><em>EnabledControls</em></span>
control only enables and disables controls; it does not configure them. Some
controls, such as the
<span class="emphasis"><em>AudibleBell</em></span>
control, have no configuration attributes and are therefore manipulated solely
by enabling and disabling them. Others, however, have additional attributes to
configure their behavior. For example, the
<span class="emphasis"><em>RepeatControl</em></span>
control uses
<em class="structfield"><code>repeat_delay</code></em>
and
<em class="structfield"><code>repeat_interval</code></em>
fields to describe the timing behavior of keys that repeat. The
<span class="emphasis"><em>RepeatControl</em></span>
behavior is turned on or off depending on the value of the
<span class="symbol">XkbRepeatKeysMask</span>
bit, but you must use other means, as described in this chapter, to configure
its behavior in detail.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_AutoReset_Control"></a>The AutoReset Control</h3></div></div></div><p>
You can configure the boolean controls to automatically be enabled or disabled
when a program exits. This capability is controlled via two masks maintained in
the X server on a per-client basis. There is no client-side Xkb data structure
corresponding to these masks. Whenever the client exits for any reason, any
boolean controls specified in the
<em class="firstterm">auto-reset mask</em>
<a id="idm4048" class="indexterm"></a>
<a id="idm4050" class="indexterm"></a>
are set to the corresponding value from the
<em class="firstterm">auto-reset values</em>
mask. This makes it possible for clients to "clean up after themselves"
automatically, even if abnormally terminated. The bits used in the masks
correspond to the
<span class="emphasis"><em>EnabledControls</em></span>
control bits.
</p><p>
For example, a client that replaces the keyboard bell with some other audible
cue might want to turn off the
<span class="emphasis"><em>AudibleBell</em></span>
control to prevent the server from also generating a sound and avoid
cacophony. If the client were to exit without resetting the
<span class="emphasis"><em>AudibleBell</em></span>
control, the user would be left without any feedback at all. Setting
<span class="emphasis"><em>AudibleBell</em></span>
in both the auto-reset mask and auto-reset values guarantees that the audible
bell will be turned back on when the client exits.
</p><p>
To get the current values of the auto-reset controls, use
<code class="function">XkbGetAutoResetControls</code>.
</p><a id="idm4061" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetAutoResetControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetAutoResetControls</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int *<var class="pdparam">auto_ctrls</var>, unsigned int *<var class="pdparam">auto_values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>auto_ctrls</code></em>
    </span></p></td><td><p>
        specifies which bits in <em class="parameter"><code>auto_values</code></em> are relevant
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>auto_values</code></em>
    </span></p></td><td><p>
        1 bit ⇒ corresponding control has auto-reset on
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetAutoResetControls</code>
backfills
<em class="parameter"><code>auto_ctrls</code></em>
and
<em class="parameter"><code>auto_values</code></em>
with the
<span class="emphasis"><em>AutoReset</em></span>
control attributes for this particular client. It returns
<span class="symbol">True</span>
if successful, and
<span class="symbol">False</span>
otherwise.
</p><p>
To change the current values of the
<span class="emphasis"><em>AutoReset</em></span>
control attributes, use
<code class="function">XkbSetAutoResetControls</code>.
</p><a id="idm4101" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetAutoResetControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetAutoResetControls</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">changes</var>, unsigned int *<var class="pdparam">auto_ctrls</var>, unsigned int *<var class="pdparam">auto_values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        controls for which to change auto-reset values
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>auto_ctrls</code></em>
    </span></p></td><td><p>
        controls from changes that should auto reset
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>auto_values</code></em>
    </span></p></td><td><p>
        1 bit ⇒ auto-reset on
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetAutoResetControls</code>
changes the auto-reset status and associated auto-reset
values for the controls selected by
<em class="parameter"><code>changes</code></em>.
For any control selected by
<em class="parameter"><code>changes</code></em>,
if the corresponding bit is set in
<em class="parameter"><code>auto_ctrls</code></em>,
the control is configured to auto-reset when the client exits. If the
corresponding bit in
<em class="parameter"><code>auto_values</code></em>
is on, the control is turned on when the client exits;
if zero, the control is turned off when the client exits.
For any control selected by
<em class="parameter"><code>changes</code></em>,
if the corresponding bit is not set in
<em class="parameter"><code>auto_ctrls</code></em>,
the control is configured to not reset when the client exits. For example:
</p><p>
To leave the auto-reset controls for
<span class="emphasis"><em>StickyKeys</em></span>
the way they are:

</p><pre class="programlisting">
    ok = XkbSetAutoResetControls(dpy, 0, 0, 0);
</pre><p>
To change the auto-reset controls so that
<span class="emphasis"><em>StickyKeys</em></span>
are unaffected when the client exits:

</p><pre class="programlisting">
    ok = XkbSetAutoResetControls(dpy, XkbStickyKeysMask, 0, 0);
</pre><p>
To change the auto-reset controls so that
<span class="emphasis"><em>StickyKeys</em></span>
are turned off when the client exits:

</p><pre class="programlisting">
    ok = XkbSetAutoResetControls(dpy, XkbStickyKeysMask, XkbStickyKeysMask, 0);
</pre><p>
To change the auto-reset controls so that
<span class="emphasis"><em>StickyKeys</em></span>
are turned on when the client exits:

</p><pre class="programlisting">
    ok = XkbSetAutoResetControls(dpy, XkbStickyKeysMask, XkbStickyKeysMask,
                                 XkbStickyKeysMask);
</pre><p>
<code class="function">XkbSetAutoResetControls</code>
backfills
<em class="parameter"><code>auto_ctrls</code></em>
and
<em class="parameter"><code>auto_values</code></em>
with the auto-reset controls for this particular client. Note that all of the
bits are valid in the returned values, not just the ones selected in the
<em class="parameter"><code>changes</code></em>
mask.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Control_for_Bell_Behavior"></a>Control for Bell Behavior</h2></div></div></div><p>
The X server’s generation of sounds is controlled by the
<span class="emphasis"><em>AudibleBell</em></span>
control. Configuration of different bell sounds is discussed in <a class="xref" href="#Bells" title="Chapter 9. Bells">Chapter 9, <em>Bells</em></a>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_AudibleBell_Control"></a>The AudibleBell Control</h3></div></div></div><p>
The
<span class="emphasis"><em>AudibleBell</em></span>
control is a boolean control that has no attributes. As such, you may enable
and disable it using either the
<span class="emphasis"><em>EnabledControls</em></span>
control or the
<span class="emphasis"><em>AutoReset</em></span>
control discussed in <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>. When enabled, protocol requests to
generate a sound result in the X server actually producing a real sound; when
disabled, requests to the server to generate a sound are ignored unless the
sound is forced. See <a class="link" href="#Audible_Bells" title="Audible Bells">section 9.2</a>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_for_Repeat_Key_Behavior"></a>Controls for Repeat Key Behavior</h2></div></div></div><a id="idm4177" class="indexterm"></a><p>
The repeating behavior of keyboard keys is governed by three controls, the
<span class="emphasis"><em>PerKeyRepeat</em></span>
control, which is always active, and the
<span class="emphasis"><em>RepeatKeys</em></span>
and
<span class="emphasis"><em>DetectableAutorepeat</em></span>
controls, which are boolean controls that may be enabled and disabled.
<span class="emphasis"><em>PerKeyRepeat</em></span>
determines which keys are allowed to repeat.
<span class="emphasis"><em>RepeatKeys</em></span>
governs the behavior of an individual key when it is repeating.
<span class="emphasis"><em>DetectableAutorepeat</em></span>
allows a client to detect when a key is repeating as a result of being held
down.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_PerKeyRepeat_Control"></a>The PerKeyRepeat Control</h3></div></div></div><p>
The
<span class="emphasis"><em>PerKeyRepeat</em></span>
control is a bitmask long enough to contain a bit for each key on the device;
it determines which individual keys are allowed to repeat. The Xkb
<span class="emphasis"><em>PerKeyRepeat</em></span>
control provides no functionality different from that available via the core X
protocol. There are no convenience functions in Xkb for manipulating this
control. The
<span class="emphasis"><em>PerKeyRepeat</em></span>
control settings are carried in the
<em class="structfield"><code>per_key_repeat</code></em>
field of an
<span class="structname">XkbControlsRec</span>
structure, discussed in <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_RepeatKeys_Control"></a>The RepeatKeys Control</h3></div></div></div><p>
The core protocol allows only control over whether or not the entire keyboard
or individual keys should auto-repeat when held down.
<span class="emphasis"><em>RepeatKeys</em></span>
is a boolean control that extends this capability by adding control over the
delay until a key begins to repeat and the rate at which it repeats.
<span class="emphasis"><em>RepeatKeys</em></span>
is coupled with the core auto-repeat control: when
<span class="emphasis"><em>RepeatKeys</em></span>
is enabled or disabled, the core auto-repeat is enabled or disabled and vice
versa.
</p><p>
Auto-repeating keys are controlled by two attributes. The first,
<em class="firstterm">timeout</em>,
is the delay after the initial press of an auto-repeating key and the first
generated repeat event. The second,
<em class="firstterm">interval</em>,
is the delay between all subsequent generated repeat events. As with all
boolean controls, configuring the attributes that determine how the control
operates does not automatically enable the control as a whole; see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>.
</p><p>
To get the current attributes of the
<span class="emphasis"><em>RepeatKeys</em></span>
control for a keyboard device, use
<code class="function">XkbGetAutoRepeatRate</code>.
</p><a id="idm4209" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetAutoRepeatRate"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetAutoRepeatRate</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int *<var class="pdparam">timeout_rtrn</var>, unsigned int *<var class="pdparam">interval_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        desired device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>timeout_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with initial repeat delay, ms
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>interval_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with subsequent repeat delay, ms
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetAutoRepeatRate</code>
queries the server for the current values of the
<span class="emphasis"><em>RepeatControls</em></span>
control attributes, backfills
<em class="parameter"><code>timeout_rtrn</code></em>
and
<em class="parameter"><code>interval_rtrn</code></em>
with them, and returns
<span class="symbol">True</span>.
If a compatible version of the Xkb extension is not available in the server
<code class="function">XkbGetAutoRepeatRate</code>
returns
<span class="symbol">False</span>.
</p><p>
To set the attributes of the RepeatKeys control for a keyboard device, use
<code class="function">XkbSetAutoRepeatRate</code>.
</p><a id="idm4256" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetAutoRepeatRate"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetAutoRepeatRate</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">timeout</var>, unsigned int <var class="pdparam">interval</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device to configure, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>timeout</code></em>
    </span></p></td><td><p>
        initial delay, ms
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>interval</code></em>
    </span></p></td><td><p>
        delay between repeats, ms
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetAutoRepeatRate</code>
sends a request to the X server to configure the
<span class="emphasis"><em>AutoRepeat</em></span>
control attributes to the values specified in
<em class="parameter"><code>timeout</code></em>
and
<em class="parameter"><code>interval</code></em>.
</p><p>
<code class="function">XkbSetAutoRepeatRate</code>
does not wait for a reply; it normally returns
<span class="symbol">True</span>.
Specifying a zero value for either
<em class="parameter"><code>timeout</code></em>
or
<em class="parameter"><code>interval</code></em>
causes the server to generate a
<span class="errorname">BadValue</span>
protocol error. If a compatible version of the Xkb extension is not available
in the server,
<code class="function">XkbSetAutoRepeatRate</code>
returns
<span class="symbol">False</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_DetectableAutorepeat_Control"></a>The DetectableAutorepeat Control</h3></div></div></div><p>
Auto-repeat is the generation of multiple key events by a keyboard when the
user presses a key and holds it down. Keyboard hardware and device-dependent X
server software often implement auto-repeat by generating multiple
<span class="symbol">KeyPress</span>
events with no intervening
<span class="symbol">KeyRelease</span>
event. The standard behavior of the X server is to generate a
<span class="symbol">KeyRelease</span>
event for every
<span class="symbol">KeyPress</span>
event. If the keyboard hardware and device-dependent software of the X server
implement auto-repeat by generating multiple
<span class="symbol">KeyPress</span>
events, the device-independent part of the X server by default synthetically
generates a
<span class="symbol">KeyRelease</span>
event after each
<span class="symbol">KeyPress</span>
event. This provides predictable behavior for X clients, but does not allow
those clients to detect the fact that a key is auto-repeating.
</p><p>
Xkb allows clients to request
<em class="firstterm">detectable auto-repeat</em>.
<a id="idm4318" class="indexterm"></a>
<a id="idm4320" class="indexterm"></a>
If a client requests and the server supports
<span class="emphasis"><em>DetectableAutorepeat</em></span>,
Xkb generates
<span class="symbol">KeyRelease</span>
events only when the key is physically released. If
<span class="emphasis"><em>DetectableAutorepeat</em></span>
is not supported or has not been requested, the server synthesizes a
<span class="symbol">KeyRelease</span>
event for each repeating
<span class="symbol">KeyPress</span>
event it generates.
</p><p>
<span class="emphasis"><em>DetectableAutorepeat</em></span>,
unlike the other controls in this chapter, is not contained in the
<span class="structname">XkbControlsRec</span>
structure, nor can it be enabled or disabled via the
<span class="emphasis"><em>EnabledControls</em></span>
control. Instead, query and set
<span class="emphasis"><em>DetectableAutorepeat</em></span>
using
<code class="function">XkbGetDetectableAutorepeat</code>
and
<code class="function">XkbSetDetectableAutorepeat</code>.
</p><p>
<span class="emphasis"><em>DetectableAutorepeat</em></span>
is a condition that applies to all keyboard devices for a client’s
connection to a given X server; it cannot be selectively set for some devices
and not for others. For this reason, none of the Xkb library functions
involving
<span class="emphasis"><em>DetectableAutorepeat</em></span>
involve a device specifier.
</p><p>
To determine whether or not the server supports
<span class="emphasis"><em>DetectableAutorepeat</em></span>,
use
<code class="function">XkbGetDetectableAutorepeat</code>.
</p><a id="idm4341" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetDetectableAutorepeat"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetDetectableAutorepeat</strong>(</code>Display *<var class="pdparam">display</var>, Bool *<var class="pdparam">supported_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>supported_rtrn</code></em>
    </span></p></td><td><p>
        backfilled <span class="symbol">True</span> if
<span class="emphasis"><em>DetectableAutorepeat</em></span>
         supported
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetDetectableAutorepeat</code>
queries the server for the current state of
<span class="emphasis"><em>DetectableAutorepeat</em></span>
and waits for a reply. If
<em class="parameter"><code>supported_rtrn</code></em>
is not
<span class="symbol">NULL</span>,
it backfills supported_rtrn with
<span class="symbol">True</span>
if the server supports
<span class="emphasis"><em>DetectableAutorepeat</em></span>,
and
<span class="symbol">False</span>
otherwise.
<code class="function">XkbGetDetectableAutorepeat</code>
returns the current state of
<span class="emphasis"><em>DetectableAutorepeat</em></span>
for the requesting client:
<span class="symbol">True</span>
if
<span class="emphasis"><em>DetectableAutorepeat</em></span>
is set, and
<span class="symbol">False</span>
otherwise.
</p><p>
To set
<span class="emphasis"><em>DetectableAutorepeat</em></span>,
use
<code class="function">XkbSetDetectableAutorepeat</code>.
This request affects all keyboard activity for the requesting client only;
other clients still see the expected nondetectable auto-repeat behavior, unless
they have requested otherwise.
</p><a id="idm4381" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetDetectableAutorepeat"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetDetectableAutorepeat</strong>(</code>Display *<var class="pdparam">display</var>, Bool <var class="pdparam">detectable</var>, Bool *<var class="pdparam">supported_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>detectable</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ set
<span class="emphasis"><em>DetectableAutorepeat</em></span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>supported_rtrn</code></em>
    </span></p></td><td><p>
        backfilled <span class="symbol">True</span> if
<span class="emphasis"><em>DetectableAutorepeat</em></span>
         supported
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetDetectableAutorepeat</code>
sends a request to the server to set
<span class="emphasis"><em>DetectableAutorepeat</em></span>
on for the current client if
<em class="parameter"><code>detectable</code></em>
is
<span class="symbol">True</span>,
and off it
<em class="parameter"><code>detectable</code></em>
is
<span class="symbol">False</span>;
it then waits for a reply. If
<em class="parameter"><code>supported_rtrn</code></em>
is not
<span class="symbol">NULL</span>,
<code class="function">XkbSetDetectableAutorepeat</code>
backfills
<em class="parameter"><code>supported_rtrn</code></em>
with
<span class="symbol">True</span>
if the server supports
<span class="emphasis"><em>DetectableAutorepeat</em></span>,
and
<span class="symbol">False</span>
if it does not.
<code class="function">XkbSetDetectableAutorepeat</code>
returns the current state of
<span class="emphasis"><em>DetectableAutorepeat</em></span>
for the requesting client:
<span class="symbol">True</span>
if
<span class="emphasis"><em>DetectableAutorepeat</em></span>
is set, and
<span class="symbol">False</span>
otherwise.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls"></a>Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)</h2></div></div></div><p>
A keyboard overlay allows some subset of the keyboard to report alternate
keycodes when the overlay is enabled. For example, a keyboard overlay can be
used to simulate a numeric or editing keypad on a keyboard that does not
actually have one by reusing some portion of the keyboard as an overlay. This
technique is very common on portable computers and embedded systems with small
keyboards.
</p><p>
Xkb includes direct support for two keyboard overlays, using the
<span class="emphasis"><em>Overlay1</em></span>
and
<span class="emphasis"><em>Overlay2</em></span>
controls. When
<span class="emphasis"><em>Overlay1</em></span>
is enabled, all of the keys that are members of the first keyboard overlay
generate an alternate keycode. When
<span class="emphasis"><em>Overlay2</em></span>
is enabled, all of the keys that are members of the second keyboard overlay
generate an alternate keycode. The two overlays are mutually exclusive; any
particular key may be in at most one overlay.
<span class="emphasis"><em>Overlay1</em></span>
and
<span class="emphasis"><em>Overlay2</em></span>
are boolean controls. As such, you may enable and disable them using either
the
<span class="emphasis"><em>EnabledControls</em></span>
control or the
<span class="emphasis"><em>AutoReset</em></span>
control discussed in <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>.
</p><p>
To specify the overlay to which a key belongs and the alternate keycode it
should generate when that overlay is enabled, assign it either the
<span class="symbol">XkbKB_Overlay1</span>
or
<span class="symbol">XkbKB_Overlay2</span>
key behaviors, as described in <a class="link" href="#Key_Behavior" title="Key Behavior">section 16.2</a>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_for_Using_the_Mouse_from_the_Keyboard"></a>Controls for Using the Mouse from the Keyboard</h2></div></div></div><p>
Using Xkb, it is possible to configure the keyboard to allow simulation of the
X pointer device. This simulation includes both movement of the pointer itself
and press and release events associated with the buttons on the pointer. Two
controls affect this behavior: the
<span class="emphasis"><em>MouseKeys</em></span>
control determines whether or not simulation of the pointer device is active,
as well as configuring the default button; the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control determines the movement characteristics of the pointer when simulated
via the keyboard. Both of them are boolean controls; as such, you may enable
and disable them using either the
<span class="emphasis"><em>EnabledControls</em></span>
control or the
<span class="emphasis"><em>AutoReset</em></span>
control discussed in <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>. The individual keys that simulate
different aspects of the pointer device are determined by the keyboard mapping,
discussed in <a class="xref" href="#Xkb_Server_Keyboard_Mapping" title="Chapter 16. Xkb Server Keyboard Mapping">Chapter 16, <em>Xkb Server Keyboard Mapping</em></a>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_MouseKeys_Control"></a>The MouseKeys Control</h3></div></div></div><p>
The
<span class="emphasis"><em>MouseKeys</em></span>
control allows a user to control all the mouse functions from the keyboard.
When
<span class="emphasis"><em>MouseKeys</em></span>
are enabled, all keys with
<span class="emphasis"><em>MouseKeys</em></span>
actions bound to them generate core pointer events instead of normal
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events.
</p><p>
The
<span class="emphasis"><em>MouseKeys</em></span>
control has a single attribute,
<em class="structfield"><code>mk_dflt_btn</code></em>
that specifies the core button number to be used by mouse keys actions that do
not explicitly specify a button. There is no convenience function for getting
or setting the attribute; instead use
<code class="function">XkbGetControls</code>
and
<code class="function">XkbSetControls</code>
(see <a class="link" href="#Querying_Controls" title="Querying Controls">section 10.9</a> and <a class="link" href="#Changing_Controls" title="Changing Controls">section 10.10</a>).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
<span class="emphasis"><em>MouseKeys</em></span>
can also be turned on and off by pressing the key combination necessary to
produce an
<span class="keysym">XK_Pointer_EnableKeys</span>
keysym. The de facto default standard for this is
<span class="keycap"><strong>Shift</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>NumLock</strong></span>,
but this may vary depending on the keymap.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_MouseKeysAccel_Control"></a>The MouseKeysAccel Control</h3></div></div></div><p>
When the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control is enabled, the effect of a key-activated pointer motion action
changes as a key is held down. If the control is disabled, pressing a
mouse-pointer key yields one mouse event. When
<span class="emphasis"><em>MouseKeysAccel</em></span>
is enabled, mouse movement is defined by an initial distance specified in the
<span class="symbol">XkbSA_MovePtr</span>
action and the following fields in the
<span class="structname">XkbControlsRec</span>
structure (see <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>).
</p><div class="table"><a id="table10.2"></a><p class="title"><strong>Table 10.2. MouseKeysAccel Fields</strong></p><div class="table-contents"><table class="table" summary="MouseKeysAccel Fields" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Field</th><th align="left">Function</th></tr></thead><tbody><tr><td align="left">mk_delay</td><td align="left">Time (ms) between the initial key press and the first repeated
motion event</td></tr><tr><td align="left">mk_interval</td><td align="left">Time (ms) between repeated motion events</td></tr><tr><td align="left">mk_time_to_max</td><td align="left">Number of events (count) before the pointer reaches maximum
speed</td></tr><tr><td align="left">mk_max_speed</td><td align="left">The maximum speed (in pixels per event) the pointer reaches</td></tr><tr><td align="left">mk_curve</td><td align="left">The ramp used to reach maximum pointer speed</td></tr></tbody></table></div></div><br class="table-break" /><p>
There are no convenience functions to query or change the attributes of the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control; instead use
<code class="function">XkbGetControls</code>
and
<code class="function">XkbSetControls</code>
(see <a class="link" href="#Querying_Controls" title="Querying Controls">section 10.9</a> and <a class="link" href="#Changing_Controls" title="Changing Controls">section 10.10</a>).
</p><p>
The effects of the attributes of the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control depend on whether the
<span class="symbol">XkbSA_MovePtr</span>
action (see <a class="link" href="#Key_Actions" title="Key Actions">section 16.1</a>) specifies relative or absolute pointer motion.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="Absolute_Pointer_Motion"></a>Absolute Pointer Motion</h4></div></div></div><p>
If an
<span class="symbol">XkbSA_MovePtr</span>
action specifies an absolute position for one of the coordinates but still
allows acceleration, all repeated events contain any absolute coordinates
specified in the action. For example, if the
<span class="symbol">XkbSA_MovePtr</span>
action specifies an absolute position for the X direction, but a relative
motion for the Y direction, the pointer accelerates in the Y direction, but
stays at the same X position.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="Relative_Pointer_Motion"></a>Relative Pointer Motion</h4></div></div></div><p>
If the
<span class="symbol">XkbSA_MovePtr</span>
action specifies relative motion, the initial event always moves the cursor
the distance specified in the action. After
<em class="structfield"><code>mk_delay</code></em>
milliseconds, a second motion event is generated, and another occurs every
<em class="structfield"><code>mk_interval</code></em>
milliseconds until the user releases the key.
</p><p>
Between the time of the second motion event and
<em class="structfield"><code>mk_time_to_max</code></em>
intervals, the change in pointer distance per interval increases with each
interval. After
<em class="structfield"><code>mk_time_to_max</code></em>
intervals have elapsed, the change in pointer distance per interval remains
the same and is calculated by multiplying the original distance specified in
the action by
<em class="structfield"><code>mk_max_speed</code></em>.
</p><p>
For example, if the
<span class="symbol">XkbSA_MovePtr</span>
action specifies a relative motion in the X direction of 5,
<em class="structfield"><code>mk_delay</code></em>
=160,
<em class="structfield"><code>mk_interval</code></em>
=40,
<em class="structfield"><code>mk_time_to_max</code></em>
=30, and
<em class="structfield"><code>mk_max_speed</code></em>
=30, the following happens when the user presses the key:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The pointer immediately moves 5 pixels in the X direction when the key is
pressed.
  </p></li><li class="listitem"><p>
After 160 milliseconds
(<em class="structfield"><code>mk_delay</code></em>),
and every 40 milliseconds thereafter
(<em class="structfield"><code>mk_interval</code></em>),
the pointer moves in the X direction.
  </p></li><li class="listitem"><p>
The distance in the X direction increases with each interval until 30 intervals
(
<em class="structfield"><code>mk_time_to_max</code></em>)
have elapsed.
  </p></li><li class="listitem"><p>
After 30 intervals, the pointer stops accelerating, and moves 150 pixels
(
<em class="structfield"><code>mk_max_speed</code></em>
* the original distance) every interval thereafter, until the key is released.
  </p></li></ul></div><p>
The increase in pointer difference for each interval is a function of
<em class="structfield"><code>mk_curve</code></em>.
Events after the first but before maximum acceleration has been achieved are
accelerated according to the formula:
</p><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-3.svg"></object></div><p>
Where
<span class="emphasis"><em>action_delta</em></span>
is the relative motion specified by the
<span class="symbol">XkbSA_MovePtr</span>
action,
<em class="structfield"><code>mk_max_speed</code></em>
and
<em class="structfield"><code>mk_time_to_max</code></em>
are parameters to the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control, and the curveFactor is computed using the
<span class="emphasis"><em>MouseKeysAccel</em></span>
<em class="structfield"><code>mk_curve</code></em>
parameter as follows:
</p><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-4.svg"></object></div><p>
With the result that a
<em class="structfield"><code>mk_curve</code></em>
of zero causes the distance moved to increase linearly from
<span class="emphasis"><em>action_delta</em></span>
to </p><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-5.svg"></object></div><p>.
A negative
<em class="structfield"><code>mk_curve</code></em>
causes an initial sharp increase in acceleration that tapers off, and a
positive curve yields a slower initial increase in acceleration followed by a
sharp increase as the number of pointer events generated by the action
approaches
<em class="structfield"><code>mk_time_to_max</code></em>.
The legal values for
<em class="structfield"><code>mk_curve</code></em>
are between −1000 and 1000.
</p><p>
A distance vs. time graph of the pointer motion is shown in
<a class="link" href="#figure10.1" title="Figure 10.1. MouseKeys Acceleration">Figure 10.1</a>.
</p><div class="figure"><a id="figure10.1"></a><p class="title"><strong>Figure 10.1. MouseKeys Acceleration</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-6.svg"></object></div></div></div><br class="figure-break" /></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_for_Better_Keyboard_Access_by_Physically_ImpairedPersons"></a>Controls for Better Keyboard Access by Physically Impaired
Persons</h2></div></div></div><p>
The Xkb extension includes several controls specifically aimed at making
keyboard use more effective for physically impaired people. All of these
controls are boolean controls and may be individually enabled and disabled, as
well as configured to tune their specific behavior. The behavior of these
controls is based on the AccessDOS package
<a href="#ftn.idm4594" class="footnote" id="idm4594"><sup class="footnote">[4]</sup></a>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_AccessXKeys_Control"></a>The AccessXKeys Control</h3></div></div></div><p>
Enabling or disabling the keyboard controls through a graphical user interface
may be impossible for people who need to use the controls. For example, a user
who needs
<span class="emphasis"><em>SlowKeys</em></span>
(see <a class="link" href="#The_SlowKeys_Control" title="The SlowKeys Control">section 10.6.6</a>) may not even be able to start the graphical application,
let alone use it, if
<span class="emphasis"><em>SlowKeys</em></span>
is not enabled. To allow easier access to some of the controls, the
<span class="emphasis"><em>AccessXKeys</em></span>
control provides a set of special key sequences similar to those available in
AccessDOS.
</p><p>
When the
<span class="emphasis"><em>AccessXKeys</em></span>
control is enabled, the user can turn controls on or off from the keyboard by
entering the following standard key sequences:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Holding down a <span class="keycap"><strong>Shift</strong></span> key by itself for eight seconds
toggles the
<span class="emphasis"><em>SlowKeys</em></span>
control.
  </p></li><li class="listitem"><p>
Pressing and releasing the left or right
<span class="keycap"><strong>Shift</strong></span>
key five times in a row, without any intervening key events and with less than
30 seconds delay between consecutive presses, toggles the state of the
<span class="emphasis"><em>StickyKeys</em></span>
control.
  </p></li><li class="listitem"><p>
Simultaneously operating two or more modifier keys deactivates the
<span class="emphasis"><em>StickyKeys</em></span>
control.
  </p></li></ul></div><p>
When the
<span class="emphasis"><em>AccessXKeys</em></span>
control is disabled, Xkb does not look for the above special key sequences.
</p><p>
Some of these key sequences optionally generate audible feedback of the change
in state, as described in <a class="link" href="#The_AccessXFeedback_Control" title="The AccessXFeedback Control">section 10.6.3</a>, or
<span class="symbol">XkbControlsNotify</span>
events, described in <a class="link" href="#Tracking_Changes_to_Keyboard_Controls" title="Tracking Changes to Keyboard Controls">section 10.11</a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_AccessXTimeout_Control"></a>The AccessXTimeout Control</h3></div></div></div><p>
In environments where computers are shared, features such as
<span class="emphasis"><em>SlowKeys</em></span>
present a problem: if
<span class="emphasis"><em>SlowKeys</em></span>
is on, the keyboard can appear to be unresponsive because keys are not
accepted until they are held for a certain period of time. To help solve this
problem, Xkb provides an
<span class="emphasis"><em>AccessXTimeout</em></span>
control to automatically change the enabled/disabled state of any boolean
controls and to change the value of the
<span class="emphasis"><em>AccessXKeys</em></span>
and
<span class="emphasis"><em>AccessXFeedback</em></span>
control attributes if the keyboard is idle for a specified period of time.
</p><p>
When a timeout as specified by
<span class="emphasis"><em>AccessXTimeout</em></span>
occurs and a control is consequently modified, Xkb generates an
<span class="symbol">XkbControlsNotify</span>
event. For more information on
<span class="symbol">XkbControlsNotify</span>
events, refer to <a class="link" href="#Tracking_Changes_to_Keyboard_Controls" title="Tracking Changes to Keyboard Controls">section 10.11</a>.
</p><p>
Use
<code class="function">XkbGetAccessXTimeout</code>
to query the current
<span class="emphasis"><em>AccessXTimeout</em></span>
options for a keyboard device.
</p><a id="idm4639" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetAccessXTimeout"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetAccessXTimeout</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned short *<var class="pdparam">timeout_rtrn</var>, unsigned int *<var class="pdparam">ctrls_mask_rtrn</var>, unsigned int *<var class="pdparam">ctrls_values_rtrn</var>, unsigned short *<var class="pdparam">opts_mask_rtrn</var>, unsigned short *<var class="pdparam">opts_values_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device to query, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>timeout_rtrn</code></em>
    </span></p></td><td><p>
        delay until AccessXTimeout, seconds
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls_mask_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with controls to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls_values_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with on/off status for controls
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>opts_mask_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with <em class="structfield"><code>ax_options</code></em> to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>opts_values_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with values for <em class="structfield"><code>ax_options</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetAccessXTimeout</code>
sends a request to the X server to obtain the current values for the
<span class="emphasis"><em>AccessXTimeout</em></span>
attributes, waits for a reply, and backfills the values into the appropriate
arguments.
The parameters
<em class="parameter"><code>opts_mask_rtrn</code></em>
and
<em class="parameter"><code>opts_values_rtrn</code></em>
are backfilled with the options to modify and the values for
<em class="structfield"><code>ax_options</code></em>,
which is a field in the
<span class="structname">XkbControlsRec</span>
structure (see <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>).
<code class="function">XkbGetAccessXTimeout</code>
returns
<span class="symbol">True</span>
if successful; if a compatible version of the Xkb extension is not available
in the server,
<code class="function">XkbGetAccessXTimeout</code>
returns
<span class="symbol">False</span>.
</p><p>
To configure the
<span class="emphasis"><em>AccessXTimeout</em></span>
options for a keyboard device, use
<code class="function">XkbSetAccessXTimeout</code>.
</p><a id="idm4714" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetAccessXTimeout"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetAccessXTimeout</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned short <var class="pdparam">timeout</var>, unsigned int <var class="pdparam">ctrls_mask</var>, unsigned int <var class="pdparam">ctrls_values</var>, unsigned short <var class="pdparam">opts_mask</var>, unsigned short <var class="pdparam">opts_values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device to configure, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>timeout</code></em>
    </span></p></td><td><p>
        seconds idle until AccessXTimeout occurs
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls_mask</code></em>
    </span></p></td><td><p>
        boolean controls to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls_values</code></em>
    </span></p></td><td><p>
        new bits for controls selected by <em class="parameter"><code>ctrls_mask</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>opts_mask</code></em>
    </span></p></td><td><p>
        <em class="structfield"><code>ax_options</code></em> to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>opts_values</code></em>
    </span></p></td><td><p>
        new bits for <em class="structfield"><code>ax_options</code></em> selected by <em class="parameter"><code>opts_mask</code></em>
      </p></td></tr></tbody></table></div><p>
<em class="parameter"><code>timeout</code></em>
specifies the number of seconds the keyboard must be idle before the controls
are modified.
<em class="parameter"><code>ctrls_mask</code></em>
specifies what controls are to be enabled or disabled, and
<em class="parameter"><code>ctrls_values</code></em>
specifies whether those controls are to be enabled or disabled. The bit values
correspond to those for enabling and disabling boolean controls
(see <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>). The
<em class="parameter"><code>opts_mask</code></em>
field specifies which attributes of the
<span class="emphasis"><em>AccessXKeys</em></span>
and
<span class="emphasis"><em>AccessXFeedback</em></span>
controls are to be changed, and
<em class="parameter"><code>opts_values</code></em>
specifies the new values for those options. The bit values correspond to those
for the
<em class="structfield"><code>ax_options</code></em>
field of an
<span class="structname">XkbDescRec</span>
(see <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>).
</p><p>
<code class="function">XkbSetAccessXTimeout</code>
sends a request to configure the
<span class="emphasis"><em>AccessXTimeout</em></span>
control to the server.
It does not wait for a reply, and normally returns
<span class="symbol">True</span>.
If a compatible version of the Xkb extension is not available in the server,
<code class="function">XkbSetAccessXTimeout</code>
returns
<span class="symbol">False</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_AccessXFeedback_Control"></a>The AccessXFeedback Control</h3></div></div></div><p>
Just as some keyboards can produce keyclicks to indicate when a key is pressed
or repeating, Xkb can provide feedback for the controls by using special beep
codes. Use the
<span class="emphasis"><em>AccessXFeedback</em></span>
control to configure the specific types of operations that generate feedback.
</p><p>
There is no convenience function for modifying the
<span class="emphasis"><em>AccessXFeedback</em></span>
control, although the feedback as a whole can be enabled or disabled just as
other boolean controls are (see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>). Individual beep codes are turned
on or off by modifying the following bits in the
<em class="structfield"><code>ax_options</code></em>
field of an
<span class="structname">XkbControlsRec</span>
structure and using
<code class="function">XkbSetControls</code>
(see <a class="link" href="#Changing_Controls" title="Changing Controls">section 10.10</a>):
</p><div class="table"><a id="table10.3"></a><p class="title"><strong>Table 10.3. AccessXFeedback Masks</strong></p><div class="table-contents"><table class="table" summary="AccessXFeedback Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Action</th><th align="left">Beep Code</th><th align="left">ax_options bit</th></tr></thead><tbody><tr><td align="left">LED turned on</td><td align="left">High-pitched beep</td><td align="left"><span class="symbol">XkbAX_IndicatorFBMask</span></td></tr><tr><td align="left">LED turned off</td><td align="left">Low-pitched beep</td><td align="left"><span class="symbol">XkbAX_IndicatorFBMask</span></td></tr><tr><td align="left">More than one LED changed state</td><td align="left">Two high-pitched beeps</td><td align="left"><span class="symbol">XkbAX_IndicatorFBMask</span></td></tr><tr><td align="left">Control turned on</td><td align="left">Rising tone</td><td align="left"><span class="symbol">XkbAX_FeatureFBMask</span></td></tr><tr><td align="left">Control turned off</td><td align="left">Falling tone</td><td align="left"><span class="symbol">XkbAX_FeatureFBMask</span></td></tr><tr><td align="left">More than one control changed state</td><td align="left">Two high-pitched beeps</td><td align="left"><span class="symbol">XkbAX_FeatureFBMask</span></td></tr><tr><td align="left">SlowKeys and BounceKeys about to be turned on or off</td><td align="left">Three high-pitched beeps</td><td align="left"><span class="symbol">XkbAX_SlowWarnFBMask</span></td></tr><tr><td align="left">SlowKeys key pressed</td><td align="left">Medium-pitched beep</td><td align="left"><span class="symbol">XkbAX_SKPressFBMask</span></td></tr><tr><td align="left">SlowKeys key accepted</td><td align="left">Medium-pitched beep</td><td align="left"><span class="symbol">XkbAX_SKAcceptFBMask</span></td></tr><tr><td align="left">SlowKeys key rejected</td><td align="left">Low-pitched beep</td><td align="left"><span class="symbol">XkbAX_SKRejectFBMask</span></td></tr><tr><td align="left">Accepted SlowKeys key released</td><td align="left">Medium-pitched beep</td><td align="left"><span class="symbol">XkbAX_SKReleaseFBMask</span></td></tr><tr><td align="left">BounceKeys key rejected</td><td align="left">Low-pitched beep</td><td align="left"><span class="symbol">XkbAX_BKRejectFBMask</span></td></tr><tr><td align="left">StickyKeys key latched</td><td align="left">Low-pitched beep followed by high-pitched beep</td><td align="left"><span class="symbol">XkbAX_StickyKeysFBMask</span></td></tr><tr><td align="left">StickyKeys key locked</td><td align="left">High-pitched beep</td><td align="left"><span class="symbol">XkbAX_StickyKeysFBMask</span></td></tr><tr><td align="left">StickyKeys key unlocked</td><td align="left">Low-pitched beep</td><td align="left"><span class="symbol">XkbAX_StickyKeysFBMask</span></td></tr></tbody></table></div></div><br class="table-break" /><p>
Implementations that cannot generate continuous tones may generate multiple
beeps instead of falling and rising tones; for example, they can generate a
high-pitched beep followed by a low-pitched beep instead of a continuous
falling tone. Other implementations can only ring the bell with one fixed
pitch. In these cases, use the
<span class="symbol">XkbAX_DumbBellFBMask</span>
bit of
<em class="structfield"><code>ax_options</code></em>
to indicate that the bell can only ring with a fixed pitch.
</p><p>
When any of the above feedbacks occur, Xkb may generate a
<span class="symbol">XkbBellNotify</span>
event (see <a class="link" href="#Detecting_Bells" title="Detecting Bells">section 9.4</a>).
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="AccessXNotify_Events"></a>AccessXNotify Events</h3></div></div></div><a id="idm4900" class="indexterm"></a><a id="idm4904" class="indexterm"></a><p>
The server can generate
<span class="symbol">XkbAccessXNotify</span>
events for some of the global keyboard controls. The structure for the
<span class="symbol">XkbAccessXNotify</span>
event type is as follows:

</p><pre class="programlisting">
typedef struct {
    int             type;            /* Xkb extension base event code */
    unsigned long   serial;          /* X server serial number for event */
    Bool            send_event;      /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *       display;         /* server connection where event generated */
    Time            time;            /* server time when event generated */
    int             xkb_type;        /* <span class="symbol">XkbAccessXNotify</span> */
    int             device;          /* Xkb device ID, will not be <span class="symbol">XkbUseCoreKbd</span> */
    int             detail;          /* XkbAXN_* */
    KeyCode         keycode;         /* key of event */
    int             slowKeysDelay;   /* current SlowKeys delay */
    int             debounceDelay;   /* current debounce delay */
} <span class="structname">XkbAccessXNotifyEvent</span>;
</pre><p>
The
<em class="structfield"><code>detail</code></em>
field describes what AccessX event just occurred and can be any of the values
in <a class="link" href="#table10.4" title="Table 10.4. AccessXNotify Events">Table 10.4</a>.
</p><div class="table"><a id="table10.4"></a><p class="title"><strong>Table 10.4. AccessXNotify Events</strong></p><div class="table-contents"><table class="table" summary="AccessXNotify Events" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">detail</th><th align="left">Reason</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbAXN_SKPress</span></td><td align="left">A key was pressed when SlowKeys was enabled.</td></tr><tr><td align="left"><span class="symbol">XkbAXN_SKAccept</span></td><td align="left">A key was accepted (held longer than the SlowKeys delay).</td></tr><tr><td align="left"><span class="symbol">XkbAXN_SKRelease</span></td><td align="left">An accepted SlowKeys key was released.</td></tr><tr><td align="left"><span class="symbol">XkbAXN_SKReject</span></td><td align="left">A key was rejected (released before the SlowKeys delay
expired).</td></tr><tr><td align="left"><span class="symbol">XkbAXN_BKAccept</span></td><td align="left">A key was accepted by BounceKeys.</td></tr><tr><td align="left"><span class="symbol">XkbAXN_BKReject</span></td><td align="left">A key was rejected (pressed before the BounceKeys delay
expired).</td></tr><tr><td align="left"><span class="symbol">XkbAXN_AXKWarning</span></td><td align="left">AccessXKeys is about to turn on/off StickyKeys or BounceKeys.</td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>keycode</code></em>
field reports the keycode of the key for which the event occurred. If the
action is related to
<span class="emphasis"><em>SlowKeys</em></span>,
the
<em class="structfield"><code>slowKeysDelay</code></em>
field contains the current
<span class="emphasis"><em>SlowKeys</em></span>
acceptance delay. If the action is related to
<span class="emphasis"><em>BounceKeys</em></span>,
the
<em class="structfield"><code>debounceDelay</code></em>
field contains the current
<span class="emphasis"><em>BounceKeys</em></span>
debounce delay.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="Selecting_for_AccessX_Events"></a>Selecting for AccessX Events</h4></div></div></div><p>
To receive
<span class="symbol">XkbAccessXNotify</span>
events under all possible conditions, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) and pass
<span class="symbol">XkbAccessXNotifyMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
To receive
<span class="symbol">XkbStateNotify</span>
events only under certain conditions, use
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbAccessXNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying the desired state changes in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
using mask bits from <a class="link" href="#table10.5" title="Table 10.5. AccessXNotify Event Details">Table 10.5</a>.
</p><div class="table"><a id="table10.5"></a><p class="title"><strong>Table 10.5. AccessXNotify Event Details</strong></p><div class="table-contents"><table class="table" summary="AccessXNotify Event Details" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">XkbAccessXNotify Event Details</th><th align="left">Value</th><th align="left">Circumstances</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbAXN_SKPressMask</span></td><td align="left">(1&lt;&lt;0)</td><td align="left">Slow key press notification wanted</td></tr><tr><td align="left"><span class="symbol">XkbAXN_SKAcceptMask</span></td><td align="left">(1&lt;&lt;1)</td><td align="left">Slow key accept notification wanted</td></tr><tr><td align="left"><span class="symbol">XkbAXN_SKRejectMask</span></td><td align="left">(1&lt;&lt;2)</td><td align="left">Slow key reject notification wanted</td></tr><tr><td align="left"><span class="symbol">XkbAXN_SKReleaseMask</span></td><td align="left">(1&lt;&lt;3)</td><td align="left">Slow key release notification wanted</td></tr><tr><td align="left"><span class="symbol">XkbAXN_BKAcceptMask</span></td><td align="left">(1&lt;&lt;4)</td><td align="left">Bounce key accept notification wanted</td></tr><tr><td align="left"><span class="symbol">XkbAXN_BKRejectMask</span></td><td align="left">(1&lt;&lt;5)</td><td align="left">Bounce key reject notification wanted</td></tr><tr><td align="left"><span class="symbol">XkbAXN_AXKWarningMask</span></td><td align="left">(1&lt;&lt;6)</td><td align="left">AccessX warning notification wanted</td></tr><tr><td align="left">XkbAXN_AllEventsMask</td><td align="left">(0x7f)</td><td align="left">All AccessX features notifications wanted</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="StickyKeys_RepeatKeys_and_MouseKeys_Events"></a>StickyKeys, RepeatKeys, and MouseKeys Events</h3></div></div></div><p>
The
<span class="emphasis"><em>StickyKeys</em></span>,
<span class="emphasis"><em>RepeatKeys</em></span>,
and
<span class="emphasis"><em>MouseKeys</em></span>
controls do not generate specific events. Instead, the latching, unlatching,
locking, or unlocking of modifiers using
<span class="emphasis"><em>StickyKeys</em></span>
generates
<span class="symbol">XkbStateNotify</span>
events as described in <a class="link" href="#Tracking_Keyboard_State" title="Tracking Keyboard State">section 5.4</a>. Repeating keys generate normal
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events, though the auto-repeat can be detected using
<span class="emphasis"><em>DetectableAutorepeat</em></span>
(see <a class="link" href="#The_DetectableAutorepeat_Control" title="The DetectableAutorepeat Control">section 10.3.3</a>). Finally,
<span class="emphasis"><em>MouseKeys</em></span>
generates pointer events identical to those of the core pointer device.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_SlowKeys_Control"></a>The SlowKeys Control</h3></div></div></div><p>
Some users may accidentally bump keys while moving a hand or typing stick
toward the key they want. Usually, the keys that are accidentally bumped are
just hit for a very short period of time. The
<span class="emphasis"><em>SlowKeys</em></span>
control helps filter these accidental bumps by telling the server to wait a
specified period, called the
<em class="firstterm">SlowKeys acceptance delay</em>,
before delivering key events. If the key is released before this period
elapses, no key events are generated. Users can then bump any number of keys on
their way to the one they want without accidentally getting those characters.
Once they have reached the key they want, they can then hold the desired key
long enough for the computer to accept it.
<span class="emphasis"><em>SlowKeys</em></span>
is a boolean control with one configurable attribute.
</p><p>
When the
<span class="emphasis"><em>SlowKeys</em></span>
control is active, the server reports the initial key press, subsequent
acceptance or rejection, and release of any key to interested clients by
sending an appropriate
<span class="emphasis"><em>AccessXNotify</em></span>
event (see <a class="link" href="#AccessXNotify_Events" title="AccessXNotify Events">section 10.6.4</a>).
</p><p>
To get the
<span class="emphasis"><em>SlowKeys</em></span>
acceptance delay for a keyboard device, use
<code class="function">XkbGetSlowKeysDelay</code>.
</p><a id="idm5059" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetSlowKeysDelay"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetSlowKeysDelay</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int *<var class="pdparam">delay_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>delay_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with <span class="emphasis"><em>SlowKeys</em></span> delay, ms
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetSlowKeysDelay</code>
requests the attributes of the
<span class="emphasis"><em>SlowKeys</em></span>
control from the server, waits for a reply and backfills
<em class="parameter"><code>delay_rtrn</code></em>
with the
<span class="emphasis"><em>SlowKeys</em></span>
delay attribute.
<code class="function">XkbGetSlowKeysDelay</code>
returns
<span class="symbol">True</span>
if successful; if a compatible version of the Xkb extension is not available
in the server,
<code class="function">XkbGetSlowKeysDelay</code>
returns
<span class="symbol">False</span>.
</p><p>
To set the
<span class="emphasis"><em>SlowKeys</em></span>
acceptance delay for a keyboard device, use
<code class="function">XkbSetSlowKeysDelay</code>.
</p><a id="idm5102" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetSlowKeysDelay"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetSlowKeysDelay</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">delay</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device to configure, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>delay</code></em>
    </span></p></td><td><p>
        <span class="emphasis"><em>SlowKeys</em></span> delay, ms
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetSlowKeysDelay</code>
sends a request to configure the
<span class="emphasis"><em>SlowKeys</em></span>
control to the server.
It does not wait for a reply, and normally returns
<span class="symbol">True</span>.
Specifying a value of
<code class="literal">0</code>
for the
<em class="parameter"><code>delay</code></em>
parameter causes
<code class="function">XkbSetSlowKeysDelay</code>
to generate a
<span class="errorname">BadValue</span>
protocol error. If a compatible version of the Xkb extension is not available
in the server
<code class="function">XkbSetSlowKeysDelay</code>
returns
<span class="symbol">False</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_BounceKeys_Control"></a>The BounceKeys Control</h3></div></div></div><p>
Some users may accidentally <span class="quote">“<span class="quote">bounce</span>”</span> on a key when they release it.
They press it once, then accidentally press it again after they release it. The
<span class="emphasis"><em>BounceKeys</em></span>
control temporarily disables a key after it has been pressed, effectively
<span class="quote">“<span class="quote">debouncing</span>”</span> the keyboard. The period of time the key is disabled
after it is released is known as the
<em class="firstterm">BounceKeys delay</em>.
<span class="emphasis"><em>BounceKeys</em></span>
is a boolean control.
</p><p>
When the
<span class="emphasis"><em>BounceKeys</em></span>
control is active, the server reports acceptance or rejection of any key to
interested clients by sending an appropriate
<span class="emphasis"><em>AccessXNotify</em></span>
event (see <a class="link" href="#AccessXNotify_Events" title="AccessXNotify Events">section 10.6.4</a>).
</p><p>
Use
<code class="function">XkbGetBounceKeysDelay</code>
to query the current
<span class="emphasis"><em>BounceKeys</em></span>
delay for a keyboard device.
</p><a id="idm5158" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetBounceKeysDelay"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetBounceKeysDelay</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int *<var class="pdparam">delay_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>delay_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with bounce keys delay, ms
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetBounceKeysDelay</code>
requests the attributes of the
<span class="emphasis"><em>BounceKeys</em></span>
control from the server, waits for a reply, and backfills
<em class="parameter"><code>delay_rtrn</code></em>
with the
<span class="emphasis"><em>BounceKeys</em></span>
delay attribute.
<code class="function">XkbGetBounceKeysDelay</code>
returns
<span class="symbol">True</span>
if successful; if a compatible version of the Xkb extension is not available
in the server
<code class="function">XkbGetSlowKeysDelay</code>
returns
<span class="symbol">False</span>.
</p><p>
To set the
<span class="emphasis"><em>BounceKeys</em></span>
delay for a keyboard device, use
<code class="function">XkbSetBounceKeysDelay</code>.
</p><a id="idm5200" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetBounceKeysDelay"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetBounceKeysDelay</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">delay</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device to configure, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>delay</code></em>
    </span></p></td><td><p>
        bounce keys delay, ms
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetBounceKeysDelay</code>
sends a request to configure the
<span class="emphasis"><em>BounceKeys</em></span>
control to the server.
It does not wait for a reply and normally returns
<span class="symbol">True</span>.
Specifying a value of
<span class="emphasis"><em>zero</em></span>
for the
<em class="parameter"><code>delay</code></em>
parameter causes
<code class="function">XkbSetBounceKeysDelay</code>
to generate a
<span class="errorname">BadValue</span>
protocol error. If a compatible version of the Xkb extension is not available
in the server,
<code class="function">XkbSetBounceKeysDelay</code>
returns
<span class="symbol">False</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_StickyKeys_Control"></a>The StickyKeys Control</h3></div></div></div><p>
Some people find it difficult or even impossible to press two keys at once. For
example, a one-fingered typist or someone using a mouth stick cannot press the
<span class="keycap"><strong>Shift</strong></span>
and
<span class="keycap"><strong>1</strong></span>
keys at the same time. The
<span class="emphasis"><em>StickyKeys</em></span>
control solves this problem by changing the behavior of the modifier keys.
With
<span class="emphasis"><em>StickyKeys</em></span>,
the user can first press a modifier, release it, then press another key. For
example, to get an exclamation point on a PC-style keyboard, the user can press
the
<span class="keycap"><strong>Shift</strong></span>
key, release it, and then press the
<span class="keycap"><strong>1</strong></span>
key.
</p><p>
<span class="emphasis"><em>StickyKeys</em></span>
also allows users to lock modifier keys without requiring special locking
keys. When
<span class="emphasis"><em>StickyKeys</em></span>
is enabled, a modifier is latched when the user presses it just once. The user
can press a modifier twice in a row to lock it, and then unlock it by pressing
it one more time.
</p><p>
When a modifier is latched, it becomes unlatched when the user presses a
nonmodifier key or a pointer button. For instance, to enter the sequence
<span class="keycap"><strong>Shift</strong></span>+<span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Z</strong></span>
the user could press and release the
<span class="keycap"><strong>Shift</strong></span>
key to latch it, then press and release the
<span class="keycap"><strong>Control</strong></span>
key to latch it, and finally press and release the
<span class="keycap"><strong>Z</strong></span> key. Because the
<span class="keycap"><strong>Control</strong></span>
key is a modifier key, pressing it does not unlatch the
<span class="keycap"><strong>Shift</strong></span>
key. Thus, after the user presses the
<span class="keycap"><strong>Control</strong></span>
key, both the
<span class="symbol">Shift</span>
and
<span class="symbol">Control</span>
modifiers are latched. When the user presses the
<span class="keycap"><strong>Z</strong></span>
key, the effect is as though the user had pressed
<span class="keycap"><strong>Shift</strong></span>+<span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>Z</strong></span>.
In addition, because the
<span class="keycap"><strong>Z</strong></span>
key is not a modifier key, the
<span class="symbol">Shift</span>
and
<span class="symbol">Control</span>
modifiers are unlatched.
</p><p>
Locking a modifier key means that the modifier affects any key or pointer
button the user presses until the user unlocks it or it is unlocked
programmatically. For example, to enter the sequence ("XKB") on a keyboard
where ‘(’ is a shifted ‘9’, ‘)’ is a shifted ‘0’, and ‘"’
is a shifted single quote, the user could press and release the
<span class="keycap"><strong>Shift</strong></span>
key twice to lock the
<span class="symbol">Shift</span>
modifier. Then, when the user presses the
<span class="keycap"><strong>9</strong></span>,
<span class="keycap"><strong>'</strong></span>,
<span class="keycap"><strong>x</strong></span>,
<span class="keycap"><strong>k</strong></span>,
<span class="keycap"><strong>b</strong></span>,
<span class="keycap"><strong>'</strong></span>,
and
<span class="keycap"><strong>0</strong></span>
keys in sequence, it generates ("XKB"). To unlock the
<span class="symbol">Shift</span>
modifier, the user can press and release the
<span class="keycap"><strong>Shift</strong></span>
key.
</p><p>
<span class="emphasis"><em>StickyKeys</em></span>
is a boolean control with two separate attributes that may be individually
configured: one to automatically disable it, and one to control the latching
behavior of modifier keys.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="StickyKeys_Options"></a>StickyKeys Options</h4></div></div></div><p>
The
<span class="emphasis"><em>StickyKeys</em></span>
control has two options that can be accessed via the
<em class="structfield"><code>ax_options</code></em>
of an
<span class="structname">XkbControlsRec</span>
structure (see <a class="link" href="#The_XkbControlsRec_Structure" title="The XkbControlsRec Structure">section 10.8</a>). The first option,
<span class="emphasis"><em>TwoKeys</em></span>,
specifies whether
<span class="emphasis"><em>StickyKeys</em></span>
should automatically turn off when two keys are pressed at the same time. This
feature is useful for shared computers so people who do not want them do not
need to turn
<span class="emphasis"><em>StickyKeys</em></span>
off if a previous user left
<span class="emphasis"><em>StickyKeys</em></span>
on. The second option,
<span class="emphasis"><em>LatchToLock</em></span>,
specifies whether or not
<span class="emphasis"><em>StickyKeys</em></span>
locks a modifier when pressed twice in a row.
</p><p>
Use
<code class="function">XkbGetStickyKeysOptions</code>
to query the current
<span class="emphasis"><em>StickyKeys</em></span>
attributes for a keyboard device.
</p><a id="idm5303" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetStickyKeysOptions"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetStickyKeysOptions</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int *<var class="pdparam">options_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>options_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with StickyKeys option mask
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetStickyKeysOptions</code>
requests the attributes of the
<span class="emphasis"><em>StickyKeys</em></span>
control from the server, waits for a reply, and backfills
<em class="parameter"><code>options_rtrn</code></em>
with a mask indicating whether the individual
<span class="emphasis"><em>StickyKeys</em></span>
options are on or off. Valid bits in
<em class="parameter"><code>options_rtrn</code></em>
are:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="symbol">XkbAX_TwoKeysMask</span></td></tr><tr><td><span class="symbol">XkbAX_LatchToLockMask</span></td></tr></table><p>
</p><p>
<code class="function">XkbGetStickyKeysOptions</code>
returns
<span class="symbol">True</span>
if successful; if a compatible version of the Xkb extension is not available
in the server
<code class="function">XkbGetStickyKeysOptions</code>
returns
<span class="symbol">False</span>.
</p><p>
To set the
<span class="emphasis"><em>StickyKeys</em></span>
attributes for a keyboard device, use
<code class="function">XkbSetStickyKeysOptions</code>.
</p><a id="idm5352" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetStickyKeysOptions"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetStickyKeysOptions</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">mask</var>, unsigned int <var class="pdparam">values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device to configure, or XkbUseCoreKbd
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mask</code></em>
    </span></p></td><td><p>
        selects StickyKeys attributes to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values</code></em>
    </span></p></td><td><p>
        values for selected attributes
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetStickyKeysOptions</code>
sends a request to configure the
<span class="emphasis"><em>StickyKeys</em></span>
control to the server.
It does not wait for a reply and normally returns
<span class="symbol">True</span>.
The valid bits to use for both the
<em class="parameter"><code>mask</code></em>
and
<em class="parameter"><code>values</code></em>
parameters are:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="symbol">XkbAX_TwoKeysMask</span></td></tr><tr><td><span class="symbol">XkbAX_LatchToLockMask</span></td></tr></table><p>
</p><p>
If a compatible version of the Xkb extension is not available in the server,
<code class="function">XkbSetStickyKeysOptions</code>
returns
<span class="symbol">False</span>.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_for_General_Keyboard_Mapping"></a>Controls for General Keyboard Mapping</h2></div></div></div><p>
There are several controls that apply to the keyboard mapping in general. They
control handling of out-of-range group indices and how modifiers are processed
and consumed in the server. These are:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="emphasis"><em>GroupsWrap</em></span></td></tr><tr><td><span class="emphasis"><em>IgnoreGroupLock</em></span></td></tr><tr><td><span class="emphasis"><em>IgnoreLockMods</em></span></td></tr><tr><td><span class="emphasis"><em>InternalMods</em></span></td></tr></table><p>
</p><p>
<span class="emphasis"><em>IgnoreGroupLock</em></span>
is a boolean control; the rest are always active.
</p><p>
Without the modifier processing options provided by Xkb, passive grabs set via
translations in a client (for example,
<span class="emphasis"><em>Alt&lt;KeyPress&gt;space</em></span>)
do not trigger if any modifiers other than those specified by the translation
are set. This results in problems in the user interface when either
<span class="emphasis"><em>NumLock</em></span>
or a secondary keyboard group is active. The
<span class="emphasis"><em>IgnoreLockMods</em></span>
and
<span class="emphasis"><em>IgnoreGroupLock</em></span>
controls make it possible to avoid this behavior without exhaustively
specifying a grab for every possible modifier combination.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_GroupsWrap_Control"></a>The GroupsWrap Control</h3></div></div></div><p>
The
<span class="emphasis"><em>GroupsWrap</em></span>
control determines how illegal groups are handled on a global basis. There are
a number of valid keyboard sequences that can cause the effective group number
to go out of range. When this happens, the group must be normalized back to a
valid number. The
<span class="emphasis"><em>GroupsWrap</em></span>
control specifies how this is done.
</p><p>
When dealing with group numbers, all computations are done using the group
index, which is the group number minus one. There are three different
algorithms; the
<span class="emphasis"><em>GroupsWrap</em></span>
control specifies which one is used:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>XkbRedirectIntoRange</p><p>
All invalid group numbers are converted to a valid group number by taking the
last four bits of the
<span class="emphasis"><em>GroupsWrap</em></span>
control and using them as the group index. If the result is still out of
range, Group one is used.
  </p></li><li class="listitem"><p>
XkbClampIntoRange
  </p><p>
All invalid group numbers are converted to the nearest valid group number.
Group numbers larger than the highest supported group number are mapped to the
highest supported group; those less than one are mapped to group one.
  </p></li><li class="listitem"><p>XkbWrapIntoRange</p><p>
All invalid group numbers are converted to a valid group number using integer
modulus applied to the group index.
  </p></li></ul></div><p>
There are no convenience functions for manipulating the
<span class="emphasis"><em>GroupsWrap</em></span>
control. Manipulate the
<span class="emphasis"><em>GroupsWrap</em></span>
control via the
<em class="structfield"><code>groups_wrap</code></em>
field in the
<span class="structname">XkbControlsRec</span>
structure, then use
<code class="function">XkbSetControls</code>
and
<code class="function">XkbGetControls</code>
(see <a class="link" href="#Querying_Controls" title="Querying Controls">section 10.9</a> and <a class="link" href="#Changing_Controls" title="Changing Controls">section 10.10</a>) to query and change this control.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>See also <a class="link" href="#Per_Key_Group_Information" title="Per-Key Group Information">section 15.3.2</a> or a discussion of the related field,
<em class="structfield"><code>group_info</code></em>,
which also normalizes a group under certain circumstances.</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_IgnoreLockMods_Control"></a>The IgnoreLockMods Control</h3></div></div></div><p>
The core protocol does not provide a way to exclude specific modifiers from
grab calculations, with the result that locking modifiers sometimes have
unanticipated side effects.
</p><p>
The
<span class="emphasis"><em>IgnoreLockMods</em></span>
control specifies modifiers that should be excluded from grab calculations.
These modifiers are also not reported in any core events except
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events that do not activate a passive grab and that do not occur while a grab
is active.
</p><p>
Manipulate the
<span class="emphasis"><em>IgnoreLockMods</em></span>
control via the
<em class="structfield"><code>ignore_lock</code></em>
field in the
<span class="structname">XkbControlsRec</span>
structure, then use
<code class="function">XkbSetControls</code>
and
<code class="function">XkbGetControls</code>
(see <a class="link" href="#Querying_Controls" title="Querying Controls">section 10.9</a> and <a class="link" href="#Changing_Controls" title="Changing Controls">section 10.10</a>) to query and change this control. Alternatively,
use
<code class="function">XkbSetIgnoreLockMods</code>.
</p><p>
To set the modifiers that, if locked, are not to be reported in matching events
to passive grabs, use
<code class="function">XkbSetIgnoreLockMods</code>.
</p><a id="idm5470" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetIgnoreLockMods"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetIgnoreLockMods</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">affect_real</var>, unsigned int <var class="pdparam">real_values</var>, unsigned int <var class="pdparam">affect_virtual</var>, unsigned int <var class="pdparam">virtual_values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>affect_real</code></em>
    </span></p></td><td><p>
        mask of real modifiers affected by this call
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>real_values</code></em>
    </span></p></td><td><p>
        values for affected real modifiers (1⇒set, 0⇒unset)
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>affect_virtual</code></em>
    </span></p></td><td><p>
        mask of virtual modifiers affected by this call
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>virtual_values</code></em>
    </span></p></td><td><p>
        values for affected virtual modifiers (1⇒set, 0⇒unset)
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetIgnoreLockMods</code>
sends a request to the server to change the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control.
<em class="parameter"><code>affect_real</code></em>
and
<em class="parameter"><code>real_values</code></em>
are masks of real modifier bits indicating which real modifiers are to be
added and removed from the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control. Modifiers selected by both
<em class="parameter"><code>affect_real</code></em>
and
<em class="parameter"><code>real_values</code></em>
are added to the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control; those selected by
<em class="parameter"><code>affect_real</code></em>
but not by
<em class="parameter"><code>real_values</code></em>
are removed from the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control. Valid values for
<em class="parameter"><code>affect_real</code></em>
and
<em class="parameter"><code>real_values</code></em>
consist of any combination of the eight core modifier bits:
<span class="symbol">ShiftMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">Mod1Mask</span>
–
<span class="symbol">Mod5Mask</span>.
<em class="parameter"><code>affect_virtual</code></em>
and
<em class="parameter"><code>virtual_values</code></em>
are masks of virtual modifier bits indicating which virtual modifiers are to
be added and removed from the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control. Modifiers selected by both
<em class="parameter"><code>affect_virtual</code></em>
and
<em class="parameter"><code>virtual_values</code></em>
are added to the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control; those selected by
<em class="parameter"><code>affect_virtual</code></em>
but not by
<em class="parameter"><code>virtual_values</code></em>
are removed from the server’s
<span class="emphasis"><em>IgnoreLockMods</em></span>
control.
See <a class="link" href="#Virtual_Modifier_Names_and_Masks" title="Virtual Modifier Names and Masks">section 7.1</a> for a discussion of virtual modifier masks to use in
<em class="parameter"><code>affect_virtual</code></em>
and
<em class="parameter"><code>virtual_values</code></em>.
<code class="function">XkbSetIgnoreLockMods</code>
does not wait for a reply from the server. It returns
<span class="symbol">True</span>
if the request was sent, and
<span class="symbol">False</span>
otherwise.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_IgnoreGroupLock_Control"></a>The IgnoreGroupLock Control</h3></div></div></div><p>
The
<span class="emphasis"><em>IgnoreGroupLock</em></span>
control is a boolean control with no attributes. If enabled, it specifies that
the locked state of the keyboard group should not be considered when activating
passive grabs.
</p><p>
Because
<span class="emphasis"><em>IgnoreGroupLock</em></span>
is a boolean control with no attributes, use the general boolean controls
functions (see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>) to change its state.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_InternalMods_Control"></a>The InternalMods Control</h3></div></div></div><p>
The core protocol does not provide any means to prevent a modifier from being
reported in events sent to clients; Xkb, however makes this possible via the
<span class="emphasis"><em>InternalMods</em></span>
control. It specifies modifiers that should be consumed by the server and not
reported to clients. When a key is pressed and a modifier that has its bit set
in the
<span class="emphasis"><em>InternalMods</em></span>
control is reported to the server, the server uses the modifier when
determining the actions to apply for the key. The server then clears the bit,
so it is not actually reported to the client. In addition, modifiers specified
in the
<span class="emphasis"><em>InternalMods</em></span>
control are not used to determine grabs and are not used to calculate core
protocol compatibility state.
</p><p>
Manipulate the
<span class="emphasis"><em>InternalMods</em></span>
control via the
<em class="structfield"><code>internal</code></em>
field in the
<span class="structname">XkbControlsRec</span>
structure, using
<code class="function">XkbSetControls</code>
and
<code class="function">XkbGetControls</code>
(see <a class="link" href="#Querying_Controls" title="Querying Controls">section 10.9</a>
and <a class="link" href="#Changing_Controls" title="Changing Controls">section 10.10</a>). Alternatively, use
<code class="function">XkbSetServerInternalMods</code>.
</p><p>
To set the modifiers that are consumed by the server before events are
delivered to the client, use
<code class="function">XkbSetServerInternalMods</code>.
</p><a id="idm5579" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetServerInternalMods"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetServerInternalMods</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">affect_real</var>, unsigned int <var class="pdparam">real_values</var>, unsigned int <var class="pdparam">affect_virtual</var>, unsigned int <var class="pdparam">virtual_values</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        ‘device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>affect_real</code></em>
    </span></p></td><td><p>
        mask of real modifiers affected by this call
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>real_values</code></em>
    </span></p></td><td><p>
        values for affected real modifiers (1⇒set, 0⇒unset)
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>affect_virtual</code></em>
    </span></p></td><td><p>
        mask of virtual modifiers affected by this call
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>virtual_values</code></em>
    </span></p></td><td><p>
        values for affected virtual modifiers (1⇒set, 0⇒unset)
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetServerInternalMods</code>
sends a request to the server to change the internal modifiers consumed by the
server.
<em class="parameter"><code>affect_real</code></em>
and
<em class="parameter"><code>real_values</code></em>
are masks of real modifier bits indicating which real modifiers are to be
added and removed from the server’s internal modifiers control. Modifiers
selected by both
<em class="parameter"><code>affect_real</code></em>
and
<em class="parameter"><code>real_values</code></em>
are added to the server’s internal modifiers control; those selected by
<em class="parameter"><code>affect_real</code></em>
but not by
<em class="parameter"><code>real_values</code></em>
are removed from the server’s internal modifiers mask. Valid values for
<em class="parameter"><code>affect_real</code></em>
and
<em class="parameter"><code>real_values</code></em>
consist of any combination of the eight core modifier bits:
<span class="symbol">ShiftMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">Mod1Mask</span>
–
<span class="symbol">Mod5Mask</span>.
<em class="parameter"><code>affect_virtual</code></em>
and
<em class="parameter"><code>virtual_values</code></em>
are masks of virtual modifier bits indicating which virtual modifiers are to
be added and removed from the server’s internal modifiers control. Modifiers
selected by both
<em class="parameter"><code>affect_virtual</code></em>
and
<em class="parameter"><code>virtual_values</code></em>
are added to the server’s internal modifiers control; those selected by
<em class="parameter"><code>affect_virtual</code></em>
but not by
<em class="parameter"><code>virtual_values</code></em>
are removed from the server’s internal modifiers control.
See <a class="link" href="#Virtual_Modifier_Names_and_Masks" title="Virtual Modifier Names and Masks">section 7.1</a> for a discussion of virtual modifier masks to use in
<em class="parameter"><code>affect_virtual</code></em>
and
<em class="parameter"><code>virtual_values</code></em>.
<code class="function">XkbSetServerInternalMods</code>
does not wait for a reply from the server. It returns
<span class="symbol">True</span>
if the request was sent and
<span class="symbol">False</span>
otherwise.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_XkbControlsRec_Structure"></a>The XkbControlsRec Structure</h2></div></div></div><a id="idm5659" class="indexterm"></a><p>
Many of the individual controls described in sections 10.1 through 10.7 may be
manipulated via convenience functions discussed in those sections. Some of
them, however, have no convenience functions. The
<span class="structname">XkbControlsRec</span>
structure allows the manipulation of one or more of the controls in a single
operation and to track changes to any of them in conjunction with the
<code class="function">XkbGetControls</code>
and
<code class="function">XkbSetControls</code>
functions. This is the only way to manipulate those controls that have no
convenience functions.
</p><p>
The
<span class="structname">XkbControlsRec</span>
structure is defined as follows:

</p><pre class="programlisting">
#define      XkbMaxLegalKeyCode       255
#define      XkbPerKeyBitArraySize    ((XkbMaxLegalKeyCode+1)/8)

typedef struct {
    unsigned char     mk_dflt_btn;       /* default button for
                                             keyboard driven mouse */
    unsigned char     num_groups;        /* number of keyboard groups */
    unsigned char     groups_wrap;       /* how to wrap out-of-bounds groups */
    XkbModsRec        internal;          /* defines server internal modifiers */
    XkbModsRec        ignore_lock;       /* modifiers to ignore when
                                             checking for grab */
    unsigned int      enabled_ctrls;     /* 1 bit ⇒ corresponding
                                             boolean control enabled */
    unsigned short    repeat_delay;      /* ms delay until first repeat */
    unsigned short    repeat_interval;   /* ms delay between repeats */
    unsigned short    slow_keys_delay;   /* ms minimum time key must be
                                             down to be ok */
    unsigned short    debounce_delay;    /* ms delay before key reactivated */
    unsigned short    mk_delay;          /* ms delay to second mouse
                                             motion event */
    unsigned short    mk_interval;       /* ms delay between repeat mouse
                                             events */
    unsigned short    mk_time_to_max;    /* # intervals until constant
                                             mouse move */
    unsigned short    mk_max_speed;      /* multiplier for maximum mouse speed */
    short             mk_curve;          /* determines mouse move curve type */
    unsigned short    ax_options;        /* 1 bit ⇒ Access X option enabled */
    unsigned short    ax_timeout;        /* seconds until Access X disabled */
    unsigned short    axt_opts_mask;     /* 1 bit ⇒ options to reset
                                             on Access X timeout */
    unsigned short    axt_opts_values;   /* 1 bit ⇒ turn option on, 0⇒ off */
    unsigned int      axt_ctrls_mask;    /* which bits in <em class="structfield"><code>enabled_ctrls</code></em>
                                             to modify */
    unsigned int      axt_ctrls_values;  /* values for new bits in
                                             <em class="structfield"><code>enabled_ctrls</code></em> */
    unsigned char     per_key_repeat[XkbPerKeyBitArraySize];
                                         /* per key auto repeat */
} <span class="structname">XkbControlsRec</span>, *XkbControlsPtr;
</pre><p>
</p><p>
The general-purpose functions that work with the
<span class="structname">XkbControlsRec</span>
structure use a mask to specify which controls are to be manipulated.
<a class="link" href="#table10.6" title="Table 10.6. Xkb Controls">Table 10.6</a>
lists these controls, the masks used to select them in the general
function calls
(<em class="structfield"><code>which</code></em>
parameter), and the data fields in the
<span class="structname">XkbControlsRec</span>
structure that comprise each of the individual controls. Also listed are the
bit used to turn boolean controls on and off and the section where each control
is described in more detail.
</p><div class="table"><a id="table10.6"></a><p class="title"><strong>Table 10.6. Xkb Controls</strong></p><div class="table-contents"><table class="table" summary="Xkb Controls" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /></colgroup><thead><tr><th align="left">Control</th><th align="left">Control Selection Mask (which parameter)</th><th align="left">Relevant XkbControlsRec Data Fields</th><th align="left">Boolean Control enabled_ctrls bit</th><th align="left">Section</th></tr></thead><tbody><tr><td align="left">AccessXFeedback</td><td align="left"><span class="symbol">XkbAccessXFeedbackMask</span></td><td align="left">ax_options:      XkbAX_*FBMask</td><td align="left">XkbAccessXFeedback­Mask</td><td align="left"><a class="link" href="#The_AccessXFeedback_Control" title="The AccessXFeedback Control">10.6.3</a></td></tr><tr><td align="left">AccessXKeys</td><td align="left"> </td><td align="left"> </td><td align="left">XkbAccessXKeys­Mask</td><td align="left"><a class="link" href="#The_AccessXKeys_Control" title="The AccessXKeys Control">10.6.1</a></td></tr><tr><td align="left">AccessXTimeout</td><td align="left"><span class="symbol">XkbAccessXTimeoutMask</span></td><td align="left">
      <p>ax_timeout</p>
      <p>axt_opts_mask</p>
      <p>axt_opts_values</p>
      <p>axt_ctrls_mask</p>
      <p>axt_ctrls_values</p>
    </td><td align="left">XkbAccessXTimeout­Mask</td><td align="left"><a class="link" href="#The_AccessXTimeout_Control" title="The AccessXTimeout Control">10.6.2</a></td></tr><tr><td align="left">AudibleBell</td><td align="left"> </td><td align="left"> </td><td align="left"><span class="symbol">XkbAudibleBellMask</span></td><td align="left"><a class="link" href="#Audible_Bells" title="Audible Bells">9.2</a></td></tr><tr><td align="left">AutoReset</td><td align="left"> </td><td align="left"> </td><td align="left"> </td><td align="left"><a class="link" href="#The_AutoReset_Control" title="The AutoReset Control">10.1.2</a></td></tr><tr><td align="left">BounceKeys</td><td align="left"><span class="symbol">XkbBounceKeysMask</span></td><td align="left">debounce_delay</td><td align="left"><span class="symbol">XkbBounceKeysMask</span></td><td align="left"><a class="link" href="#The_BounceKeys_Control" title="The BounceKeys Control">10.6.7</a></td></tr><tr><td align="left">Detectable-Autorepeat</td><td align="left"> </td><td align="left"> </td><td align="left"> </td><td align="left"><a class="link" href="#The_DetectableAutorepeat_Control" title="The DetectableAutorepeat Control">10.3.3</a></td></tr><tr><td align="left">EnabledControls</td><td align="left"><span class="symbol">XkbControlsEnabledMask</span></td><td align="left">enabled_ctrls</td><td align="left"><span class="emphasis"><em>Non-Boolean Control</em></span></td><td align="left"><a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">10.1.1</a></td></tr><tr><td align="left">GroupsWrap</td><td align="left"><span class="symbol">XkbGroupsWrapMask</span></td><td align="left">groups_wrap</td><td align="left"><span class="emphasis"><em>Non-Boolean Control</em></span></td><td align="left"><a class="link" href="#The_GroupsWrap_Control" title="The GroupsWrap Control">10.7.1</a></td></tr><tr><td align="left">IgnoreGroupLock</td><td align="left"> </td><td align="left"> </td><td align="left">XkbIgnoreGroupLock­Mask</td><td align="left"><a class="link" href="#The_IgnoreGroupLock_Control" title="The IgnoreGroupLock Control">10.7.3</a></td></tr><tr><td align="left">IgnoreLockMods</td><td align="left"><span class="symbol">XkbIgnoreLockModsMask</span></td><td align="left">ignore_lock</td><td align="left"><span class="emphasis"><em>Non-Boolean Control</em></span></td><td align="left"><a class="link" href="#Keyboard_State_Description" title="Keyboard State Description">5.1</a></td></tr><tr><td align="left">InternalMods</td><td align="left"><span class="symbol">XkbInternalModsMask</span></td><td align="left">internal</td><td align="left"><span class="emphasis"><em>Non-Boolean Control</em></span></td><td align="left"><a class="link" href="#Keyboard_State_Description" title="Keyboard State Description">5.1</a></td></tr><tr><td align="left">MouseKeys</td><td align="left"><span class="symbol">XkbMouseKeysMask</span></td><td align="left">mk_dflt_btn</td><td align="left"><span class="symbol">XkbMouseKeysMask</span></td><td align="left"><a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">10.5.1</a></td></tr><tr><td align="left">MouseKeysAccel</td><td align="left"><span class="symbol">XkbMouseKeysAccelMask</span></td><td align="left">
      <p>mk_delay</p>
      <p>mk_interval</p>
      <p>mk_time_to_max</p>
      <p>mk_max_speed</p>
      <p>mk_curve</p>
    </td><td align="left">XkbMouseKeysAccel­Mask</td><td align="left"><a class="link" href="#The_MouseKeysAccel_Control" title="The MouseKeysAccel Control">10.5.2</a></td></tr><tr><td align="left">Overlay1</td><td align="left"> </td><td align="left"> </td><td align="left"><span class="symbol">XkbOverlay1Mask</span></td><td align="left"><a class="link" href="#Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls" title="Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)">10.4</a></td></tr><tr><td align="left">Overlay2</td><td align="left"> </td><td align="left"> </td><td align="left"><span class="symbol">XkbOverlay2Mask</span></td><td align="left"><a class="link" href="#Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls" title="Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)">10.4</a></td></tr><tr><td align="left">PerKeyRepeat</td><td align="left"><span class="symbol">XkbPerKeyRepeatMask</span></td><td align="left">per_key_repeat</td><td align="left"><span class="emphasis"><em>Non-Boolean Control</em></span></td><td align="left"><a class="link" href="#The_PerKeyRepeat_Control" title="The PerKeyRepeat Control">10.3.1</a></td></tr><tr><td align="left">RepeatKeys</td><td align="left"><span class="symbol">XkbRepeatKeysMask</span></td><td align="left">
      <p>repeat_delay</p>
      <p>repeat_interval</p>
    </td><td align="left"><span class="symbol">XkbRepeatKeysMask</span></td><td align="left"><a class="link" href="#Controls_for_Repeat_Key_Behavior" title="Controls for Repeat Key Behavior">10.3</a></td></tr><tr><td align="left">SlowKeys</td><td align="left"><span class="symbol">XkbSlowKeysMask</span></td><td align="left">slow_keys_delay</td><td align="left"><span class="symbol">XkbSlowKeysMask</span></td><td align="left"><a class="link" href="#The_SlowKeys_Control" title="The SlowKeys Control">10.6.6</a></td></tr><tr><td align="left">StickyKeys</td><td align="left"><span class="symbol">XkbStickyKeysMask</span></td><td align="left">
      <p>ax_options:</p>
      <p>XkbAX_Two­KeysMask</p>
      <p>XkbAX_Latch­ToLockMask</p>
    </td><td align="left"><span class="symbol">XkbStickyKeysMask</span></td><td align="left"><a class="link" href="#The_StickyKeys_Control" title="The StickyKeys Control">10.6.8</a></td></tr></tbody></table></div></div><br class="table-break" /><p>
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>
shows the actual values for the individual mask bits used to select
controls for modification and to enable and disable the control. Note that the
same mask bit is used to specify general modifications to the parameters used
to configure the control
(<em class="structfield"><code>which</code></em>),
and to enable and disable the control
(<em class="structfield"><code>enabled_ctrls</code></em>).
The anomalies in the table (no <span class="quote">“<span class="quote">ok</span>”</span> in column) are for controls that have no
configurable attributes; and for controls that are not boolean controls and
therefore cannot be enabled or disabled.
</p><div class="table"><a id="table10.7"></a><p class="title"><strong>Table 10.7. Controls Mask Bits</strong></p><div class="table-contents"><table class="table" summary="Controls Mask Bits" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Mask Bit</th><th align="left">which or changed_ctrls</th><th align="left">enabled_ctrls</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbRepeatKeysMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;0)</td></tr><tr><td align="left"><span class="symbol">XkbSlowKeysMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;1)</td></tr><tr><td align="left"><span class="symbol">XkbBounceKeysMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;2)</td></tr><tr><td align="left"><span class="symbol">XkbStickyKeysMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;3)</td></tr><tr><td align="left"><span class="symbol">XkbMouseKeysMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;4)</td></tr><tr><td align="left"><span class="symbol">XkbMouseKeysAccelMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;5)</td></tr><tr><td align="left"><span class="symbol">XkbAccessXKeysMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;6)</td></tr><tr><td align="left"><span class="symbol">XkbAccessXTimeoutMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;7)</td></tr><tr><td align="left"><span class="symbol">XkbAccessXFeedbackMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(1L&lt;&lt;8)</td></tr><tr><td align="left"><span class="symbol">XkbAudibleBellMask</span></td><td align="left"> </td><td align="left">ok</td><td align="left">(1L&lt;&lt;9)</td></tr><tr><td align="left"><span class="symbol">XkbOverlay1Mask</span></td><td align="left"> </td><td align="left">ok</td><td align="left">(1L&lt;&lt;10)</td></tr><tr><td align="left"><span class="symbol">XkbOverlay2Mask</span></td><td align="left"> </td><td align="left">ok</td><td align="left">(1L&lt;&lt;11)</td></tr><tr><td align="left"><span class="symbol">XkbIgnoreGroupLockMask</span></td><td align="left"> </td><td align="left">ok</td><td align="left">(1L&lt;&lt;12)</td></tr><tr><td align="left"><span class="symbol">XkbGroupsWrapMask</span></td><td align="left">ok</td><td align="left"> </td><td align="left">(1L&lt;&lt;27)</td></tr><tr><td align="left"><span class="symbol">XkbInternalModsMask</span></td><td align="left">ok</td><td align="left"> </td><td align="left">(1L&lt;&lt;28)</td></tr><tr><td align="left"><span class="symbol">XkbIgnoreLockModsMask</span></td><td align="left">ok</td><td align="left"> </td><td align="left">(1L&lt;&lt;29)</td></tr><tr><td align="left"><span class="symbol">XkbPerKeyRepeatMask</span></td><td align="left">ok</td><td align="left"> </td><td align="left">(1L&lt;&lt;30)</td></tr><tr><td align="left"><span class="symbol">XkbControlsEnabledMask</span></td><td align="left">ok</td><td align="left"> </td><td align="left">(1L&lt;&lt;31)</td></tr><tr><td align="left"><span class="symbol">XkbAccessXOptionsMask</span></td><td align="left">ok</td><td align="left">ok</td><td align="left">(XkbStickyKeysMask | XkbAccessXFeedbackMask)</td></tr><tr><td align="left"><span class="symbol">XkbAllBooleanCtrlsMask</span></td><td align="left"> </td><td align="left">ok</td><td align="left">(0x00001FFF) </td></tr><tr><td align="left"><span class="symbol">XkbAllControlsMask</span></td><td align="left">ok</td><td align="left"> </td><td align="left">(0xF8001FFF)</td></tr></tbody></table></div></div><br class="table-break" /><p>
The individual fields of the
<span class="structname">XkbControlsRec</span>
structure are defined as follows.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm6021"></a></h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="mk_dflt_btn"></a>mk_dflt_btn</h4></div></div></div><p>
<em class="structfield"><code>mk_dflt_btn</code></em> is an attribute of the
<span class="emphasis"><em>MouseKeys</em></span>
control
(see <a class="link" href="#Controls_for_Using_the_Mouse_from_the_Keyboard" title="Controls for Using the Mouse from the Keyboard">section 10.5</a>). It
specifies the mouse button number to use for keyboard simulated mouse button
operations. Its value should be one of the core symbols
<span class="symbol">Button1</span>
–
<span class="symbol">Button5</span>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="num_groups"></a>num_groups</h4></div></div></div><p>
<em class="structfield"><code>num_groups</code></em>
is not a part of any control, but is reported in the
<span class="structname">XkbControlsRec</span>
structure whenever any of its components are fetched from the server. It
reports the number of groups the particular keyboard configuration uses and is
computed automatically by the server whenever the keyboard mapping changes.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="groups_wrap"></a>groups_wrap</h4></div></div></div><p>
<em class="structfield"><code>groups_wrap</code></em>
is an attribute of the
<span class="emphasis"><em>GroupsWrap</em></span>
control (see <a class="link" href="#The_GroupsWrap_Control" title="The GroupsWrap Control">section 10.7.1</a>). It specifies the handling of illegal groups on a
global basis. Valid values for
<em class="structfield"><code>groups_wrap</code></em>
are shown in <a class="link" href="#table10.8" title="Table 10.8. GroupsWrap options (groups_wrap field)">Table 10.8</a>.
</p><div class="table"><a id="table10.8"></a><p class="title"><strong>Table 10.8. GroupsWrap options (groups_wrap field)</strong></p><div class="table-contents"><table class="table" summary="GroupsWrap options (groups_wrap field)" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">groups_wrap symbolic name</th><th align="left">value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbWrapIntoRange</span></td><td align="left">(0x00)</td></tr><tr><td align="left"><span class="symbol">XkbClampIntoRange</span></td><td align="left">(0x40)</td></tr><tr><td align="left"><span class="symbol">XkbRedirectIntoRange</span></td><td align="left">(0x80)</td></tr></tbody></table></div></div><br class="table-break" /><p>
When
<em class="structfield"><code>groups_wrap</code></em>
is set to
<span class="symbol">XkbRedirectIntoRange</span>,
its four low-order bits specify the index of the group to use.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="internal"></a>internal</h4></div></div></div><p>
<em class="structfield"><code>internal</code></em>
is an attribute of the
<span class="emphasis"><em>InternalMods</em></span>
control (see <a class="link" href="#The_InternalMods_Control" title="The InternalMods Control">section 10.7.4</a>). It specifies modifiers to be consumed in the
server and not passed on to clients when events are reported. Valid values
consist of any combination of the eight core modifier bits:
<span class="symbol">ShiftMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">Mod1Mask</span>
–
<span class="symbol">Mod5Mask</span>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="ignore_lock"></a>ignore_lock</h4></div></div></div><p>
<em class="structfield"><code>ignore_lock</code></em>
is an attribute of the
<span class="emphasis"><em>IgnoreLockMods</em></span>
control (see <a class="link" href="#The_IgnoreLockMods_Control" title="The IgnoreLockMods Control">section 10.7.2</a>). It specifies modifiers to be ignored in grab
calculations. Valid values consist of any combination of the eight core
modifier bits:
<span class="symbol">ShiftMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">Mod1Mask</span>
–
<span class="symbol">Mod5Mask</span>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="enabled_ctrls"></a>enabled_ctrls</h4></div></div></div><p>
<em class="structfield"><code>enabled_ctrls</code></em>
is an attribute of the
<span class="emphasis"><em>EnabledControls</em></span>
control (see <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>). It contains one bit per boolean control. Each
bit determines whether the corresponding control is enabled or disabled; a one
bit means the control is enabled. The mask bits used to enable these controls
are listed in <a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>,
using only those masks with <span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="structfield"><code>enabled_ctrls</code></em>
column.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="repeat_delay_and_repeat_interval"></a>repeat_delay and repeat_interval</h4></div></div></div><p>
<em class="structfield"><code>repeat_delay</code></em>
and
<em class="structfield"><code>repeat_interval</code></em>
are attributes of the
<span class="emphasis"><em>RepeatKeys</em></span>
control (see <a class="link" href="#The_RepeatKeys_Control" title="The RepeatKeys Control">section 10.3.2</a>).
<em class="structfield"><code>repeat_delay</code></em>
is the initial delay before a key begins repeating, in milliseconds;
<em class="structfield"><code>repeat_interval</code></em>
is the delay between subsequent key events, in milliseconds.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="slow_keys_delay"></a>slow_keys_delay</h4></div></div></div><p>
<em class="structfield"><code>slow_keys_delay</code></em>
is an attribute of the
<span class="emphasis"><em>SlowKeys</em></span>
control (see <a class="link" href="#The_SlowKeys_Control" title="The SlowKeys Control">section 10.6.6</a>). Its value specifies the
<span class="emphasis"><em>SlowKeys</em></span>
acceptance delay period in milliseconds before a key press is accepted by the
server.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="debounce_delay"></a>debounce_delay</h4></div></div></div><p>
<em class="structfield"><code>debounce_delay</code></em>
is an attribute of the
<span class="emphasis"><em>BounceKeys</em></span>
control (see <a class="link" href="#The_BounceKeys_Control" title="The BounceKeys Control">section 10.6.7</a>). Its value specifies the
<span class="emphasis"><em>BounceKeys</em></span>
delay period in milliseconds for which the key is disabled after having been
pressed before another press of the same key is accepted by the server.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="mk_delay_mk_interval_mk_time_to_max_mk_max_speed_and_mk_curve"></a>mk_delay, mk_interval, mk_time_to_max, mk_max_speed, and mk_curve</h4></div></div></div><p>
<em class="structfield"><code>mk_delay</code></em>,
<em class="structfield"><code>mk_interval</code></em>,
<em class="structfield"><code>mk_time_to_max</code></em>,
<em class="structfield"><code>mk_max_speed</code></em>,
and
<em class="structfield"><code>mk_curve</code></em>
are attributes of the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control. Refer to <a class="link" href="#The_MouseKeysAccel_Control" title="The MouseKeysAccel Control">section 10.5.2</a> for a description of these fields and the
units involved.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="ax_options"></a>ax_options</h4></div></div></div><p>
The
<em class="structfield"><code>ax_options</code></em>
field contains attributes used to configure two different controls, the
<span class="emphasis"><em>StickyKeys</em></span>
control (see <a class="link" href="#The_StickyKeys_Control" title="The StickyKeys Control">section 10.6.8</a>) and the
<span class="emphasis"><em>AccessXFeedback</em></span>
control (see <a class="link" href="#The_AccessXFeedback_Control" title="The AccessXFeedback Control">section 10.6.3</a>). The
<em class="structfield"><code>ax_options</code></em>
field is a bitmask and may include any combination of the bits defined in
<a class="link" href="#table10.9" title="Table 10.9. Access X Enable/Disable Bits (ax_options field)">Table 10.9</a>.
</p><div class="table"><a id="table10.9"></a><p class="title"><strong>Table 10.9. Access X Enable/Disable Bits (ax_options field)</strong></p><div class="table-contents"><table class="table" summary="Access X Enable/Disable Bits (ax_options field)" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Access X Control</th><th align="left">ax_options bit</th><th align="left">value</th></tr></thead><tbody><tr><td align="left">AccessXFeedback</td><td align="left"><span class="symbol">XkbAX_SKPressFBMask</span></td><td align="left">(1L&lt;&lt;0)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_SKAcceptFBMask</span></td><td align="left">(1L &lt;&lt; 1)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_FeatureFBMask</span></td><td align="left">(1L &lt;&lt; 2)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_SlowWarnFBMask</span></td><td align="left">(1L &lt;&lt; 3)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_IndicatorFBMask</span></td><td align="left">(1L &lt;&lt; 4)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_StickyKeysFBMask</span></td><td align="left">(1L &lt;&lt; 5)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_SKReleaseFBMask</span></td><td align="left">(1L &lt;&lt; 8)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_SKRejectFBMask</span></td><td align="left">(1L &lt;&lt; 9)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_BKRejectFBMask</span></td><td align="left">(1L &lt;&lt; 10)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_DumbBellFBMask</span></td><td align="left">(1L &lt;&lt; 11)</td></tr><tr><td align="left">StickyKeys</td><td align="left"><span class="symbol">XkbAX_TwoKeysMask</span></td><td align="left">(1L &lt;&lt; 6)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_LatchToLockMask</span></td><td align="left">(1L &lt;&lt; 7)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbAX_AllOptionsMask</span></td><td align="left">(0xFFF)</td></tr></tbody></table></div></div><br class="table-break" /><p>
The fields pertaining to each control are relevant only when the control is
enabled
(<span class="symbol">XkbAccessXFeedbackMask</span>
or
<span class="symbol">XkbStickyKeysMask</span>
bit is turned on in the
<em class="structfield"><code>enabled_ctrls</code></em>
field).
</p><p>
Xkb provides a set of convenience macros for working with the
<em class="structfield"><code>ax_options</code></em>
field of an
<span class="structname">XkbControlsRec</span>
structure:

</p><pre class="programlisting">
#define      <span class="symbol">XkbAX_NeedOption</span>(c,w)      ((c)-&gt;ax_options &amp; (w))
</pre><p>
The
<span class="symbol">XkbAX_NeedOption</span>
macro is useful for determining whether a particular AccessX option is enabled
or not. It accepts a pointer to an
<span class="structname">XkbControlsRec</span>
structure and a valid mask bit from
<a class="link" href="#table10.9" title="Table 10.9. Access X Enable/Disable Bits (ax_options field)">Table 10.9</a>.
If the specified mask bit in the
<em class="structfield"><code>ax_options</code></em>
field of the controls structure is set, the macro returns the mask bit.
Otherwise, it returns zero. Thus,

</p><pre class="programlisting">
    XkbAX_NeedOption(ctlrec, XkbAX_LatchToLockMask)
</pre><p>

is nonzero if the latch to lock transition for latching keys is enabled, and
zero if it is disabled. Note that
<span class="symbol">XkbAX_NeedOption</span>
only determines whether or not the particular capability is configured to
operate; the
<span class="symbol">XkbAccessXFeedbackMask</span>
bit must also be turned on in
<em class="structfield"><code>enabled_ctrls</code></em>
for the capability to actually be functioning.
</p><pre class="programlisting">
#define      <span class="symbol">XkbAX_AnyFeedback</span>(c) \
                 ((c)-&gt;enabled_ctrls &amp; XkbAccessXFeedbackMask)
</pre><p>
The
<span class="symbol">XkbAX_AnyFeedback</span>
macro accepts a pointer to an
<span class="structname">XkbControlsRec</span>
structure and tells whether the
<span class="emphasis"><em>AccessXFeedback</em></span>
control is enabled or not. If the
<span class="emphasis"><em>AccessXFeedback</em></span>
control is enabled, the macro returns
<span class="symbol">XkbAccessXFeedbackMask</span>.
Otherwise, it returns zero.
</p><pre class="programlisting">
#define      <span class="symbol">XkbAX_NeedFeedback</span>(c,w) \
                 (XkbAX_AnyFeedback(c) &amp;&amp; XkbAX_NeedOption(c,w))
</pre><p>
The
<span class="symbol">XkbAX_NeedFeedback</span>
macro is useful for determining if both the
<span class="emphasis"><em>AccessXFeedback</em></span>
control and a particular AccessX feedback option are enabled. The macro
accepts a pointer to an
<span class="structname">XkbControlsRec</span>
structure and a feedback option from the table above. If both the
<span class="emphasis"><em>AccessXFeedback</em></span>
control and the specified feedback option are enabled, the macro returns
<span class="symbol">True</span>.
Otherwise it returns
<span class="symbol">False</span>.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="ax_timeout_axt_opts_mask_axt_opts_values_axt_ctrls_mask_and_axt_ctrls_values"></a>ax_timeout, axt_opts_mask, axt_opts_values, axt_ctrls_mask, and axt_ctrls_values</h4></div></div></div><p>
<em class="structfield"><code>ax_timeout</code></em>,
<em class="structfield"><code>axt_opts_mask</code></em>,
<em class="structfield"><code>axt_opts_values</code></em>,
<em class="structfield"><code>axt_ctrls_mask</code></em>,
and
<em class="structfield"><code>axt_ctrls_values</code></em>
are attributes of the
<span class="emphasis"><em>AccessXTimeout</em></span>
control. Refer to <a class="link" href="#The_AccessXTimeout_Control" title="The AccessXTimeout Control">section 10.6.2</a> for a description of these fields and the
units involved.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="per_key_repeat"></a>per_key_repeat</h4></div></div></div><p>
The
<em class="structfield"><code>per_key_repeat</code></em>
field mirrors the
<em class="structfield"><code>auto_repeats</code></em>
field of the core protocol
<span class="structname">XKeyboardState</span>
structure: changing the
<em class="structfield"><code>auto_repeats</code></em>
field automatically changes
<em class="structfield"><code>per_key_repeat</code></em>
and vice versa. It is provided for convenience and to reduce protocol traffic.
For example, to obtain the individual repeat key behavior as well as the repeat
delay and rate, use
<code class="function">XkbGetControls</code>.
If the
<em class="structfield"><code>per_key_repeat</code></em>
were not in this structure, you would have to call both
<code class="function">XGetKeyboardControl</code>
and
<code class="function">XkbGetControls</code>
to get this information. The bits correspond to keycodes. The first seven keys
(keycodes 1–7) are indicated in
<em class="structfield"><code>per_key_repeat</code></em>[0],
with bit position 0 (low order) corresponding to the fictitious keycode 0.
Following array elements correspond to 8 keycodes per element. A 1 bit
indicates that the key is a repeating key.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Querying_Controls"></a>Querying Controls</h2></div></div></div><p>
Use
<code class="function">XkbGetControls</code>
to find the current state of Xkb server controls.
</p><a id="idm6284" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetControls"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetControls</strong>(</code>Display *<var class="pdparam">display</var>, unsigned long <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of controls requested
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description for controls information
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetControls</code>
queries the server for the requested control information, waits for a reply,
and then copies the server’s values for the requested information into the
<em class="structfield"><code>ctrls</code></em>
structure of the
<em class="parameter"><code>xkb</code></em>
argument. Only those components specified by the
<em class="parameter"><code>which</code></em>
parameter are copied. Valid values for
<em class="parameter"><code>which</code></em>
are any combination of the masks listed in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a> that have <span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="parameter"><code>which</code></em>
column.
</p><p>
If
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>
is
<span class="symbol">NULL</span>,
<code class="function">XkbGetControls</code>
allocates and initializes it before obtaining the values specified by
<em class="parameter"><code>which</code></em>.
If
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>
is not
<span class="symbol">NULL</span>,
<code class="function">XkbGetControls</code>
modifies only those portions of
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>
corresponding to the values specified by
<em class="parameter"><code>which</code></em>.
</p><p>
<code class="function">XkbGetControls</code>
returns
<span class="symbol">Success</span>
if successful; otherwise, it returns
<span class="errorname">BadAlloc</span>
if it cannot obtain sufficient storage,
<span class="errorname">BadMatch</span>
if
<em class="parameter"><code>xkb</code></em>
is
<span class="symbol">NULL</span>
or
<em class="parameter"><code>which</code></em>
is empty, or
<span class="errorname">BadImplementation</span>.
</p><p>
To free the
<em class="structfield"><code>ctrls</code></em>
member of a keyboard description, use
<code class="function">XkbFreeControls</code>
(see <a class="link" href="#Allocating_and_Freeing_an_XkbControlsRec" title="Allocating and Freeing an XkbControlsRec">section 10.12</a>)
</p><p>
The
<em class="structfield"><code>num_groups</code></em>
field in the
<em class="structfield"><code>ctrls</code></em>
structure is always filled in by
<code class="function">XkbGetControls</code>,
regardless of which bits are selected by
<em class="parameter"><code>which</code></em>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Changing_Controls"></a>Changing Controls</h2></div></div></div><p>
There are two ways to make changes to controls: either change a local copy
keyboard description and call
<code class="function">XkbSetControls</code>,
or, to reduce network traffic, use an
<span class="structname">XkbControlsChangesRec</span>
structure and call
<code class="function">XkbChangeControls</code>.
</p><p>
To change the state of one or more controls, first modify the
<em class="structfield"><code>ctrls</code></em>
structure in a local copy of the keyboard description and then use
<code class="function">XkbSetControls</code>
to copy those changes to the X server.
</p><a id="idm6362" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetControls</strong>(</code>Display *<var class="pdparam">display</var>, unsigned long <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of controls to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        <em class="structfield"><code>ctrls</code></em> field contains new values to be set
      </p></td></tr></tbody></table></div><p>
For each bit that is set in the
<em class="parameter"><code>which</code></em>
parameter,
<code class="function">XkbSetControls</code>
sends the corresponding values from the
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>
field to the server. Valid values for
<em class="parameter"><code>which</code></em>
are any combination of the masks listed in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a> that have <span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="parameter"><code>which</code></em>
column.
</p><p>
If
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>
is
<span class="symbol">NULL</span>,
the server does not support a compatible version of Xkb, or the Xkb extension
has not been properly initialized,
<code class="function">XkbSetControls</code>
returns
<span class="symbol">False</span>.
Otherwise, it sends the request to the X server and returns
<span class="symbol">True</span>.
</p><p>
Note that changes to attributes of controls in the
<span class="structname">XkbControlsRec</span>
structure are apparent only when the associated control is enabled, although
the corresponding values are still updated in the X server. For example, the
<em class="structfield"><code>repeat_delay</code></em>
and
<em class="structfield"><code>repeat_interval</code></em>
fields are ignored unless the
<span class="emphasis"><em>RepeatKeys</em></span>
control is enabled (that is, the X server’s equivalent of
<em class="structfield"><code>xkb-&gt;ctrls</code></em>
has
<span class="symbol">XkbRepeatKeysMask</span>
set in
<em class="structfield"><code>enabled_ctrls</code></em>).
It is permissible to modify the attributes of a control in one call to
XkbSetControls and enable the control in a subsequent call. See <a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>
for more information on enabling and disabling controls.
</p><p>
Note that the
<em class="structfield"><code>enabled_ctrls</code></em>
field is itself a control — the
<span class="emphasis"><em>EnabledControls</em></span>
control. As such, to set a specific configuration of enabled and disabled
boolean controls, you must set
<em class="structfield"><code>enabled_ctrls</code></em>
to the appropriate bits to enable only the controls you want and disable all
others, then specify the
<span class="symbol">XkbControlsEnabledMask</span>
in a call to
<code class="function">XkbSetControls</code>.
Because this is somewhat awkward if all you want to do is enable and disable
controls, and not modify any of their attributes, a convenience function is
also provided for this purpose
(<code class="function">XkbChangeEnabledControls</code>,
<a class="link" href="#The_EnabledControls_Control" title="The EnabledControls Control">section 10.1.1</a>).
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_XkbControlsChangesRec_Structure"></a>The XkbControlsChangesRec Structure</h3></div></div></div><a id="idm6427" class="indexterm"></a><p>
The
<span class="structname">XkbControlsChangesRec</span>
structure allows applications to track modifications to an
<span class="structname">XkbControlsRec</span>
structure and thereby reduce the amount of traffic sent to the server. The
same
<span class="structname">XkbControlsChangesRec</span>
structure may be used in several successive modifications to the same
<span class="structname">XkbControlsRec</span>
structure, then subsequently used to cause all of the changes, and only the
changes, to be propagated to the server. The
<span class="structname">XkbControlsChangesRec</span>
structure is defined as follows:

</p><pre class="programlisting">
typedef struct _XkbControlsChanges {
    unsigned int changed_ctrls;          /* bits indicating changed
                                             control data */
    unsigned int enabled_ctrls_changes;  /* bits indicating
                                             enabled/disabled controls */
    Bool         num_groups_changed;     /* <span class="symbol">True</span> if number of keyboard
                                             groups changed */
} <span class="structname">XkbControlsChangesRec</span>, *XkbControlsChangesPtr;
</pre><p>
The
<em class="structfield"><code>changed_ctrls</code></em>
field is a mask specifying which logical sets of data in the controls
structure have been modified. In this context, modified means
<span class="emphasis"><em>set</em></span>,
that is, if a value is set to the same value it previously contained, it has
still been modified, and is noted as changed. Valid values for
<em class="structfield"><code>changed_ctrls</code></em>
are any combination of the masks listed in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a> that have <span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="structfield"><code>changed_ctrls</code></em>
column. Setting a bit implies the corresponding data fields from the
<span class="quote">“<span class="quote">Relevant XkbControlsRec Data Fields</span>”</span> column in
<a class="link" href="#table10.6" title="Table 10.6. Xkb Controls">Table 10.6</a> have been modified. The
<em class="structfield"><code>enabled_ctrls_changes</code></em>
field specifies which bits in the
<em class="structfield"><code>enabled_ctrls</code></em>
field have changed. If the number of keyboard groups has changed, the
<em class="structfield"><code>num_groups_changed</code></em>
field is set to <span class="symbol">True</span>.
</p><p>
If you have an Xkb description with controls that have been modified and an
<span class="structname">XkbControlsChangesRec</span>
that describes the changes that have been made, the
<code class="function">XkbChangeControls</code>
function provides a flexible method for updating the controls in a server to
match those in the changed keyboard description.
</p><a id="idm6455" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbChangeControls</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbControlsChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description with changed <em class="structfield"><code>xkb-&gt;ctrls</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        which parts of <em class="structfield"><code>xkb-&gt;ctrls</code></em> have changed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbChangeControls</code>
copies any controls fields specified by
<em class="parameter"><code>changes</code></em>
from the keyboard description controls structure,
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>,
to the server specified by
<em class="parameter"><code>dpy</code></em>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Changes_to_Keyboard_Controls"></a>Tracking Changes to Keyboard Controls</h2></div></div></div><a id="idm6494" class="indexterm"></a><a id="idm6498" class="indexterm"></a><p>
Whenever a field in the controls structure changes in the server’s keyboard
description, the server sends an
<span class="symbol">XkbControlsNotify</span>
event to all interested clients.To receive
<span class="symbol">XkbControlsNotify</span>
events under all possible conditions, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) and pass
<span class="symbol">XkbControlsNotifyMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
To receive
<span class="symbol">XkbControlsNotify</span>
events only under certain conditions, use
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbControlsNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying the desired state changes in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
using mask bits from <a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>.
</p><p>
The structure for the
<span class="symbol">XkbControlsNotify</span>
event is defined as follows:

</p><pre class="programlisting">
typedef struct {
    int            type;          /* Xkb extension base event code */
    unsigned long  serial;        /* X server serial number for event */
    Bool           send_event;    /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;       /* server connection where event generated */
    Time           time;          /* server time when event generated */
    int            xkb_type;      /* <span class="symbol">XkbCompatMapNotify</span> */
    int            device;        /* Xkb device ID,
                                     will not be <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int   changed_ctrls; /* bits indicating which controls
                                     data have changed */
    unsigned int   enabled_ctrls; /* controls currently enabled in server */
    unsigned int   enabled_ctrl_changes;  /* bits indicating
                                             enabled/disabled controls */
    int            num_groups;    /* current number of keyboard groups */
    KeyCode        keycode;       /* != 0 ⇒ keycode of key causing change */
    char           event_type;    /* Type of event causing change */
    char           req_major;     /* major event code of event causing change */
    char           req_minor;     /* minor event code of event causing change */
} <span class="structname">XkbControlsNotifyEvent</span>;
</pre><p>
The
<em class="structfield"><code>changed_ctrls</code></em>
field specifies the controls components that have changed and consists of bits
taken from the masks defined in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a> with <span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="structfield"><code>changed_ctrls</code></em>
column.
</p><p>
The controls currently enabled in the server are reported in the
<em class="structfield"><code>enabled_ctrls</code></em>
field. If any controls were just enabled or disabled (that is, the contents of
the
<em class="structfield"><code>enabled_ctrls</code></em>
field changed), they are flagged in the
<em class="structfield"><code>enabled_ctrl_changes</code></em>
field. The valid bits for these fields are the masks listed in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a> with
<span class="quote">“<span class="quote">ok</span>”</span> in the
<em class="structfield"><code>enabled_ctrls</code></em>
column. The
<em class="structfield"><code>num_groups</code></em>
field reports the number of groups bound to the key belonging to the most
number of groups and is automatically updated when the keyboard mapping changes.
</p><p>
If the change was caused by a request from a client, the
<em class="structfield"><code>keycode</code></em>
and
<em class="structfield"><code>event_type</code></em>
fields are set to
<span class="emphasis"><em>zero</em></span>
and the
<em class="structfield"><code>req_major</code></em>
and
<em class="structfield"><code>req_minor</code></em>
fields identify the request. The
<em class="structfield"><code>req_major</code></em>
value is the same as the major extension opcode. Otherwise,
<em class="structfield"><code>event_type</code></em>
is set to the type of event that caused the change (one of
<span class="symbol">KeyPress</span>,
<span class="symbol">KeyRelease</span>,
<span class="symbol">DeviceKeyPress</span>,
<span class="symbol">DeviceKeyRelease</span>,
<span class="symbol">ButtonPress</span>
or
<span class="symbol">ButtonRelease</span>),
and
<em class="structfield"><code>req_major</code></em>
and
<em class="structfield"><code>req_minor</code></em>
are undefined. If
<em class="structfield"><code>event_type</code></em>
is
<span class="symbol">KeyPress</span>,
<span class="symbol">KeyRelease</span>,
<span class="symbol">DeviceKeyPress</span>,
or
<span class="symbol">DeviceKeyRelease</span>,
the
<em class="structfield"><code>keycode</code></em>
field is set to the key that caused the change. If
<em class="structfield"><code>event_type</code></em>
is
<span class="symbol">ButtonPress</span>
or
<span class="symbol">ButtonRelease</span>,
<em class="structfield"><code>keycode</code></em>
contains the button number.
</p><p>
When a client receives an
<span class="symbol">XkbControlsNotify</span>
event, it can note the changes in a changes structure using
<code class="function">XkbNoteControlsChanges</code>.
</p><a id="idm6566" class="indexterm"></a><div class="funcsynopsis"><a id="XkbNoteControlsChanges"></a><p><code class="funcdef">void <strong class="fsfunc">XkbNoteControlsChanges</strong>(</code>XkbControlsChangesPtr <var class="pdparam">changes</var>, XkbControlsNotifyEvent *<var class="pdparam">new</var>, unsigned int <var class="pdparam">wanted</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        records changes indicated by new
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new</code></em>
    </span></p></td><td><p>
        tells which things have changed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>wanted</code></em>
    </span></p></td><td><p>
        tells which parts of new to record in changes
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>wanted</code></em>
parameter is a bitwise inclusive OR of bits taken from the set of masks
specified in <a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a> with <span class="quote">“<span class="quote">ok</span>”</span>
in the
<em class="structfield"><code>changed_ctrls</code></em>
column.
<code class="function">XkbNoteControlsChanges</code>
copies any changes reported in
<em class="parameter"><code>new</code></em>
and specified in
<em class="parameter"><code>wanted</code></em>
into the changes record specified by
<em class="parameter"><code>changes</code></em>.
</p><p>
Use
<code class="function">XkbGetControlsChanges</code>
to update a local copy of a keyboard description with the changes previously
noted by one or more calls to
<code class="function">XkbNoteControlsChanges</code>.
</p><a id="idm6607" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetControlsChanges"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetControlsChanges</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbNameChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        <em class="structfield"><code>xkb-&gt;ctrls</code></em> will be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        indicates which parts of <em class="structfield"><code>xkb-&gt;ctrls</code></em> to update
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetControlsChanges</code>
examines the
<em class="parameter"><code>changes</code></em>
parameter, queries the server for the necessary information, and copies the
results into the
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>ctrls</code></em>
keyboard description. If the
<em class="structfield"><code>ctrls</code></em>
field of
<em class="parameter"><code>xkb</code></em>
is
<span class="symbol">NULL</span>,
<code class="function">XkbGetControlsChanges</code>
allocates and initializes it. To free the
<em class="structfield"><code>ctrls</code></em>
field, use
<code class="function">XkbFreeControls</code>
(see <a class="link" href="#Allocating_and_Freeing_an_XkbControlsRec" title="Allocating and Freeing an XkbControlsRec">section 10.12</a>).
</p><p>
<code class="function">XkbGetControlsChanges</code>
returns
<span class="symbol">Success</span>
if successful and can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadImplementation</span>,
and
<span class="errorname">BadMatch</span>
errors.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_an_XkbControlsRec"></a>Allocating and Freeing an XkbControlsRec</h2></div></div></div><p>
The need to allocate an
<span class="structname">XkbControlsRec</span>
structure seldom arises; Xkb creates one when an application calls
<code class="function">XkbGetControls</code>
or a related function. For those situations where there is not an
<span class="structname">XkbControlsRec</span>
structure allocated in the
<span class="structname">XkbDescRec</span>,
allocate one by calling
<code class="function">XkbAllocControls</code>.
</p><a id="idm6664" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocControls"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocControls</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description in which to allocate ctrls rec
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of components of <em class="structfield"><code>ctrls</code></em> to allocate
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocControls</code>
allocates the
<em class="structfield"><code>ctrls</code></em>
field of the
<em class="parameter"><code>xkb</code></em>
parameter, initializes all fields to zero, and returns
<span class="symbol">Success</span>.
If the
<em class="structfield"><code>ctrls</code></em>
field is not
<span class="symbol">NULL</span>,
<code class="function">XkbAllocControls</code>
simply returns
<span class="symbol">Success</span>.
If
<em class="parameter"><code>xkb</code></em>
is
<span class="symbol">NULL</span>,
<code class="function">XkbAllocControls</code>
reports a
<span class="errorname">BadMatch</span>
error. If the
<em class="structfield"><code>ctrls</code></em>
field could not be allocated, it reports a
<span class="errorname">BadAlloc</span>
error.
</p><p>
The
<em class="parameter"><code>which</code></em>
mask specifies the individual fields of the
<em class="structfield"><code>ctrls</code></em>
structure to be allocated and can contain any of the valid masks defined in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>.
Because none of the currently existing controls have any structures
associated with them, which is currently of little practical value in this call.
</p><p>
To free memory used by the
<em class="structfield"><code>ctrls</code></em>
member of an
<span class="structname">XkbDescRec</span>
structure, use
<code class="function">XkbFreeControls</code>:
</p><a id="idm6710" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeControls"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeControls</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description in which to free controls components
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of components of <em class="structfield"><code>ctrls</code></em> to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ free everything + ctrls itself
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbFreeControls</code>
frees the specified components of the
<em class="structfield"><code>ctrls</code></em>
field in the
<em class="parameter"><code>xkb</code></em>
keyboard description and sets the corresponding structure component values to
<span class="symbol">NULL</span>
or
<span class="emphasis"><em>zero</em></span>.
The
<em class="parameter"><code>which</code></em>
mask specifies the fields of
<em class="structfield"><code>ctrls</code></em>
to be freed and can contain any of the controls components specified in
<a class="link" href="#table10.7" title="Table 10.7. Controls Mask Bits">Table 10.7</a>.
</p><p>
If
<em class="parameter"><code>free_all</code></em>
is
<span class="symbol">True</span>,
<code class="function">XkbFreeControls</code>
frees every non-
<span class="symbol">NULL</span>
structure component in the controls, frees the
<span class="structname">XkbControlsRec</span>
structure referenced by the
<em class="structfield"><code>ctrls</code></em>
member of
<em class="parameter"><code>xkb</code></em>,
and sets
<em class="structfield"><code>ctrls</code></em>
to
<span class="symbol">NULL</span>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_Miscellaneous_Per_client_Controls"></a>The Miscellaneous Per-client Controls</h2></div></div></div><p>
You can configure the boolean per-client controls which affect the state
reported in button and key events. See
<span class="olink">section 12.1.1</span>,
<span class="olink">12.3</span>,
<span class="olink">12.5</span>,
and
<span class="olink">16.3.11</span>
of the
<span class="olink"><em class="citetitle">XKB Protocol specification</em></span>
for more details.
</p><p>
To get the current values of the
<span class="emphasis"><em>per-client</em></span>
controls, use
<code class="function">XkbGetPerClientControls</code>.
</p><a id="idm6772" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetPerClientControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbGetPerClientControls</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int *<var class="pdparam">ctrls</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls</code></em>
    </span></p></td><td><p>
        1 bit ⇒ corresponding control is on
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetPerClientControls</code>
backfills
<em class="parameter"><code>ctrls</code></em>
with the
<span class="emphasis"><em>per-client</em></span>
control attributes for this particular client. It returns
<span class="symbol">True</span>
if successful, and
<span class="symbol">False</span>
otherwise.
</p><p>
To change the current values of the
<span class="emphasis"><em>per-client</em></span>
control attributes, use
<code class="function">XkbSetPerClientControls</code>.
</p><a id="idm6803" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetPerClientControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetPerClientControls</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">change</var>, unsigned int *<var class="pdparam">value</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>change</code></em>
    </span></p></td><td><p>
        1 bit ⇒ change control
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>value</code></em>
    </span></p></td><td><p>
        1 bit ⇒ control on
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetPerClientControls</code>
changes the per-client values for the controls selected by
<em class="parameter"><code>change</code></em> to the corresponding value in
<em class="parameter"><code>value</code></em>. Legal values for
<em class="parameter"><code>change</code></em> and <em class="parameter"><code>value</code></em>
are: XkbPCF_GrabsUseXKBStateMask, XkbPCF_LookupStateWhenGrabbed, and
XkbPCF_SendEventUsesXKBState. More than one control may be changed at one time
by OR-ing the values together. XkbSetPerClientControls backfills value with the
<span class="emphasis"><em>per-client</em></span>
control attributes for this particular client.
It returns
<span class="symbol">True</span>
if successful, and
<span class="symbol">False</span>
otherwise.
</p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm4594" class="footnote"><p><a href="#idm4594" class="para"><sup class="para">[4] </sup></a>
AccessDOS provides access to the DOS operating system for people with physical
impairments and was developed by the Trace R&amp;D Center at the University of
Wisconsin. For more information on AccessDOS, contact the Trace R&amp;D Center,
Waisman Center and Department of Industrial Engineering, University of
Wisconsin-Madison WI 53705-2280. Phone: 608-262-6966. e-mail: info@trace.wisc.edu.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="X_Library_Controls"></a>Chapter 11. X Library Controls</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Controls_Affecting_Keycode_to_String_Translation">Controls Affecting Keycode-to-String Translation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ForceLatin1Lookup">ForceLatin1Lookup</a></span></dt><dt><span class="sect2"><a href="#ConsumeLookupMods">ConsumeLookupMods</a></span></dt><dt><span class="sect2"><a href="#AlwaysConsumeShiftAndLock">AlwaysConsumeShiftAndLock</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_Affecting_Compose_Processing">Controls Affecting Compose Processing</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ConsumeKeysOnComposeFail">ConsumeKeysOnComposeFail</a></span></dt><dt><span class="sect2"><a href="#ComposeLED">ComposeLED</a></span></dt><dt><span class="sect2"><a href="#BeepOnComposeFail">BeepOnComposeFail</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Controls_Effecting_Event_Delivery">Controls Effecting Event Delivery</a></span></dt><dd><dl><dt><span class="sect2"><a href="#IgnoreNewKeyboards">IgnoreNewKeyboards</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Manipulating_the_Library_Controls">Manipulating the Library Controls</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Determining_Which_Library_Controls_are_Implemented">Determining Which Library Controls are Implemented</a></span></dt><dt><span class="sect2"><a href="#Determining_the_State_of_the_Library_Controls">Determining the State of the Library Controls</a></span></dt><dt><span class="sect2"><a href="#Changing_the_State_of_the_Library_Controls">Changing the State of the Library Controls</a></span></dt></dl></dd></dl></div><p>
The Xkb extension is composed of two parts: a server extension, and a
client-side X library extension. <a class="xref" href="#Keyboard_Controls" title="Chapter 10. Keyboard Controls">Chapter 10, <em>Keyboard Controls</em></a> discusses functions used to modify
controls affecting the behavior of the server portion of the Xkb extension.
This chapter discusses functions used to modify controls that affect only the
behavior of the client portion of the extension; these controls are known as
<em class="firstterm">Library Controls</em>.
<a id="idm6846" class="indexterm"></a>
<a id="idm6848" class="indexterm"></a>
</p><p>
All of the Library Controls are boolean flags that may be enabled and disabled.
The controls can be divided into several categories:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Controls affecting general string lookups
  </p></li><li class="listitem"><p>
Controls affecting compose processing
  </p></li><li class="listitem"><p>
Controls affecting event delivery
  </p></li></ul></div><p>
There are two types of string lookups performed by
<code class="function">XLookupString</code>.
<a id="idm6861" class="indexterm"></a>
The first type involves translating a single keycode into a string; the
controls in the first category affect this type of lookup. The second type
involves translating a series of keysyms into a string; the controls in the
second category affect this type of lookup.
</p><p>
An Xkb implementation is required to support the programming interface for all
of the controls. However, an implementation may choose not to support the
semantics associated with the controls that deal with compose processing. In
this case, a program that accesses these controls should still function
normally; however, the feedback that would normally occur with the controls
enabled may be missing.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_Affecting_Keycode_to_String_Translation"></a>Controls Affecting Keycode-to-String Translation</h2></div></div></div><p>
The first type of string lookups, which are here called
<em class="firstterm">simple string lookups</em>,
involves translating a single keycode into a string. Because these simple
lookups involve only a single keycode, all of the information needed to do the
translation is contained in the keyboard state in a single event. The controls
affecting simple string lookups are:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="emphasis"><em>ForceLatin1Lookup</em></span></td></tr><tr><td><span class="emphasis"><em>ConsumeLookupMods</em></span></td></tr><tr><td><span class="emphasis"><em>LevelOneUsesShiftAndLock</em></span></td></tr></table><p>
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="ForceLatin1Lookup"></a>ForceLatin1Lookup</h3></div></div></div><p>
If the
<span class="emphasis"><em>ForceLatin1Lookup</em></span>
control is enabled,
<code class="function">XLookupString</code>
only returns strings using the Latin1 character set. If
<span class="emphasis"><em>ForceLatin1Lookup</em></span>
is not enabled,
<code class="function">XLookupString</code>
can return characters that are not in the Latin1 set. By default, this control
is disabled, allowing characters outside of the Latin1 set to be returned.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="ConsumeLookupMods"></a>ConsumeLookupMods</h3></div></div></div><p>
Simple string lookups in
<code class="function">XLookupString</code>
involve two different translation phases. The first phase translates raw
device keycodes to individual keysyms. The second phase attempts to map the
resulting keysym into a string of one or more characters. In the first phase,
some of the modifiers are normally used to determine the appropriate shift
level for a key.
</p><p>
The
<span class="emphasis"><em>ConsumeLookupMods</em></span>
control determines whether or not
<code class="function">XLookupString</code>
<span class="emphasis"><em>consumes</em></span>
the modifiers it uses during the first phase of processing (mapping a keycode
to a keysym). When a modifier is consumed, it is effectively removed from the
working copy of the keyboard state information
<code class="function">XLookupString</code>
is using and appears to be unset for the remainder of the processing.
</p><p>
If the
<span class="emphasis"><em>ConsumeLookupMods</em></span>
control is enabled,
<code class="function">XLookupString</code>
does not use the modifiers used to translate the keycode of the event to a
keysym when it is determining the string associated with a keysym. For example,
assume the keymap for the ‘A’ key only contains the shift modifier and the
<span class="emphasis"><em>ConsumeLookupMods</em></span>
control is enabled. If a user presses the
<span class="keycap"><strong>Shift</strong></span>
key and the
<span class="keycap"><strong>A</strong></span>
key while the
<span class="keycap"><strong>Num_Lock</strong></span>
key is locked,
<code class="function">XLookupString</code>
uses the
<span class="symbol">Shift</span>
modifier when mapping the keycode for the ‘a’ key to the keysym for
‘A’; subsequently, it only uses the
<span class="emphasis"><em>NumLock</em></span>
modifier when determining the string associated with the keysym ‘A’.
</p><p>
If the
<span class="emphasis"><em>ConsumeLookupMods</em></span>
control is not enabled,
<code class="function">XLookupString</code>
uses all of the event modifiers to determine the string associated with a
keysym. This behavior mirrors the behavior of
<code class="function">XLookupString</code>
in the core implementation.
</p><p>
The
<span class="emphasis"><em>ConsumeLookupMods</em></span>
control is unset by default. For more information on modifier consumption,
refer to <a class="xref" href="#Interpreting_Key_Events" title="Chapter 12. Interpreting Key Events">Chapter 12, <em>Interpreting Key Events</em></a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="AlwaysConsumeShiftAndLock"></a>AlwaysConsumeShiftAndLock</h3></div></div></div><p>
The
<span class="emphasis"><em>AlwaysConsumeShiftAndLock</em></span>
control, if enabled, forces
<code class="function">XLookupString</code>
to consume the
<span class="symbol">Shift</span>
and
<span class="symbol">Lock</span>
modifiers when processing all keys, even if the definition for the key type
does not specify these modifiers. The
<span class="emphasis"><em>AlwaysConsumeShiftAndLock</em></span>
control is unset by default. See <a class="link" href="#Key_Types" title="Key Types">section 15.2</a> for a discussion of key types.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_Affecting_Compose_Processing"></a>Controls Affecting Compose Processing</h2></div></div></div><p>
The second type of string lookup performed by
<code class="function">XLookupString</code>
involves translating a series of keysyms into a string. Because these lookups
can involve more than one key event, they require
<code class="function">XLookupString</code>
to retain some state information between successive calls. The process of
mapping a series of keysyms to a string is known as
<em class="firstterm">compose processing</em>.
<a id="idm6924" class="indexterm"></a>
The controls affecting compose processing are:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="emphasis"><em>ConsumeKeysOnComposeFail</em></span></td></tr><tr><td><span class="emphasis"><em>ComposeLED</em></span></td></tr><tr><td><span class="emphasis"><em>BeepOnComposeFail</em></span></td></tr></table><p>
</p><p>
Because different vendors have historically used different algorithms to
implement compose processing, and these algorithms may be incompatible with the
semantics required by the Xkb compose processing controls, implementation of
the compose processing controls is optional in an Xkb implementation.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="ConsumeKeysOnComposeFail"></a>ConsumeKeysOnComposeFail</h3></div></div></div><p>
Some compose processing algorithms signal the start of a compose sequence by a
key event meaning <span class="quote">“<span class="quote">start compose</span>”</span>.
<a href="#ftn.idm6938" class="footnote" id="idm6938"><sup class="footnote">[5]</sup></a>
The subsequent key events should normally result in a valid composition yielding a
valid translation to a string. If the subsequent key events do not have a valid
translation, some decision must be made about what to do with the key events
that were processed while attempting the compose. The
<span class="emphasis"><em>ConsumeKeysOnComposeFail</em></span>
control allows a client to specify what happens with the key events
<code class="function">XLookupString</code>
has been considering when it reaches a dead end in a compose sequence.
</p><p>
If the
<span class="emphasis"><em>ConsumeKeysOnComposeFail</em></span>
control is set, all keys associated with a failed compose sequence should be
consumed (discarded). If the
<span class="emphasis"><em>ConsumeKeysOnComposeFail</em></span>
control is not set, the key events associated with a failed compose sequence
should be processed as a normal sequence of key events.
</p><p>
The
<span class="emphasis"><em>ConsumeKeysOnComposeFail</em></span>
control is disabled by default.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="ComposeLED"></a>ComposeLED</h3></div></div></div><p>
The
<span class="emphasis"><em>ComposeLED</em></span>
control allows a client to specify whether or not an indicator should be set
and cleared to provide feedback when compose processing is in progress. The
control does not specify which indicator should be used; the mapping for this
is up to the individual implementation. If the
<span class="emphasis"><em>ComposeLED</em></span>
control is enabled, it specifies that an indicator should be set when a
compose sequence is in progress and cleared when one is not in progress. The
<span class="emphasis"><em>ComposeLED</em></span>
control is disabled by default.
</p><p>
While the Xkb extension does not specify the type of type of indicator to be
used when the
<span class="emphasis"><em>ComposeLED</em></span>
control is implemented, a consistent convention between implementations is to
everyone’s benefit. If a named indicator is used for this purpose, the
recommended name is “<code class="literal">Compose</code>”.
Note that some implementations may use an unnamed, custom hardware LED for
this purpose.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="BeepOnComposeFail"></a>BeepOnComposeFail</h3></div></div></div><p>
The
<span class="emphasis"><em>BeepOnComposeFail</em></span>
control allows a client to specify whether or not a bell should be activated
to provide feedback when a compose sequence fails. The control does not specify
the type of bell that should be used; the mapping for this is up to the
individual implementation. If the
<span class="emphasis"><em>BeepOnComposeFail</em></span>
control is enabled, it specifies that a bell should be activated when a
compose sequence fails. The
<span class="emphasis"><em>BeepOnComposeFail</em></span>
control is disabled by default. If implemented, the bell should be activated
using
<code class="function">XkbBell</code>
or
<code class="function">XkbDeviceBell</code>.
</p><p>
While the Xkb extension does not specify the type of bell to be used when the
<span class="emphasis"><em>BeepOnComposeFail</em></span>
control is implemented, a consistent convention between implementations is to
everyone’s benefit. If a named bell is used for this purpose, the recommended
name is “<code class="literal">ComposeFail</code>”.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Controls_Effecting_Event_Delivery"></a>Controls Effecting Event Delivery</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="IgnoreNewKeyboards"></a>IgnoreNewKeyboards</h3></div></div></div><a id="idm6971" class="indexterm"></a><a id="idm6975" class="indexterm"></a><p>
When Xkb is initialized, it implicitly forces requests for
<span class="symbol">NewKeyboardNotify</span>
events. These events may be used by the Xkb library extension internally; they
are normally translated into core protocol
<span class="symbol">MappingNotify</span>
events before being passed to the client. While delivering the event to the
client is appropriate in most cases, it is not appropriate for some clients
that maintain per-key data structures. This is because once the server has sent
a
<span class="symbol">NewKeyboardNotify</span>
event, it is free to send the client events for all keys in the new range and
that range may be outside of the per-key data structures the client is
maintaining.
</p><p>
The
<span class="emphasis"><em>IgnoreNewKeyboards</em></span>
control, if enabled, prevents Xkb from mapping
<span class="symbol">NewKeyboardNotify</span>
events to core
<span class="symbol">MappingNotify</span>
events and passing them to the client. The control is initially disabled.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Manipulating_the_Library_Controls"></a>Manipulating the Library Controls</h2></div></div></div><p>
The Library Controls are manipulated using functions that deal with bitmasks to
indicate which controls to manipulate. The controls are identified by the masks
defined in <a class="link" href="#table11.1" title="Table 11.1. Library Control Masks">Table 11.1</a>.
</p><div class="table"><a id="table11.1"></a><p class="title"><strong>Table 11.1. Library Control Masks</strong></p><div class="table-contents"><table class="table" summary="Library Control Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Library Control Mask</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbLC_ForceLatin1Lookup</span></td><td align="left">(1 &lt;&lt; 0)</td></tr><tr><td align="left"><span class="symbol">XkbLC_ConsumeLookupMods</span></td><td align="left">(1 &lt;&lt; 1)</td></tr><tr><td align="left"><span class="symbol">XkbLC_AlwaysConsumeShiftAndLock</span></td><td align="left">(1 &lt;&lt; 2)</td></tr><tr><td align="left"><span class="symbol">XkbLC_IgnoreNewKeyboards</span></td><td align="left">(1 &lt;&lt; 3)</td></tr><tr><td align="left"><span class="symbol">XkbLC_ConsumeKeysOnComposeFail</span></td><td align="left">(1 &lt;&lt; 29)</td></tr><tr><td align="left"><span class="symbol">XkbLC_ComposeLED</span></td><td align="left">(1 &lt;&lt; 30)</td></tr><tr><td align="left"><span class="symbol">XkbLC_BeepOnComposeFail</span></td><td align="left">(1 &lt;&lt; 31)</td></tr><tr><td align="left"><span class="symbol">XkbLC_AllControls</span></td><td align="left">(0xc0000007)</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Determining_Which_Library_Controls_are_Implemented"></a>Determining Which Library Controls are Implemented</h3></div></div></div><p>
To determine which Library Controls are actually
implemented, use <code class="function">XkbXlibControlsImplemented</code>.
</p><a id="idm7037" class="indexterm"></a><div class="funcsynopsis"><a id="XkbXlibControlsImplemented"></a><p><code class="funcdef">unsigned int <strong class="fsfunc">XkbXlibControlsImplemented</strong>(</code>Display *<var class="pdparam">display</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbXlibControlsImplemented</code>
returns a bitmask indicating the controls actually implemented in the Xkb
library and is composed of an inclusive OR of bits from
<a class="link" href="#table11.1" title="Table 11.1. Library Control Masks">Table 11.1</a>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Determining_the_State_of_the_Library_Controls"></a>Determining the State of the Library Controls</h3></div></div></div><p>
To determine the current state of the Library Controls, use
<code class="function">XkbGetXlibControls</code>.
</p><a id="idm7059" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetXlibControls"></a><p><code class="funcdef">unsigned int <strong class="fsfunc">XkbGetXlibControls</strong>(</code>Display *<var class="pdparam">display</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetXlibControls</code>
returns the current state of the Library Controls as a bit mask that is an
inclusive OR of the control masks from
<a class="link" href="#table11.1" title="Table 11.1. Library Control Masks">Table 11.1</a> for the controls that are
enabled. For the optional compose processing controls, the fact that a control
is enabled does not imply that it is actually implemented.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_the_State_of_the_Library_Controls"></a>Changing the State of the Library Controls</h3></div></div></div><p>
To change the state of the Library Controls, use
<code class="function">XkbSetXlibControls</code>.
</p><a id="idm7081" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetXlibControls"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetXlibControls</strong>(</code>Display *<var class="pdparam">display</var>, unsigned long <var class="pdparam">bits_to_change</var>, unsigned long <var class="pdparam">values_for_bits</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bits_to_change</code></em>
    </span></p></td><td><p>
        selects controls to be modified
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>values_for_bits</code></em>
    </span></p></td><td><p>
        turns selected controls on (1) or off (0)
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetXlibControls</code>
modifies the state of the controls selected by
<em class="parameter"><code>bits_to_change</code></em>;
only the controls selected by
<em class="parameter"><code>bits_to_change</code></em>
are modified. If the bit corresponding to a control is on in
<em class="parameter"><code>bits_to_change</code></em>
and also on in values_for_bits, the control is enabled. If the bit
corresponding to a control is on in
<em class="parameter"><code>bits_to_change</code></em>
but off in
<em class="parameter"><code>values_for_bits</code></em>,
the control is disabled.
<em class="parameter"><code>bits_to_change</code></em>
should be an inclusive OR of bits from
<a class="link" href="#table11.1" title="Table 11.1. Library Control Masks">Table 11.1</a>.
</p></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm6938" class="footnote"><p><a href="#idm6938" class="para"><sup class="para">[5] </sup></a>
Another possibility is to have the compose processing simply be the result of a finite state acceptor; a compose sequence would never fail for a properly written finite state acceptor.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Interpreting_Key_Events"></a>Chapter 12. Interpreting Key Events</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Effects_of_Xkb_on_the_Core_X_Library">Effects of Xkb on the Core X Library</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Effects_of_Xkb_on_Event_State">Effects of Xkb on Event State</a></span></dt><dt><span class="sect2"><a href="#Effects_of_Xkb_on_MappingNotify_Events">Effects of Xkb on MappingNotify Events</a></span></dt><dt><span class="sect2"><a href="#X_Library_Functions_Affected_by_Xkb">X Library Functions Affected by Xkb</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Xkb_Event_and_Keymap_Functions">Xkb Event and Keymap Functions</a></span></dt></dl></div><p>
Xkb provides functions to help developers interpret key events without having
to directly interpret Xkb data structures. Xkb also modifies the behavior of
several core X library functions.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Effects_of_Xkb_on_the_Core_X_Library"></a>Effects of Xkb on the Core X Library</h2></div></div></div><p>
When support for Xkb is built into the X library, the
<code class="function">XOpenDisplay</code>
function looks for a compatible version of Xkb on the server. If it finds a
compatible version, it initializes the extension and enables
<em class="firstterm">implicit support</em>
for Xkb in a number of X library functions. This makes it possible for clients
to take advantage of nearly all Xkb features without having to be rewritten or
even recompiled, if they are built with shared libraries. This implicit support
is invisible to most clients, but it can have side effects, so the extension
includes ways to control or disable it.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Effects_of_Xkb_on_Event_State"></a>Effects of Xkb on Event State</h3></div></div></div><p>
Because
<code class="function">XOpenDisplay</code>
initializes Xkb, some events contain an Xkb description of the keyboard state
instead of that normally used by the core protocol. See <a class="link" href="#Xkb_State_to_Core_Protocol_State_Transformation" title="Xkb State to Core Protocol State Transformation">section 17.1.1</a> for more
information about the differences between Xkb keyboard state and that reported
by the core protocol.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Effects_of_Xkb_on_MappingNotify_Events"></a>Effects of Xkb on MappingNotify Events</h3></div></div></div><a id="idm7134" class="indexterm"></a><p>
When Xkb is missing or disabled, the X library tracks changes to the keyboard
mapping using
<span class="symbol">MappingNotify</span>
events. Whenever the keyboard mapping is changed, the server sends all clients
a
<span class="symbol">MappingNotify</span>
event to report the change. When a client receives a
<span class="symbol">MappingNotify</span>
event, it is supposed to call
<code class="function">XRefreshKeyboardMapping</code>
to update the keyboard description used internally by the X library.
</p><p>
The X Keyboard Extension uses
<span class="symbol">XkbMapNotify</span>
and
<span class="symbol">XkbNewKeyboardNotify</span>
events to track changes to the keyboard mapping. When an Xkb-aware client
receives either event, it should call
<code class="function">XkbRefreshKeyboardMapping</code>
to update the keyboard description used internally by the X library. To avoid
duplicate events, the X server does not send core protocol
<span class="symbol">MappingNotify</span>
events to a client that has selected for
<span class="symbol">XkbMapNotify</span>
events.
</p><p>
The implicit support for Xkb selects for
<span class="symbol">XkbMapNotify</span>
events. This means that clients that do not explicitly use Xkb but that are
using a version of the X library that has implicit support for Xkb do not
receive
<span class="symbol">MappingNotify</span>
events over the wire. Clients that were not written with Xkb in mind do not
recognize or properly handle the new Xkb events, so the implicit support
converts them to
<span class="symbol">MappingNotify</span>
events that report approximately the same information, unless the client has
explicitly selected for the Xkb version of the event.
</p><p>
An Xkb-capable X server does not send events from keys that fall outside the
legal range of keycodes expected by that client. Once the server sends a client
an
<span class="symbol">XkbNewKeyboardNotify</span>
event, it reports events from all keys because it assumes that any client that
has received an
<span class="symbol">XkbNewKeyboardNotify</span>
event expects key events from the new range of keycodes. The implicit support
for Xkb asks for
<span class="symbol">XkbNewKeyboardNotify</span>
events, so the range of keycodes reported to the client might vary without the
client’s knowledge. Most clients don’t really care about the range of legal
keycodes, but some clients maintain information about each key and might have
problems with events that come from unexpected keys. Such clients can set the
<span class="symbol">XkbLC_IgnoreNewKeyboards</span>
library control (see <a class="link" href="#IgnoreNewKeyboards" title="IgnoreNewKeyboards">section 11.3.1</a>) to prevent the implicit support from
requesting notification of changes to the legal range of keycodes.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="X_Library_Functions_Affected_by_Xkb"></a>X Library Functions Affected by Xkb</h3></div></div></div><p>
The following X library functions are modified by Xkb:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="function">XKeycodeToKeysym</code></td></tr><tr><td><code class="function">XKeysymToKeycode</code></td></tr><tr><td><code class="function">XLookupKeysym</code></td></tr><tr><td><code class="function">XLookupString</code></td></tr><tr><td><code class="function">XRefreshKeyboardMapping</code></td></tr><tr><td><code class="function">XRebindKeysym</code></td></tr></table><p>
</p><p>
The implicit support for Xkb replaces a number of X library functions with
versions that understand and use the X Keyboard Extension. In most cases, the
semantics of the new versions are identical to those of the old, but there are
occasional visible differences. This section lists all of the functions that
are affected and the differences in behavior, if any, that are visible to
clients.
</p><p><a id="XKeycodeToKeysym"></a>
The
<span class="olink"><code class="function">XKeycodeToKeysym</code></span>
<a id="idm7179" class="indexterm"></a>
function reports the keysym associated with a particular index for a single
key. The index specifies a column of symbols in the core keyboard mapping (that
is, as reported by the core protocol
<code class="systemitem">GetKeyboardMapping</code>
request). The order of the symbols in the core mapping does not necessarily
correspond to the order of the symbols used by Xkb; <a class="link" href="#Xkb_Keyboard_Mapping_to_Core_Keyboard_Mapping_Transformations" title="Xkb Keyboard Mapping to Core Keyboard Mapping Transformations">section 17.1.3</a> describes
the differences.
</p><p><a id="XKeysymToKeycode"></a>
The
<span class="olink"><code class="function">XKeysymToKeycode</code></span>
<a id="idm7187" class="indexterm"></a>
function reports a keycode to which a particular keysym is bound. When Xkb is
missing or disabled, this function looks in each column of the core keyboard
mapping in turn and returns the lowest numbered key that matches in the lowest
numbered group. When Xkb is present, this function uses the Xkb ordering for
symbols instead.
</p><p><a id="XLookupKeysym"></a>
The
<span class="olink"><code class="function">XLookupKeysym</code></span>
<a id="idm7193" class="indexterm"></a>
function reports the symbol in a specific column of the key associated with an
event. Whether or not Xkb is present, the column specifies an index into the
core symbol mapping.
</p><p><a id="XLookupString"></a>
The
<span class="olink"><code class="function">XLookupString</code></span>
<a id="idm7199" class="indexterm"></a>
function reports the symbol and string associated with a key event, taking
into account the keycode and keyboard state as reported in the event. When Xkb
is disabled or missing,
<code class="function">XLookupString</code>
uses the rules specified by the core protocol and reports only ISO Latin-1
characters. When Xkb is present,
<code class="function">XLookupString</code>
uses the explicit keyboard group, key types, and rules specified by Xkb. When
Xkb is present,
<code class="function">XLookupString</code>
is allowed, but not required, to return strings in character sets other than
ISO Latin-1, depending on the current locale. If any key bindings are defined,
<code class="function">XLookupString</code>
does not use any consumed modifiers (see <a class="link" href="#ConsumeLookupMods" title="ConsumeLookupMods">section 11.1.2</a> and <a class="link" href="#Key_Types" title="Key Types">section 15.2</a>) to
determine matching bindings.
</p><p><a id="XRefreshKeyboardMapping"></a>
The
<span class="olink"><code class="function">XRefreshKeyboardMapping</code></span>
<a id="idm7211" class="indexterm"></a>
function updates the X library’s internal representation of the keyboard to
reflect changes reported via
<span class="symbol">MappingNotify</span>
events. When Xkb is missing or disabled, this function reloads the entire
modifier map or keyboard mapping. When Xkb is present, the implicit Xkb support
keeps track of the changed components reported by each
<span class="symbol">XkbMapNotify</span>
event and updates only those pieces of the keyboard description that have
changed. If the implicit support has not noted any keyboard mapping changes,
<code class="function">XRefreshKeyboardMapping</code>
updates the entire keyboard description.
</p><p><a id="XRebindKeysym"></a>
The
<span class="olink"><code class="function">XRebindKeysym</code></span>
<a id="idm7220" class="indexterm"></a>
function associates a string with a keysym and a set of modifiers. Xkb does
not directly change this function, but it does affect the way that the state
reported in the event is compared to the state specified to
<code class="function">XRebindKeysym</code>.
When Xkb is missing or disabled,
<code class="function">XLookupString</code>
returns the specified string if the modifiers in the event exactly match the
modifiers from this call. When Xkb is present, any modifiers used to determine
the keysym are consumed and are not used to look up the string.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Xkb_Event_and_Keymap_Functions"></a>Xkb Event and Keymap Functions</h2></div></div></div><p>
To find the keysym bound to a particular key at a specified group and shift
level, use <code class="function">XkbKeycodeToKeysym</code>.
</p><a id="idm7229" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeycodeToKeysym"></a><p><code class="funcdef">KeySym <strong class="fsfunc">XkbKeycodeToKeysym</strong>(</code>Display *<var class="pdparam">dpy</var>, KeyCode <var class="pdparam">kc</var>, unsigned int <var class="pdparam">group</var>, unsigned int <var class="pdparam">level</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>kc</code></em>
    </span></p></td><td><p>
        key of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>group</code></em>
    </span></p></td><td><p>
        group of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>level</code></em>
    </span></p></td><td><p>
        shift level of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeycodeToKeysym</code>
returns the keysym bound to a particular group and shift level for a
particular key on the core keyboard. If
<em class="parameter"><code>kc</code></em>
is not a legal keycode for the core keyboard, or if
<em class="parameter"><code>group</code></em>
or
<em class="parameter"><code>level</code></em>
are out of range for the specified key,
<code class="function">XkbKeycodeToKeysym</code>
returns
<span class="symbol">NoSymbol</span>.
</p><p>
To find the set of modifiers bound to a particular keysym on the core keyboard,
use
<code class="function">XkbKeysymToModifiers</code>.
</p><a id="idm7274" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeysymToModifiers"></a><p><code class="funcdef">unsigned int <strong class="fsfunc">XkbKeysymToModifiers</strong>(</code>Display *<var class="pdparam">dpy</var>, KeySym <var class="pdparam">ks</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ks</code></em>
    </span></p></td><td><p>
        keysym of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeysymToModifiers</code>
finds the set of modifiers currently bound to the keysym
<em class="parameter"><code>ks</code></em>
on the core keyboard. The value returned is the mask of modifiers bound to the
keysym
<em class="parameter"><code>ks</code></em>.
If no modifiers are bound to the keysym,
<code class="function">XkbKeysymToModifiers</code>
returns zero; otherwise, it returns the inclusive OR of zero or more of the
following:
<span class="symbol">ShiftMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">Mod1Mask</span>,
<span class="symbol">Mod2Mask</span>,
<span class="symbol">Mod3Mask</span>,
<span class="symbol">Mod4Mask</span>,
and
<span class="symbol">Mod5Mask</span>.
</p><p>
Use
<code class="function">XkbLookupKeySym</code>
to find the symbol associated with a key for a particular state.
</p><a id="idm7311" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLookupKeySym"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbLookupKeySym</strong>(</code>Display *<var class="pdparam">dpy</var>, KeyCode <var class="pdparam">key</var>, unsigned int <var class="pdparam">state</var>, unsigned int *<var class="pdparam">mods_rtrn</var>, KeySym *<var class="pdparam">sym_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>key</code></em>
    </span></p></td><td><p>
        key for which symbols are to be found
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state</code></em>
    </span></p></td><td><p>
        state for which symbol should be found
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mods_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with consumed modifiers
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sym_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with symbol associated with key + state
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbLookupKeySym</code>
is the equivalent of the core
<span class="symbol">XLookupKeySym</span>
function. For the core keyboard, given a keycode
<em class="parameter"><code>key</code></em>
and an Xkb state
<em class="parameter"><code>state</code></em>,
<code class="function">XkbLookupKeySym</code>
returns the symbol associated with the key  in
<em class="parameter"><code>sym_rtrn</code></em>
and the list of modifiers that should still be applied in
<em class="parameter"><code>mods_rtrn</code></em>.
The
<em class="parameter"><code>state</code></em>
parameter is the state from a
<span class="symbol">KeyPress</span>
or
<span class="symbol">KeyRelease</span>
event.
<code class="function">XkbLookupKeySym</code>
returns
<span class="symbol">True</span>
if it succeeds.
</p><p>
Use
<code class="function">XkbLookupKeyBinding</code>
to find the string bound to a key by
<code class="function">XRebindKeysym</code>.
<code class="function">XkbLookupKeyBinding</code>
is the equivalent of the core
<code class="function">XLookupString</code>
function.
</p><a id="idm7372" class="indexterm"></a><div class="funcsynopsis"><a id="XkbLookupKeyBinding"></a><p><code class="funcdef">int <strong class="fsfunc">XkbLookupKeyBinding</strong>(</code>Display *<var class="pdparam">dpy</var>, KeySym <var class="pdparam">sym</var>, unsigned int <var class="pdparam">state</var>, char *<var class="pdparam">buf</var>, int <var class="pdparam">nbytes</var>, int *<var class="pdparam">extra_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sym</code></em>
    </span></p></td><td><p>
        symbol to be looked up
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>state</code></em>
    </span></p></td><td><p>
        state for which string is to be looked up
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>buf</code></em>
    </span></p></td><td><p>
        buffer into which returned string is written
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>nbytes</code></em>
    </span></p></td><td><p>
        size of buffer in bytes
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>extra_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with number bytes overflow
      </p></td></tr></tbody></table></div><p>
<code class="function">XRebindKeysym</code>
binds an ASCII string to a specified keysym, so that the string and keysym are
returned when the key is pressed and a specified list of modifiers are also
being held down.
<code class="function">XkbLookupKeyBinding</code>
returns in
<em class="parameter"><code>buf</code></em>
the string associated with the keysym
<em class="parameter"><code>sym</code></em>
and modifier state
<em class="parameter"><code>state</code></em>.
<em class="parameter"><code>buf</code></em>
is
<span class="symbol">NULL</span>
terminated unless there’s an overflow. If the string returned is larger than
<em class="parameter"><code>nbytes</code></em>,
a count of bytes that does not fit into the buffer is returned in extra_rtrn.
<code class="function">XkbTranslateKeySym</code>
returns the number of bytes that it placed into
<em class="parameter"><code>buf</code></em>.
</p><p>
To find the string and symbol associated with a keysym for a given keyboard
state, use
<code class="function">XkbTranslateKeySym</code>.
</p><a id="idm7435" class="indexterm"></a><div class="funcsynopsis"><a id="XkbTranslateKeySym"></a><p><code class="funcdef">int <strong class="fsfunc">XkbTranslateKeySym</strong>(</code>Display *<var class="pdparam">dpy</var>, KeySym *<var class="pdparam">sym_inout</var>, unsigned int <var class="pdparam">mods</var>, char *<var class="pdparam">buf</var>, int <var class="pdparam">nbytes</var>, int *<var class="pdparam">extra_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sym_inout</code></em>
    </span></p></td><td><p>
        symbol to be translated; result of translation
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mods</code></em>
    </span></p></td><td><p>
        modifiers to apply to <em class="parameter"><code>sym_inout</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>buf</code></em>
    </span></p></td><td><p>
        buffer into which returned string is written
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>nbytes</code></em>
    </span></p></td><td><p>
        size of buffer in bytes
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>extra_rtrn</code></em>
    </span></p></td><td><p>
        number of bytes overflow
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbTranslateKeySym</code>
applies the transformations specified in
<em class="parameter"><code>mods</code></em>
to the symbol specified by
<em class="parameter"><code>sym_inout</code></em>.
It returns in
<em class="parameter"><code>buf</code></em>
the string, if any, associated with the keysym for the current locale. If the
transformations in
<em class="parameter"><code>mods</code></em>
changes the keysym,
<em class="parameter"><code>sym_inout</code></em>
is updated accordingly. If the string returned is larger than
<em class="parameter"><code>nbytes</code></em>,
a count of bytes that does not fit into the buffer is returned in extra_rtrn.
<code class="function">XkbTranslateKeySym</code>
returns the number of bytes it placed into
<em class="parameter"><code>buf</code></em>.
</p><p>
To update the keyboard description that is internal to the X library, use
<code class="function">XkbRefreshKeyboardMapping</code>.
</p><a id="idm7498" class="indexterm"></a><div class="funcsynopsis"><a id="XkbRefreshKeyboardMapping"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbRefreshKeyboardMapping</strong>(</code>XkbMapNotifyEvent *<var class="pdparam">event</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>event</code></em>
    </span></p></td><td><p>
        event initiating remapping
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbRefreshKeyboardMapping</code>
is the Xkb equivalent of the core
<code class="function">XRefreshKeyboardMapping</code>
function. It requests that the X server send the current key mapping
information to this client. A client usually invokes
<code class="function">XkbRefreshKeyboardMapping</code>
after receiving an
<span class="symbol">XkbMapNotify</span>
event.
<code class="function">XkbRefreshKeyboardMapping</code>
returns
<span class="symbol">Success</span>
if it succeeds and
<span class="errorname">BadMatch</span>
if the event is not an Xkb event.
</p><p>
The
<span class="symbol">XkbMapNotify</span>
event can be generated when some client calls
<code class="function">XkbSetMap</code>,
<code class="function">XkbChangeMap</code>,
<code class="function">XkbGetKeyboardByName</code>,
or any of the standard X library functions that change the keyboard mapping
or modifier mapping.
</p><p>
To translate a keycode to a key symbol and modifiers, use
<code class="function">XkbTranslateKeyCode</code>.
</p><a id="idm7528" class="indexterm"></a><div class="funcsynopsis"><a id="XkbTranslateKeyCode"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbTranslateKeyCode</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">key</var>, unsigned int <var class="pdparam">mods</var>, unsigned int *<var class="pdparam">mods_rtrn</var>, KeySym *<var class="pdparam">keysym_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to use for translation
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>key</code></em>
    </span></p></td><td><p>
        keycode to translate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mods</code></em>
    </span></p></td><td><p>
        modifiers to apply when translating <em class="parameter"><code>key</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mods_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with consumed modifiers
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keysym_rtrn</code></em>
    </span></p></td><td><p>
        keysym resulting from translation
      </p></td></tr></tbody></table></div><p>
<em class="parameter"><code>mods_rtrn</code></em>
is backfilled with the modifiers consumed by the translation process.
<em class="parameter"><code>mods</code></em>
is a bitwise inclusive OR of the legal modifier masks:
<span class="symbol">ShiftMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">Mod1Mask</span>,
<span class="symbol">Mod2Mask</span>,
<span class="symbol">Mod3Mask</span>,
<span class="symbol">Mod4Mask</span>,
<span class="symbol">Mod5Mask</span>.
The
<span class="emphasis"><em>AlwaysConsumeShiftAndLock</em></span>
library control (see <a class="link" href="#AlwaysConsumeShiftAndLock" title="AlwaysConsumeShiftAndLock">section 11.1.3</a>), if enabled, causes
<code class="function">XkbTranslateKeyCode</code>
to consume shift and lock.
<code class="function">XkbTranslateKeyCode</code>
returns
<span class="symbol">True</span>
if the translation resulted in a keysym, and
<span class="symbol">False</span>
if it resulted in
<span class="symbol">NoSymbol</span>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Keyboard_Geometry"></a>Chapter 13. Keyboard Geometry</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Shapes_and_Outlines">Shapes and Outlines</a></span></dt><dt><span class="sect1"><a href="#Sections">Sections</a></span></dt><dt><span class="sect1"><a href="#Rows_and_Keys">Rows and Keys</a></span></dt><dt><span class="sect1"><a href="#Doodads">Doodads</a></span></dt><dt><span class="sect1"><a href="#Overlay_Rows_and_Overlay_Keys">Overlay Rows and Overlay Keys</a></span></dt><dt><span class="sect1"><a href="#Drawing_a_Keyboard_Representation">Drawing a Keyboard Representation</a></span></dt><dt><span class="sect1"><a href="#Geometry_Data_Structures">Geometry Data Structures</a></span></dt><dd><dl><dt><span class="sect2"><a href="#DoodadRec_Structures">DoodadRec Structures</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Keyboard_Geometry_From_the_Server">Getting Keyboard Geometry From the Server</a></span></dt><dt><span class="sect1"><a href="#Using_Keyboard_Geometry">Using Keyboard Geometry</a></span></dt><dt><span class="sect1"><a href="#Adding_Elements_to_a_Keyboard_Geometry">Adding Elements to a Keyboard Geometry</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Geometry_Components">Allocating and Freeing Geometry Components</a></span></dt></dl></div><p>
The Xkb description of a keyboard includes an optional keyboard geometry that
describes the physical appearance of the keyboard. Keyboard geometry describes
the shape, location, and color of all keyboard keys or other visible keyboard
components such as indicators. The information contained in a keyboard geometry
is sufficient to allow a client program to draw an accurate two-dimensional
image of the keyboard.
</p><p>
You can retrieve a keyboard geometry from an X server that supports Xkb, or you
can allocate it from scratch and initialize it in a client program. The
keyboard geometry need not have any correspondence with the physical keyboard
that is connected to the X server.
</p><p>
Geometry measurements are specified in mm/10 units. The origin (0,0) is in the
top left corner of the keyboard image. A component’s own origin is also its
upper left corner. In some cases a component needs to be drawn rotated. For
example, a special keyboard may have a section of keys arranged in rows in a
rectangular area, but the entire rectangle may not be in alignment with the
rest of the keyboard, and instead, it is rotated from horizontal by 30°.
Rotation for a geometry object is specified in 1/10° increments about its
origin. An example of a keyboard with rotated sections is shown in <a class="link" href="#figure13.1" title="Figure 13.1. Rotated Keyboard Sections">Figure 13.1</a>.
</p><div class="figure"><a id="figure13.1"></a><p class="title"><strong>Figure 13.1. Rotated Keyboard Sections</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-7.svg"></object></div></div></div><br class="figure-break" /><p>
Some geometry components include a
<em class="structfield"><code>priority</code></em>,
which indicates the order in which overlapping objects should be drawn.
Objects should be drawn in order from highest priority (0) to lowest (255).
</p><p><a id="XkbGeometryRec"></a>
<a id="idm7604" class="indexterm"></a>
The keyboard geometry’s top-level description is stored in a
<span class="structname">XkbGeometryRec</span>
structure. This structure contains three types of information:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Lists of items, not used to draw the basic keyboard, but indexed by the
geometry descriptions that comprise the entire keyboard geometry (colors,
geometry properties, key aliases, shapes)
    </p></li><li class="listitem"><p>
A number of singleton items that describe the keyboard as a whole (keyboard
name, width and height, a color for the keyboard as a whole, and a color for
keyboard key labels)
    </p></li><li class="listitem"><p>
A list of the keyboard’s sections and nonkey doodads
    </p></li></ol></div><p>
The top-level geometry is described in more detail in the following.
</p><p>
The lists of items used by components of the keyboard geometry description is
as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The top-level keyboard geometry description includes a list of up to
<span class="symbol">XkbGeomMaxColors</span>
(32)
<em class="firstterm">color names</em>.
A color name is a string whose interpretation is not specified by Xkb. The
<span class="structname">XkbColorRec</span>
structure provides a field for this name as well as a pixel field. The pixel
field is a convenient place for an application to store a pixel value or color
definition, if it needs to. All other geometry data structures refer to colors
using their indices in this global list.
  </p></li><li class="listitem"><p>
The top-level keyboard geometry description includes a list of
<em class="firstterm">geometry properties</em>.
A geometry property associates an arbitrary string with an equally arbitrary
name. Geometry properties can be used to provide hints to programs that display
images of keyboards, but they are not interpreted by Xkb. No other geometry
structures refer to geometry properties. As an example of a possible use of
<em class="structfield"><code>properties</code></em>,
consider the pause/break key on most PC keyboards: the <span class="quote">“<span class="quote">break</span>”</span>
symbol is
usually on the front of the key and is often a different color. A program might
set a property to:
  </p><p>
LBL_PAUS = "{Pause/top/black,Break/front/red}"
  </p><p>
and use the property information to draw the key with a front label as well as
a top label.
  </p></li><li class="listitem"><p>
The top-level keyboard geometry description includes a list of
<em class="firstterm">key aliases</em>
(see <a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a>). Key aliases allow the keyboard layout designer to assign
multiple key names to a single key.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Key aliases defined in the geometry component of a keyboard mapping
override those defined in the keycodes component of the server database, which
are stored in the
<span class="structname">XkbNamesRec</span>

(<em class="structfield"><code>xkb-&gt;names</code></em>).
Therefore, consider the key aliases defined by the geometry before
considering key aliases supplied by the keycodes.</p></div></li><li class="listitem"><p>
The top-level keyboard geometry description includes a list of
<em class="structfield"><code>shapes</code></em>;
other keyboard components refer to shapes by their index in this list. A
shape consists of an arbitrary name of type Atom and one or more closed-polygon
<em class="structfield"><code>outlines</code></em>.
All points in an outline are specified relative to the origin of its
enclosing shape, that is, whichever shape that contains this outline in its
list of outlines. One outline is the primary outline. The primary outline is by
default the first outline, or it can be optionally specified by the
<em class="structfield"><code>primary</code></em>
field in the
<span class="structname">XkbShapeRec</span>
structure. A keyboard display application can generate a simpler but still
accurate keyboard image by displaying only the primary outlines for each shape.
Nonrectangular keys must include a rectangular
<em class="firstterm">approximation</em>
as one of the outlines associated with the shape. The approximation is not
normally displayed but can be used by very simple keyboard display applications
to generate a recognizable but degraded image of the keyboard.
  </p></li></ul></div><p>
The
<span class="structname">XkbGeometryRec</span>
top-level geometry description contains the following information that
pertains to the keyboard as a whole:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
A
<em class="firstterm">keyboard symbolic name</em>
of type Atom to help users identify the keyboard.
  </p></li><li class="listitem"><p>
The
<em class="structfield"><code>width</code></em>
and
<em class="structfield"><code>height</code></em>
of the keyboard, in mm/10. For nonrectangular keyboards, the width and height
describe the smallest bounding box that encloses the outline of the keyboard.
  </p></li><li class="listitem"><p>
The
<em class="firstterm">base color</em>
of the keyboard is the predominant color on the keyboard and is used as the
default color for any components whose color is not explicitly specified.
  </p></li><li class="listitem"><p>
The
<em class="firstterm">label color</em>
is the color used to draw the labels on most of the keyboard keys.
  </p></li><li class="listitem"><p>
The
<em class="firstterm">label font</em>
is a string that describes the font used to draw labels on most keys; label
fonts are arbitrary strings, because Xkb does not specify the format or name
space for font names.
  </p></li></ul></div><p>
The keyboard is subdivided into named
<em class="structfield"><code>sections</code></em>
of related keys and doodads. The sections and doodads on the keyboard are
listed in the
<span class="structname">XkbGeometryRec</span>
top-level keyboard geometry description. A section is composed of keys that
are physically together and logically related. <a class="link" href="#figure13.2" title="Figure 13.2. Keyboard with Four Sections">Figure 13.2</a> shows a keyboard
that is divided into four sections. A
<em class="structfield"><code>doodad</code></em>
describes some visible aspect of the keyboard that is not a key and is not a
section.
</p><div class="figure"><a id="figure13.2"></a><p class="title"><strong>Figure 13.2. Keyboard with Four Sections</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-8.svg"></object></div></div></div><br class="figure-break" /><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Shapes_and_Outlines"></a>Shapes and Outlines</h2></div></div></div><p>
A
<em class="structfield"><code>shape</code></em>,
used to draw keyboard components and stored in a
<span class="structname">XkbShapeRec</span>
structure, has:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
An arbitrary name of type Atom.
  </p></li><li class="listitem"><p>
Bounds (two x and y coordinates) that describe the corners of a rectangle
containing the shape’s top surface outline.
  </p></li><li class="listitem"><p>
A list of one or more outlines (described below).
  </p></li><li class="listitem"><p>
Optional pointers to a primary and an approximation outline (described below).
If either of these pointers is
<span class="symbol">NULL</span>,
the default primary/approximation outline is the first one in the list of
outlines for the shape.
  </p></li></ul></div><p>
An
<em class="firstterm">outline</em>,
stored in a
<span class="structname">XkbOutlineRec</span>
structure, is a list of one or more points that describes a single
closed-polygon, as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
A list with a single point describes a rectangle with one corner at the origin
of the shape (0,0) and the opposite corner at the specified point.
  </p></li><li class="listitem"><p>
A list of two points describes a rectangle with one corner at the position
specified by the first point and the opposite corner at the position specified
by the second point.
  </p></li><li class="listitem"><p>
A list of three or more points describes an arbitrary polygon. If necessary,
the polygon is automatically closed by connecting the last point in the list
with the first.
  </p></li><li class="listitem"><p>
A nonzero value for the
<em class="structfield"><code>corner_radius</code></em>
field specifies that the corners of the polygon should be drawn as circles
with the specified radius.
  </p></li></ul></div><p>
All points in an outline are specified relative to the origin of the enclosing
shape. Points in an outline may have negative values for the X and Y coordinate.
</p><p>
One outline is the primary outline; a keyboard display application can generate
a simple but still accurate keyboard image by displaying only the primary
outlines for each shape. The default primary outline is the first in a
shape’s list of outlines. If the
<em class="structfield"><code>primary</code></em>
field of the
<span class="structname">XkbShapeRec</span>
structure is not
<span class="symbol">NULL</span>,
it points to the primary outline. A rectangular
<em class="firstterm">approximation</em>
must be included for nonrectangular keys as one of the outlines associated
with the shape; the approximation is not normally displayed but can be used by
very simple keyboard display applications to generate a recognizable but
degraded image of the keyboard.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Sections"></a>Sections</h2></div></div></div><p>
As previously noted, a keyboard is subdivided into
<em class="structfield"><code>sections</code></em>
of related keys. Each section has its own coordinate system — if a section
is rotated, the coordinates of any components within the section are
interpreted relative to the edges that were on the top and left before
rotation. The components that make up a section, stored in a
<span class="structname">XkbSectionRec</span>,
include:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
An arbitrary name of type Atom.
  </p></li><li class="listitem"><p>
A priority, to indicate drawing order. 0 is the highest priority, 255 the
lowest.
  </p></li><li class="listitem"><p>
Origin of the section, relative to the origin of the keyboard.
  </p></li><li class="listitem"><p>
The width and height and the angle of rotation.
  </p></li><li class="listitem"><p>
A list of
<em class="structfield"><code>rows</code></em>.
A row is a list of horizontally or vertically adjacent keys. Horizontal rows
parallel the (prerotation) top of the section, and vertical rows parallel the
(prerotation) left of the section. All keys in a horizontal row share a common
top coordinate; all keys in a vertical row share a left coordinate. <a class="link" href="#figure13.3" title="Figure 13.3. Rows in a Section">Figure 13.3</a>
shows the alpha section from the keyboard shown in <a class="link" href="#figure13.2" title="Figure 13.2. Keyboard with Four Sections">Figure 13.2</a>, divided into
rows. Rows and keys are defined below.
  </p></li></ul></div><div class="figure"><a id="figure13.3"></a><p class="title"><strong>Figure 13.3. Rows in a Section</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-9.svg"></object></div></div></div><br class="figure-break" /><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
An optional list of
<em class="structfield"><code>doodads</code></em>;
any type of doodad can be enclosed within a section. Position and angle of
rotation are relative to the origin and angle of rotation of the sections that
contain them. Priority for doodads in a section is relative to the other
components of the section, not to the keyboard as a whole.
  </p></li><li class="listitem"><p>
An optional
<em class="firstterm">overlay</em>
with a name of type Atom and a list of overlay rows (described below).
  </p></li><li class="listitem"><p>
Bounds (two x and y coordinates) that describe the corners of a rectangle
containing the entire section.
  </p></li></ul></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Rows_and_Keys"></a>Rows and Keys</h2></div></div></div><p>
A row description
(<span class="structname">XkbRowRec</span>)
consists of the coordinates of its origin relative to its enclosing section,
a flag indicating whether the row is horizontal or vertical, and a list of keys
in the row.
</p><p>
A key description
(<span class="structname">XkbKeyRec</span>)
consists of a key name, a shape, a key color, and a gap. The key name should
correspond to one of the keys named in the keyboard names description, the
shape specifies the appearance of the key, and the key color specifies the
color of the key (not the label on the key; the label color is stored in the
<span class="structname">XkbGeometryRec</span>).
Keys are normally drawn immediately adjacent to one another from left to
right (or top to bottom) within a row. The gap field specifies the distance
between a key and its predecessor.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Doodads"></a>Doodads</h2></div></div></div><p>
Doodads can be global to the keyboard or part of a section. Doodads have
symbolic names of arbitrary length. The only doodad name whose interpretation
is specified by Xkb is <span class="quote">“<span class="quote">Edges</span>”</span>, which, if present, describes the
outline of the entire keyboard.
</p><p>
Each doodad’s origin is stored in fields named
<em class="structfield"><code>left</code></em>
and
<em class="structfield"><code>top</code></em>,
which are the coordinates of the doodad’s origin relative to its enclosing
object, whether it be a section or the top-level keyboard. The priority for
doodads that are listed in the top-level geometry is relative to the other
doodads listed in the top-level geometry and the sections listed in the
top-level geometry. The priority for doodads listed in a section are relative
to the other components of the section. Each doodad is stored in a structure
with a
<em class="structfield"><code>type</code></em>
field, which specifies the type of doodad.
</p><p>
Xkb supports five types of doodads:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
An
<em class="firstterm">indicator doodad</em>
describes one of the physical keyboard indicators. Indicator doodads specify
the shape of the indicator, the indicator color when it is lit
(<span class="emphasis"><em>on_color</em></span>)
and the indicator color when it is dark
(<span class="emphasis"><em>off_color</em></span>).

  </p></li><li class="listitem"><p>
An
<em class="firstterm">outline doodad</em>
describes some aspect of the keyboard to be drawn as one or more hollow,
closed polygons. Outline doodads specify the shape, color, and angle of
rotation about the doodad origin at which they should be drawn.
  </p></li><li class="listitem"><p>
A
<em class="firstterm">solid doodad</em>
describes some aspect of the keyboard to be drawn as one or more filled
polygons. Solid doodads specify the shape, color, and angle of rotation about
the doodad origin at which they should be drawn.
  </p></li><li class="listitem"><p>
A
<em class="firstterm">text doodad</em>
describes a text label somewhere on the keyboard. Text doodads specify the
label string, the font and color to use when drawing the label, and the angle
of rotation of the doodad about its origin.
  </p></li><li class="listitem"><p>
A
<em class="firstterm">logo doodad</em>
is a catch-all, which describes some other visible element of the keyboard. A
logo doodad is essentially an outline doodad with an additional symbolic name
that describes the element to be drawn. If a keyboard display program
recognizes the symbolic name, it can draw something appropriate within the
bounding region of the shape specified in the doodad. If the symbolic name does
not describe a recognizable image, it should draw an outline using the
specified shape, outline, and angle of rotation. The Xkb extension does not
specify the interpretation of logo names.
  </p></li></ul></div><p>
The structures these doodads are stored in and the values of the
<em class="structfield"><code>type</code></em>
fields are shown in <a class="link" href="#table13.1" title="Table 13.1. Doodad Types">Table 13.1</a>.
</p><div class="table"><a id="table13.1"></a><p class="title"><strong>Table 13.1. Doodad Types</strong></p><div class="table-contents"><table class="table" summary="Doodad Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Doodad</th><th align="left">Structure</th><th align="left">Type</th></tr></thead><tbody><tr><td align="left">
<span class="emphasis"><em>indicator doodad</em></span>
</td><td align="left">
<span class="structname">XkbIndicatorDoodadRec</span>
</td><td align="left">
<span class="symbol">XkbIndicatorDoodad</span>
</td></tr><tr><td align="left">
<span class="emphasis"><em>outline doodad</em></span>
</td><td align="left">
<span class="structname">XkbShapeDoodadRec</span>
</td><td align="left">
<span class="symbol">XkbOutlineDoodad</span>
</td></tr><tr><td align="left">
<span class="emphasis"><em>solid doodad</em></span>
</td><td align="left">
<span class="structname">XkbShapeDoodadRec</span>
</td><td align="left">
<span class="symbol">XkbSolidDoodad</span>
</td></tr><tr><td align="left">
<span class="emphasis"><em>text doodad</em></span>
</td><td align="left">
<span class="structname">XkbTextDoodadRec</span>
</td><td align="left">
<span class="symbol">XkbTextDoodad</span>
</td></tr><tr><td align="left">
<span class="emphasis"><em>logo doodad</em></span>
</td><td align="left">
<span class="structname">XkbLogoDoodadRec</span>
</td><td align="left">
<span class="symbol">XkbLogoDoodad</span>
</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Overlay_Rows_and_Overlay_Keys"></a>Overlay Rows and Overlay Keys</h2></div></div></div><p>
An
<em class="firstterm">overlay row</em>

(<span class="structname">XkbOverlayRowRec</span>)
contains a pointer to the row it overlays and a list of
<em class="firstterm">overlay keys</em>.
</p><p>
Each overlay key definition
(<span class="structname">XkbOverlayKeyRec</span>)
indicates a key that can yield multiple keycodes and consists of a field
named
<em class="structfield"><code>under</code></em>,
which specifies the primary name of the key and a field named
<em class="structfield"><code>over</code></em>,
which specifies the name for the key when the overlay keycode is selected.
The key specified in
<em class="structfield"><code>under</code></em>
must be a member of the section that contains the overlay key definition,
while the key specified in over must not be.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Drawing_a_Keyboard_Representation"></a>Drawing a Keyboard Representation</h2></div></div></div><p>
To draw a representation of the keyboard, draw in the following order:

</p><pre class="programlisting">
     Draw the top-level keyboard as a rectangle, using its width and height.
     For each component (section or doodad) of the top-level geometry, in priority order:
        If component is a section
           For each row, in the order it appears in the section
              Draw keys in the order they appear in the row
           Draw doodads within the section in priority order.
        Else draw doodad
</pre></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Geometry_Data_Structures"></a>Geometry Data Structures</h2></div></div></div><p>
In the following figures, a solid arrow denotes a pointer to an array of
structures or a singleton structure. A dotted arrow denotes an index or a
pointer into the array.
</p><div class="figure"><a id="figure13.4"></a><p class="title"><strong>Figure 13.4. Xkb Geometry Data Structures</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-10.svg"></object></div></div></div><br class="figure-break" /><div class="figure"><a id="figure13.5"></a><p class="title"><strong>Figure 13.5. Xkb Geometry Data Structures (Doodads)</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-11.svg"></object></div></div></div><br class="figure-break" /><div class="figure"><a id="figure13.6"></a><p class="title"><strong>Figure 13.6. Xkb Geometry Data Structures (Overlays)</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-12.svg"></object></div></div></div><br class="figure-break" /><pre class="programlisting">
typedef struct _XkbGeometry {    /* top-level keyboard geometry structure */
    Atom              name;            /* keyboard name */
    unsigned short    width_mm;        /* keyboard width in <sup>mm</sup>/<sub>10</sub> */
    unsigned short    height_mm;       /* keyboard height in <sup>mm</sup>/<sub>10</sub> */
    char *            label_font;      /* font for key labels */
    XkbColorPtr       label_color;     /* color for key labels
                                          - pointer into colors array */
    XkbColorPtr       base_color;      /* color for basic keyboard
                                          - pointer into colors array */
    unsigned short    sz_properties;   /* size of properties array */
    unsigned short    sz_colors;       /* size of colors array */
    unsigned short    sz_shapes;       /* size of shapes array */
    unsigned short    sz_sections;     /* size of sections array */
    unsigned short    sz_doodads;      /* size of doodads array */
    unsigned short    sz_key_aliases;  /* size of key aliases array */
    unsigned short    num_properties;  /* number of properties in the
                                           properties array */
    unsigned short    num_colors;      /* number of colors in the
                                           colors array */
    unsigned short    num_shapes;      /* number of shapes in the
                                           shapes array */
    unsigned short    num_sections;    /* number of sections in the
                                           sections array */
    unsigned short    num_doodads;     /* number of doodads in the
                                           doodads array */
    unsigned short    num_key_aliases; /* number of key aliases in the
                                           key_aliases array */
    XkbPropertyPtr    properties;      /* properties array */
    XkbColorPtr       colors;          /* colors array */
    XkbShapePtr       shapes;          /* shapes array */
    XkbSectionPtr     sections;        /* sections array */
    XkbDoodadPtr      doodads;         /* doodads array */
    XkbKeyAliasPtr    key_aliases;     /* key aliases array */
} <span class="structname">XkbGeometryRec</span>, *XkbGeometryPtr;
</pre><p>
The
<em class="structfield"><code>doodads</code></em>
array is only for doodads not contained in any of the
<em class="structfield"><code>sections</code></em>
that has its own
<em class="structfield"><code>doodads</code></em>.
The key aliases contained in the
<em class="structfield"><code>key_aliases</code></em>
array take precedence over any defined in the keycodes component of the
keyboard description.
</p><pre class="programlisting">
typedef struct _XkbProperty {
    char *      name;                   /* property name */
    char *      value;                  /* property value */
} <span class="structname">XkbPropertyRec</span>, *XkbPropertyPtr;
</pre><pre class="programlisting">
typedef struct _XkbColor {
    unsigned int      pixel;            /* color */
    char *            spec;             /* color name */
} <span class="structname">XkbColorRec</span>, *XkbColorPtr;
</pre><pre class="programlisting">
typedef struct _XkbKeyAliasRec {
    char      real[XkbKeyNameLength];   /* real name of the key */
    char      alias[XkbKeyNameLength];  /* alias for the key */
} <span class="structname">XkbKeyAliasRec</span>, *XkbKeyAliasPtr;
</pre><pre class="programlisting">
typedef struct _XkbPoint {              /* x, y coordinates */
    short      x;
    short      y;
} <span class="structname">XkbPointRec</span>, *XkbPointPtr;
</pre><pre class="programlisting">
typedef struct _XkbOutline {
    unsigned short      num_points;     /* number of points in the outline */
    unsigned short      sz_points;      /* size of the points array */
    unsigned short      corner_radius;  /* draw corners as circles
                                           with this radius */
    XkbPointPtr         points;         /* array of points defining
                                           the outline */
} <span class="structname">XkbOutlineRec</span>, *XkbOutlinePtr;
</pre><pre class="programlisting">
typedef struct _XkbBounds {
    short      x1, y1;       /* upper left corner of the bounds, in <sup>mm</sup>/<sub>10</sub> */
    short      x2, y2;       /* lower right corner of the bounds, in <sup>mm</sup>/<sub>10</sub> */
} <span class="structname">XkbBoundsRec</span>, *XkbBoundsPtr;
</pre><pre class="programlisting">
typedef struct _XkbShape {
    Atom              name;             /* shape’s name */
    unsigned short    num_outlines;     /* number of outlines for the shape */
    unsigned short    sz_outlines;      /* size of the outlines array */
    XkbOutlinePtr     outlines;         /* array of outlines for the shape */
    XkbOutlinePtr     approx;           /* pointer into the array to the
                                           approximating outline */
    XkbOutlinePtr     primary;          /* pointer into the array to the
                                           primary outline */
    XkbBoundsRec      bounds;           /* bounding box for the shape;
                                           encompasses all outlines */
} <span class="structname">XkbShapeRec</span>, *XkbShapePtr;
</pre><p>
If
<em class="structfield"><code>approx</code></em>
and/or
<em class="structfield"><code>primary</code></em>
is
<span class="symbol">NULL</span>,
the default value is used. The default primary outline is the first element
in the outlines array, as is the default approximating outline.
</p><pre class="programlisting">
typedef struct _XkbKey {           /* key in a row */
    XkbKeyNameRec    name;         /* key name */
    short            gap;          /* gap in <sup>mm</sup>/<sub>10</sub> from previous key in row */
    unsigned char    shape_ndx;    /* index of shape for key */
    unsigned char    color_ndx;    /* index of color for key body */
} <span class="structname">XkbKeyRec</span>, *XkbKeyPtr;
</pre><pre class="programlisting">
typedef struct _XkbRow {           /* row in a section */
    short               top;       /* top coordinate of row origin,
                                      relative to section’s origin */
    short               left;      /* left coordinate of row origin,
                                      relative to section’s origin */
    unsigned short      num_keys;  /* number of keys in the keys array */
    unsigned short      sz_keys;   /* size of the keys array */
    int                 vertical;  /* <span class="symbol">True</span> ⇒vertical row,
                                      <span class="symbol">False</span> ⇒horizontal row */
    XkbKeyPtr           keys;      /* array of keys in the row */
    XkbBoundsRec        bounds;    /* bounding box for the row */
} <span class="structname">XkbRowRec</span>, *XkbRowPtr;
</pre><p>
<em class="structfield"><code>top</code></em>
and
<em class="structfield"><code>left</code></em>
are in
<sup>mm</sup>/<sub>10</sub>.
</p><pre class="programlisting">
typedef struct _XkbOverlayRec {
    Atom              name;           /* overlay name */
    XkbSectionPtr     section_under;  /* the section under this overlay */
    unsigned short    num_rows;       /* number of rows in the rows array */
    unsigned short    sz_rows;        /* size of the rows array */
    XkbOverlayRowPtr  rows;           /* array of rows in the overlay */
    XkbBoundsPtr      bounds;         /* bounding box for the overlay */
} <span class="structname">XkbOverlayRec</span>, *XkbOverlayPtr;
</pre><pre class="programlisting">
typedef struct _XkbOverlayRow {
    unsigned short      row_under;    /* index into the row under this
                                         overlay row */
    unsigned short      num_keys;     /* number of keys in the keys array */
    unsigned short      sz_keys;      /* size of the keys array */
    XkbOverlayKeyPtr    keys;         /* array of keys in the overlay row */
} <span class="structname">XkbOverlayRowRec</span>, *XkbOverlayRowPtr;
</pre><p>
<em class="structfield"><code>row_under</code></em>
is an index into the array of
<em class="structfield"><code>rows</code></em>
in the section under this overlay. The section under this overlay row is the
one pointed to by
<em class="structfield"><code>section_under</code></em>
in this overlay row’s
<span class="structname">XkbOverlayRec</span>.
</p><pre class="programlisting">
typedef struct _XkbOverlayKey {
    XkbKeyNameRec      over;      /* name of this overlay key */
    XkbKeyNameRec      under;     /* name of the key under this overlay key */
} <span class="structname">XkbOverlayKeyRec</span>, *XkbOverlayKeyPtr;
</pre><pre class="programlisting">
typedef struct _XkbSection {
    Atom            name;          /* section name */
    unsigned char   priority;      /* drawing priority, 0⇒highest, 255⇒lowest */
    short           top;           /* top coordinate of section origin */
    short           left;          /* left coordinate of row origin */
    unsigned short  width;         /* section width, in <sup>mm</sup>/<sub>10</sub> */
    unsigned short  height;        /* section height, in <sup>mm</sup>/<sub>10</sub> */
    short           angle;         /* angle of section rotation,
                                      counterclockwise */
    unsigned short  num_rows;      /* number of rows in the rows array */
    unsigned short  num_doodads;   /* number of doodads in the doodads array */
    unsigned short  num_overlays;  /* number of overlays in the overlays array */
    unsigned short  sz_rows;       /* size of the rows array */
    unsigned short  sz_doodads;    /* size of the doodads array */
    unsigned short  sz_overlays;   /* size of the overlays array */
    XkbRowPtr       rows;          /* section rows array */
    XkbDoodadPtr    doodads;       /* section doodads array */
    XkbBoundsRec    bounds;        /* bounding box for the section,
                                      before rotation */
    XkbOverlayPtr   overlays;      /* section overlays array */
} <span class="structname">XkbSectionRec</span>, *XkbSectionPtr;
</pre><p>
<em class="structfield"><code>top</code></em>
and
<em class="structfield"><code>left</code></em>
are the origin of the section, relative to the origin of the keyboard, in
<sup>mm</sup>/<sub>10</sub>.
<em class="structfield"><code>angle</code></em>
is in
<sup>1</sup>/<sub>10</sub>
degrees.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="DoodadRec_Structures"></a>DoodadRec Structures</h3></div></div></div><p>
The doodad arrays in the
<span class="structname">XkbGeometryRec</span>
and the
<span class="structname">XkbSectionRec</span>
may contain any of the doodad structures and types shown in
<a class="link" href="#table13.1" title="Table 13.1. Doodad Types">Table 13.1</a>.
</p><p>
The doodad structures form a union:
</p><pre class="programlisting">
typedef union _XkbDoodad {
      XkbAnyDoodadRec        any;
      XkbShapeDoodadRec      shape;
      XkbTextDoodadRec       text;
      XkbIndicatorDoodadRec  indicator;
      XkbLogoDoodadRec       logo;
} <span class="structname">XkbDoodadRec</span>, *XkbDoodadPtr;
</pre><p>
The
<em class="structfield"><code>top</code></em>
and
<em class="structfield"><code>left</code></em>
coordinates of each doodad are the coordinates of the origin of the doodad
relative to the keyboard’s origin if the doodad is in the
<span class="structname">XkbGeometryRec</span>
doodad array, and with respect to the section’s origin if the doodad is in a
<span class="structname">XkbSectionRec</span>
doodad array. The
<em class="structfield"><code>color_ndx</code></em>
or
<em class="structfield"><code>on_color_ndx</code></em>
and
<em class="structfield"><code>off_color_ndx</code></em>
fields are color indices into the
<span class="structname">XkbGeometryRec</span>’s
color array and are the colors to draw the doodads with. Similarly, the
<em class="structfield"><code>shape_ndx</code></em>
fields are indices into the
<span class="structname">XkbGeometryRec</span>’s
shape array.
</p><pre class="programlisting">
typedef struct _XkbShapeDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <span class="symbol">XkbOutlineDoodad</span>
                                      or <span class="symbol">XkbSolidDoodad</span> */
    unsigned char    priority;     /* drawing priority,
                                       0⇒highest, 255⇒lowest */
    short            top;          /* top coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            left;         /* left coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <sup>1</sup>/<sub>10</sub> degrees */
    unsigned short   color_ndx;    /* doodad color */
    unsigned short   shape_ndx;    /* doodad shape */
} <span class="structname">XkbShapeDoodadRec</span>, *XkbShapeDoodadPtr;
</pre><pre class="programlisting">
typedef struct _XkbTextDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <span class="symbol">XkbTextDoodad</span> */
    unsigned char    priority;     /* drawing priority,
                                     0⇒highest, 255⇒lowest */
    short            top;          /* top coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            left;         /* left coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <sup>1</sup>/<sub>10</sub> degrees */
    short            width;        /* width in <sup>mm</sup>/<sub>10</sub> */
    short            height;       /* height in <sup>mm</sup>/<sub>10</sub> */
    unsigned short   color_ndx;    /* doodad color */
    char *           text;         /* doodad text */
    char *           font;         /* arbitrary font name for doodad text */
} <span class="structname">XkbTextDoodadRec</span>, *XkbTextDoodadPtr;
</pre><pre class="programlisting">
typedef struct _XkbIndicatorDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <span class="symbol">XkbIndicatorDoodad</span> */
    unsigned char    priority;     /* drawing priority, 0⇒highest, 255⇒lowest */
    short            top;          /* top coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            left;         /* left coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <sup>1</sup>/<sub>10</sub> degrees */
    unsigned short   shape_ndx;    /* doodad shape */
    unsigned short   on_color_ndx; /* color for doodad if indicator is on */
    unsigned short   off_color_ndx;/* color for doodad if indicator is off */
} <span class="structname">XkbIndicatorDoodadRec</span>, *XkbIndicatorDoodadPtr;
</pre><pre class="programlisting">
typedef struct _XkbLogoDoodad {
    Atom             name;         /* doodad name */
    unsigned char    type;         /* <span class="symbol">XkbLogoDoodad</span> */
    unsigned char    priority;     /* drawing priority, 0⇒highest, 255⇒lowest */
    short            top;          /* top coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            left;         /* left coordinate, in <sup>mm</sup>/<sub>10</sub> */
    short            angle;        /* angle of rotation, clockwise,
                                      in <sup>1</sup>/<sub>10</sub> degrees */
    unsigned short   color_ndx;    /* doodad color */
    unsigned short   shape_ndx;    /* doodad shape */
    char *           logo_name;    /* text for logo */
} <span class="structname">XkbLogoDoodadRec</span>, *XkbLogoDoodadPtr
</pre></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Getting_Keyboard_Geometry_From_the_Server"></a>Getting Keyboard Geometry From the Server</h2></div></div></div><p>
You can load a keyboard geometry as part of the keyboard description returned
by
<code class="function">XkbGetKeyboard</code>.
However, if a keyboard description has been previously loaded, you can
instead obtain the geometry by calling the
<code class="function">XkbGetGeometry</code>.
In this case, the geometry returned is the one associated with the keyboard
whose device ID is contained in the keyboard description.
</p><p>
To load a keyboard geometry if you already have the keyboard description, use
<code class="function">XkbGetGeometry</code>.
</p><a id="idm8016" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetGeometry"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetGeometry</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description that contains the ID for the keyboard and into
        which the geometry should be loaded
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetGeometry</code>
can return
<span class="errorname">BadValue</span>,
<span class="errorname">BadImplementation</span>,
<span class="errorname">BadName</span>,
<span class="errorname">BadAlloc</span>,
or
<span class="errorname">BadLength</span>
errors or
<span class="symbol">Success</span>
if it succeeds.
</p><p>
It is also possible to load a keyboard geometry by name. The X server maintains
a database of keyboard components (see <a class="xref" href="#Server_Database_of_Keyboard_Components" title="Chapter 20. Server Database of Keyboard Components">Chapter 20, <em>Server Database of Keyboard Components</em></a>). To load a keyboard geometry
description from this database by name, use
<code class="function">XkbGetNamedGeometry</code>.
</p><a id="idm8049" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetNamedGeometry"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetNamedGeometry</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, Atom <var class="pdparam">name</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description into which the geometry should be loaded
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the geometry to be loaded
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetNamedGeometry</code>
can return
<span class="errorname">BadName</span>
if the
<em class="parameter"><code>name</code></em>
cannot be found.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Using_Keyboard_Geometry"></a>Using Keyboard Geometry</h2></div></div></div><p>
Xkb provides a number of convenience functions to help use a keyboard geometry.
These include functions to return the bounding box of a shape’s top surface
and to update the bounding box of a shape row or section.
</p><p>
A shape is made up of a number of outlines. Each outline is a polygon made up
of a number of points. The bounding box of a shape is a rectangle that contains
all the outlines of that shape.
</p><div class="figure"><a id="figure13.7"></a><p class="title"><strong>Figure 13.7. Key Surface, Shape Outlines, and Bounding Box</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-13.svg"></object></div></div></div><br class="figure-break" /><p>
To determine the bounding box of the top surface of a shape, use
<code class="function">XkbComputeShapeTop</code>.
</p><a id="idm8093" class="indexterm"></a><div class="funcsynopsis"><a id="XkbComputeShapeTop"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbComputeShapeTop</strong>(</code>XkbShapePtr <var class="pdparam">shape</var>, XkbBoundsPtr <var class="pdparam">bounds_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>shape</code></em>
    </span></p></td><td><p>
        shape to be examined
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>bounds_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with the bounding box for the shape
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbComputeShapeTop</code>
returns a
<span class="structname">BoundsRec</span>
that contains two x and y coordinates. These coordinates describe the corners
of a rectangle that contains the outline that describes the top surface of the
shape. The top surface is defined to be the approximating outline if the
<em class="structfield"><code>approx</code></em>
field of
<em class="parameter"><code>shape</code></em>
is not
<span class="symbol">NULL</span>.
If
<em class="structfield"><code>approx</code></em>
is
<span class="symbol">NULL</span>,
the top surface is defined as the last outline in the
<em class="parameter"><code>shape</code></em>’s
array of outlines.
<code class="function">XkbComputeShapeTop</code>
returns
<span class="symbol">False</span>
if
<em class="parameter"><code>shape</code></em>
is
<span class="symbol">NULL</span>
or if there are no outlines for the shape; otherwise, it returns
<span class="symbol">True</span>.
</p><p>
A
<span class="structname">ShapeRec</span>
contains a
<span class="structname">BoundsRec</span>
that describes the bounds of the shape. If you add or delete an outline to or
from a shape, the bounding box must be updated. To update the bounding box of a
shape, use <code class="function">XkbComputeShapeBounds</code>.
</p><a id="idm8133" class="indexterm"></a><div class="funcsynopsis"><a id="XkbComputeShapeBounds"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbComputeShapeBounds</strong>(</code>XkbShapePtr <var class="pdparam">shape</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>shape</code></em>
    </span></p></td><td><p>
        shape to be examined
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbComputeShapeBounds</code>
updates the
<span class="structname">BoundsRec</span>
contained in the
<em class="parameter"><code>shape</code></em>
by examining all the outlines of the shape and setting the
<span class="structname">BoundsRec</span>
to the minimum x and minimum y, and maximum x and maximum y values found in
those outlines.
<code class="function">XkbComputeShapeBounds</code>
returns
<span class="symbol">False</span>
if
<em class="parameter"><code>shape</code></em>
is
<span class="symbol">NULL</span>
or if there are no outlines for the shape; otherwise, it returns
<span class="symbol">True</span>.
</p><p>
If you add or delete a key to or from a row, or if you update the shape of one
of the keys in that row, you may need to update the bounding box of that row.
To update the bounding box of a row, use <code class="function">XkbComputeRowBounds</code>.
</p><a id="idm8160" class="indexterm"></a><div class="funcsynopsis"><a id="XkbComputeRowBounds"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbComputeRowBounds</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, XkbSectionPtr <var class="pdparam">section</var>, XkbRowPtr <var class="pdparam">row</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry that contains the <em class="parameter"><code>section</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section that contains the row
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        row to be examined and updated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbComputeRowBounds</code>
checks the bounds of all keys in the
<em class="parameter"><code>row</code></em>
and updates the bounding box of the row if necessary.
<code class="function">XkbComputeRowBounds</code>
returns
<span class="symbol">False</span>
if any of the arguments is
<span class="symbol">NULL</span>;
otherwise, it returns
<span class="symbol">True</span>.
</p><p>
If you add or delete a row to or from a section, or if you change the geometry
of any of the rows in that section, you may need to update the bounding box for
that section. To update the bounding box of a section, use
<code class="function">XkbComputeSectionBounds</code>.
</p><a id="idm8199" class="indexterm"></a><div class="funcsynopsis"><a id="XkbComputeSectionBounds"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbComputeSectionBounds</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, XkbSectionPtr <var class="pdparam">section</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry that contains the <em class="parameter"><code>section</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section to be examined and updated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbComputeSectionBounds</code>
examines all the rows of the
<em class="parameter"><code>section</code></em>
and updates the bounding box of that section so that it contains all rows.
<code class="function">XkbComputeSectionBounds</code>
returns
<span class="symbol">False</span>
if any of the arguments is
<span class="symbol">NULL</span>;
otherwise, it returns
<span class="symbol">True</span>.
</p><p>
Keys that can generate multiple keycodes may be associated with multiple names.
Such keys have a primary name and an alternate name. To find the alternate name
by using the primary name for a key that is part of an overlay, use
<code class="function">XkbFindOverlayForKey</code>.
</p><a id="idm8231" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFindOverlayForKey"></a><p><code class="funcdef">char *<strong class="fsfunc">XkbFindOverlayForKey</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, XkbSectionPtr <var class="pdparam">section</var>, char *<var class="pdparam">under</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry that contains the <em class="parameter"><code>section</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section to be searched for matching keys
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>under</code></em>
    </span></p></td><td><p>
        .primary name of the key to be considered
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbFindOverlayForKey</code>
uses the primary name of the key,
<em class="parameter"><code>under</code></em>,
to look up the alternate name, which it returns.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Adding_Elements_to_a_Keyboard_Geometry"></a>Adding Elements to a Keyboard Geometry</h2></div></div></div><p>
Xkb provides functions to add a single new element to the top-level keyboard
geometry. In each case the
<em class="structfield"><code>num_<em class="replaceable"><code>*</code></em></code></em>
fields of the corresponding structure is incremented by 1. These functions do
not change
<em class="structfield"><code>sz_<em class="replaceable"><code>*</code></em></code></em>
unless there is no more room in the array. Some of these functions fill in the
values of the element’s structure from the arguments. For other functions,
you must explicitly write code to fill the structure’s elements.
</p><p>
The top-level geometry description includes a list of
<em class="firstterm">geometry properties</em>.
A geometry property associates an arbitrary string with an equally arbitrary
name. Programs that display images of keyboards can use geometry properties as
hints, but they are not interpreted by Xkb. No other geometry structures refer
to geometry properties.
</p><p>
To add one property to an existing keyboard geometry description, use
<code class="function">XkbAddGeomProperty</code>.
</p><a id="idm8275" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomProperty"></a><p><code class="funcdef">XkbPropertyPtr <strong class="fsfunc">XkbAddGeomProperty</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, char *<var class="pdparam">name</var>, char *<var class="pdparam">value</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the new property
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>value</code></em>
    </span></p></td><td><p>
        value for the new property
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddGeomProperty</code>
adds one property with the specified
<em class="parameter"><code>name</code></em>
and
<em class="parameter"><code>value</code></em>
to the keyboard geometry specified by geom.
<code class="function">XkbAddGeomProperty</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the property. To allocate space for an arbitrary number of properties, use the
XkbAllocGeomProps function.
</p><p>
To add one key alias to an existing keyboard geometry description, use
<code class="function">XkbAddGeomKeyAlias</code>.
</p><a id="idm8312" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomKeyAlias"></a><p><code class="funcdef">XkbKeyAliasPtr <strong class="fsfunc">XkbAddGeomKeyAlias</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, char *<var class="pdparam">alias</var>, char *<var class="pdparam">real</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>alias</code></em>
    </span></p></td><td><p>
        alias to be added
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>real</code></em>
    </span></p></td><td><p>
        real name to be bound to the new alias
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddGeomKeyAlias</code>
adds one key alias with the value alias to the geometry geom, and associates
it with the key whose real name is real.
<code class="function">XkbAddGeomKeyAlias</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the alias. To allocate space for an arbitrary number of aliases, use the
XkbAllocGeomKeyAliases function.
</p><p>
To add one color name to an existing keyboard geometry description, use
<code class="function">XkbAddGeomColor</code>.
</p><a id="idm8347" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomColor"></a><p><code class="funcdef">XkbColorPtr <strong class="fsfunc">XkbAddGeomColor</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, char *<var class="pdparam">spec</var>, unsigned int <var class="pdparam">pixel</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>spec</code></em>
    </span></p></td><td><p>
        color to be added
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>pixel</code></em>
    </span></p></td><td><p>
        color to be added
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddGeomColor</code>
adds the specified color
<em class="structfield"><code>name</code></em>
and
<em class="parameter"><code>pixel</code></em>
to the specified geometry
<em class="parameter"><code>geom</code></em>.
The top-level geometry description includes a list of up to
<span class="emphasis"><em>MaxColors</em></span>
(32)
<span class="emphasis"><em>color names</em></span>.
A color
<em class="structfield"><code>name</code></em>
is a string whose interpretation is not specified by Xkb and neither is the
<em class="parameter"><code>pixel</code></em>
value’s interpretation. All other geometry data structures refer to colors
using their indices in this global list or pointers to colors in this list.
<code class="function">XkbAddGeomColor</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the color. To allocate space for an arbitrary number of colors to a geometry,
use the
<code class="function">XkbAllocGeomColors</code>
function.
</p><p>
To add one outline to an existing shape, use
<code class="function">XkbAddGeomOutline</code>.
</p><a id="idm8390" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomOutline"></a><p><code class="funcdef">XkbOutlinePtr <strong class="fsfunc">XkbAddGeomOutline</strong>(</code>XkbShapePtr <var class="pdparam">shape</var>, int <var class="pdparam">sz_points</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>shape</code></em>
    </span></p></td><td><p>
        shape to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_points</code></em>
    </span></p></td><td><p>
        number of points to be reserved
      </p></td></tr></tbody></table></div><p>
An outline consists of an arbitrary number of points.
<code class="function">XkbAddGeomOutline</code>
adds an outline to the specified
<em class="parameter"><code>shape</code></em>
by reserving
<em class="parameter"><code>sz_points</code></em>
points for it. The new outline is allocated and zeroed.
<code class="function">XkbAddGeomOutline</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space. To
allocate space for an arbitrary number of outlines to a shape, use
XkbAllocGeomOutlines.
</p><p>
To add a shape to a keyboard geometry, use
<code class="function">XkbAddGeomShape</code>.
</p><a id="idm8420" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomShape"></a><p><code class="funcdef">XkbShapePtr <strong class="fsfunc">XkbAddGeomShape</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, Atom <var class="pdparam">name</var>, int <var class="pdparam">sz_outlines</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the new shape
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_outlines</code></em>
    </span></p></td><td><p>
        number of outlines to be reserved
      </p></td></tr></tbody></table></div><p>
A geometry contains an arbitrary number of shapes, each of which is made up of
an arbitrary number of outlines.
<code class="function">XkbAddGeomShape</code>
adds a shape to a geometry
<em class="parameter"><code>geom</code></em>
by allocating space for
<em class="parameter"><code>sz_outlines</code></em>
outlines for it and giving it the name specified by name. If a shape with name
<em class="parameter"><code>name</code></em>
already exists in the geometry, a pointer to the existing shape is returned.
<code class="function">XkbAddGeomShape</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space. To
allocate space for an arbitrary number of geometry shapes, use
<code class="function">XkbAllocGeomShapes</code>.
</p><p>
To add one key at the end of an existing row of keys, use
<code class="function">XkbAddGeomKey</code>.
</p><a id="idm8459" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomKey"></a><p><code class="funcdef">XkbKeyPtr <strong class="fsfunc">XkbAddGeomKey</strong>(</code>XkbRowPtr <var class="pdparam">row</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        row to be updated
      </p></td></tr></tbody></table></div><p>
Keys are grouped into rows.
<code class="function">XkbAddGeomKey</code>
adds one key to the end of the specified
<em class="parameter"><code>row</code></em>.
The key is allocated and zeroed.
<code class="function">XkbAddGeomKey</code>
returns
<span class="symbol">NULL</span>
if
<em class="parameter"><code>row</code></em>
is empty or if it was not able to allocate space for the key. To allocate
space for an arbitrary number of keys to a row, use XkbAllocGeomKeys.
</p><p>
To add one section to an existing keyboard geometry, use
<code class="function">XkbAddGeomSection</code>.
</p><a id="idm8482" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomSection"></a><p><code class="funcdef">XkbSectionPtr <strong class="fsfunc">XkbAddGeomSection</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, Atom <var class="pdparam">name</var>, int <var class="pdparam">sz_rows</var>, int <var class="pdparam">sz_doodads</var>, int <var class="pdparam">sz_overlays</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the new section
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_rows</code></em>
    </span></p></td><td><p>
        number of rows to reserve in the section
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_doodads</code></em>
    </span></p></td><td><p>
        number of doodads to reserve in the section
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_overlays</code></em>
    </span></p></td><td><p>
        number of overlays to reserve in the section
      </p></td></tr></tbody></table></div><p>
A keyboard geometry contains an arbitrary number of sections.
<code class="function">XkbAddGeomSection</code>
adds one section to an existing keyboard geometry
<em class="parameter"><code>geom</code></em>.
The new section contains space for the number of rows, doodads, and overlays
specified by
<em class="parameter"><code>sz_rows</code></em>,
<em class="parameter"><code>sz_doodads</code></em>,
and
<em class="parameter"><code>sz_overlays</code></em>.
The new section is allocated and zeroed and given the name specified by
<em class="parameter"><code>name</code></em>.
If a section with name
<em class="parameter"><code>name</code></em>
already exists in the geometry, a pointer to the existing section is
returned.
<code class="function">XkbAddGeomSection</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the section. To allocate space for an arbitrary number of sections to a
geometry, use XkbAllocGeomSections.
</p><p>
To add a row to a section, use
<code class="function">XkbAddGeomRow</code>.
</p><a id="idm8537" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomRow"></a><p><code class="funcdef">XkbRowPtr <strong class="fsfunc">XkbAddGeomRow</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, int <var class="pdparam">sz_keys</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_keys</code></em>
    </span></p></td><td><p>
        number of keys to be reserved
      </p></td></tr></tbody></table></div><p>
One of the components of a keyboard geometry section is one or more rows of
keys.
<code class="function">XkbAddGeomRow</code>
adds one row to the specified
<em class="parameter"><code>section</code></em>.
The newly created row contains space for the number of keys specified in
<em class="parameter"><code>sz_keys</code></em>.
They are allocated and zeroed, but otherwise uninitialized.
<code class="function">XkbAddGeomRow</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the row. To allocate space for an arbitrary number of rows to a section, use
the XkbAllocGeomRows function.
</p><p>
To add one doodad to a section of a keyboard geometry or to the top-level
geometry, use
<code class="function">XkbAddGeomDoodad</code>.
</p><a id="idm8567" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomDoodad"></a><p><code class="funcdef">XkbDoodadPtr <strong class="fsfunc">XkbAddGeomDoodad</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, XkbSectionPtr <var class="pdparam">section</var>, Atom <var class="pdparam">name</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to which the doodad is added
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section, if any, to which the doodad is added
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the new doodad
      </p></td></tr></tbody></table></div><p>
A
<em class="structfield"><code>doodad</code></em>
describes some visible aspect of the keyboard that is not a key and is not a
section.
<code class="function">XkbAddGeomDoodad</code>
adds a doodad with name specified by name to the geometry
<em class="parameter"><code>geom</code></em>
if section is
<span class="symbol">NULL</span>
or to the section of the geometry specified by section if
<em class="parameter"><code>section</code></em>
is not
<span class="symbol">NULL</span>.
<code class="function">XkbAddGeomDoodad</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the doodad. If there is already a doodad with the name
<em class="parameter"><code>name</code></em>
in the doodad array for the geometry (if
<em class="parameter"><code>section</code></em>
is
<span class="symbol">NULL</span>)
or the section (if
<em class="parameter"><code>section</code></em>
is non-
<span class="symbol">NULL</span>),
a pointer to that doodad is returned. To allocate space for an arbitrary
number of doodads to a section, use the XkbAllocGeomSectionDoodads function. To
allocate space for an arbitrary number of doodads to a keyboard geometry, use
the XkbAllocGeomDoodads function.
</p><p>
To add one overlay to a section, use
<code class="function">XkbAddGeomOverlay</code>.
</p><a id="idm8612" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomOverlay"></a><p><code class="funcdef">XkbOverlayPtr <strong class="fsfunc">XkbAddGeomOverlay</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, Atom <var class="pdparam">name</var>, int <var class="pdparam">sz_rows</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section to which an overlay will be added
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>name</code></em>
    </span></p></td><td><p>
        name of the overlay
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_rows</code></em>
    </span></p></td><td><p>
        number of rows to reserve in the overlay
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddGeomOverlay</code>
adds an overlay with the specified name to the specified
<em class="parameter"><code>section</code></em>.
The new overlay is created with space allocated for sz_rows rows. If an
overlay with name
<em class="parameter"><code>name</code></em>
already exists in the section, a pointer to the existing overlay is
returned.
<code class="function">XkbAddGeomOverlay</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the overlay. To allocate space for an arbitrary number of overlays to a
section, use the XkbAllocGeomOverlay function.
</p><p>
To add a row to an existing overlay, use
<code class="function">XkbAddGeomOverlayRow</code>.
</p><a id="idm8649" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomOverlayRow"></a><p><code class="funcdef">XkbOverlayRowPtr <strong class="fsfunc">XkbAddGeomOverlayRow</strong>(</code>XkbOverlayPtr <var class="pdparam">overlay</var>, XkbRowPtr <var class="pdparam">row_under</var>, int <var class="pdparam">sz_keys</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>overlay</code></em>
    </span></p></td><td><p>
        overlay to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>row_under</code></em>
    </span></p></td><td><p>
        row to be overlayed in the section <em class="parameter"><code>overlay</code></em>
         overlays
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_keys</code></em>
    </span></p></td><td><p>
        number of keys to reserve in the row
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddGeomOverlayRow</code>
adds one row to the
<em class="parameter"><code>overlay</code></em>.
The new row contains space for
<em class="parameter"><code>sz_keys</code></em>
keys. If
<em class="parameter"><code>row_under</code></em>
specifies a row that doesn’t exist on the underlying section,
<code class="function">XkbAddGeomOverlayRow</code>
returns
<span class="symbol">NULL</span>
and doesn’t change the overlay.
<code class="function">XkbAddGeomOverlayRow</code>
returns
<span class="symbol">NULL</span>
if any of the parameters is empty or if it was not able to allocate space for
the overlay.
</p><p>
To add a key to an existing overlay row, use
<code class="function">XkbAddGeomOverlayKey</code>.
</p><a id="idm8690" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddGeomOverlayKey"></a><p><code class="funcdef">XkbOverlayKeyPtr <strong class="fsfunc">XkbAddGeomOverlayKey</strong>(</code>XkbOverlayPtr <var class="pdparam">overlay</var>, XkbRowPtr <var class="pdparam">row</var>, char *<var class="pdparam">under</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>overlay</code></em>
    </span></p></td><td><p>
        overlay to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        row in overlay to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>under</code></em>
    </span></p></td><td><p>
        primary name of the key to be considered
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddGeomOverlayKey</code>
adds one key to the
<em class="parameter"><code>row</code></em>
in the
<em class="parameter"><code>overlay</code></em>.
If there is no key named
<em class="parameter"><code>under</code></em>
in the row of the underlying section,
<code class="function">XkbAddGeomOverlayKey</code>
returns
<span class="symbol">NULL</span>.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_Geometry_Components"></a>Allocating and Freeing Geometry Components</h2></div></div></div><p>
Xkb provides a number of functions to allocate and free subcomponents of a
keyboard geometry. Use these functions to create or modify keyboard geometries.
Note that these functions merely allocate space for the new element(s), and it
is up to you to fill in the values explicitly in your code. These allocation
functions increase
<em class="structfield"><code>sz_<em class="replaceable"><code>*</code></em></code></em>
but never touch
<em class="structfield"><code>num_<em class="replaceable"><code>*</code></em></code></em>
(unless there is an allocation failure, in which case they reset both
<em class="structfield"><code>sz_<em class="replaceable"><code>*</code></em></code></em>
and
<em class="structfield"><code>num_<em class="replaceable"><code>*</code></em></code></em>
to zero). These functions return
<span class="symbol">Success</span>
if they succeed,
<span class="errorname">BadAlloc</span>
if they are not able to allocate space, or
<span class="errorname">BadValue</span>
if a parameter is not as expected.
</p><p>
To allocate space for an arbitrary number of outlines to a shape, use
XkbAllocGeomOutlines.
</p><a id="idm8741" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomOutlines"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomOutlines</strong>(</code>XkbShapePtr <var class="pdparam">shape</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>shape</code></em>
    </span></p></td><td><p>
        shape for which outlines should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new outlines required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomOutlines</code>
allocates space for
<em class="parameter"><code>num_needed</code></em>
outlines in the specified
<em class="parameter"><code>shape</code></em>.
The outlines are not initialized.
</p><p>
To free geometry outlines, use
<code class="function">XkbFreeGeomOutlines</code>.
</p><a id="idm8769" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomOutlines"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomOutlines</strong>(</code>XkbShapePtr <var class="pdparam">shape</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>shape</code></em>
    </span></p></td><td><p>
        shape in which outlines should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first outline to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of outlines to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all outlines are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all outlines are freed regardless of the value of first or count. Otherwise,
count outlines are freed beginning with the one specified by first.
</p><p>
To allocate space for an arbitrary number of keys to a row, use
XkbAllocGeomKeys.
</p><a id="idm8809" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomKeys"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomKeys</strong>(</code>XkbRowPtr <var class="pdparam">row</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        row to which keys should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new keys required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomKeys</code>
allocates num_needed keys and adds them to the row. No initialization of the
keys is done.
</p><p>
To free geometry keys, use
<code class="function">XkbFreeGeomKeys</code>.
</p><a id="idm8835" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomKeys"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomKeys</strong>(</code>XkbRowPtr <var class="pdparam">row</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        row in which keys should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first key to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of keys to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all keys are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all keys are freed regardless of the value of first or count. Otherwise,
count keys are freed beginning with the one specified by first.
</p><p>
To allocate geometry properties, use
<code class="function">XkbAllocGeomProps</code>.
</p><a id="idm8876" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomProps"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomProps</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry for which properties should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new properties required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomProps</code>
allocates space for num_needed properties and adds them to the specified
geometry
<em class="parameter"><code>geom</code></em>.
No initialization of the properties is done. A geometry property associates
an arbitrary string with an equally arbitrary name. Geometry properties can be
used to provide hints to programs that display images of keyboards, but they
are not interpreted by Xkb. No other geometry structures refer to geometry
properties.
</p><p>
To free geometry properties, use
<code class="function">XkbFreeGeomProperties</code>.
</p><a id="idm8903" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomProperties"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomProperties</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry in which properties should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first property to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of properties to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all properties are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all properties are freed regardless of the value of first or count.
Otherwise, count properties are freed beginning with the one specified by first.
</p><p>
To allocate geometry key aliases, use
<code class="function">XkbAllocGeomKeyAliases</code>.
</p><a id="idm8944" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomKeyAliases"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomKeyAliases</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry for which key aliases should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new key aliases required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomKeyAliases</code>
allocates space for num_needed key aliases and adds them to the specified
geometry
<em class="parameter"><code>geom</code></em>.
A key alias is a pair of strings that associates an alternate name for a key
with the real name for that key.
</p><p>
To free geometry key aliases, use
<code class="function">XkbFreeGeomKeyAliases</code>.
</p><a id="idm8971" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomKeyAliases"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomKeyAliases</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry in which key aliases should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first key alias to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of key aliases to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all key aliases are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all aliases in the top level of the specified geometry
<em class="parameter"><code>geom</code></em>
are freed regardless of the value of first or count. Otherwise, count aliases
in
<em class="parameter"><code>geom</code></em>
are freed beginning with the one specified by first.
</p><p>
To allocate geometry colors, use
<code class="function">XkbAllocGeomColors</code>.
</p><a id="idm9014" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomColors"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomColors</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry for which colors should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new colors required.
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomColors</code>
allocates space for num_needed colors and adds them to the specified geometry
<em class="parameter"><code>geom</code></em>.
A color name is a string whose interpretation is not specified by Xkb. All
other geometry data structures refer to colors using their indices in this
global list or pointers to colors in this list.
</p><p>
To free geometry colors, use
<code class="function">XkbFreeGeomColors</code>.
</p><a id="idm9041" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomColors"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomColors</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry in which colors should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first color to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of colors to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all colors are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all colors are freed regardless of the value of first or count. Otherwise,
count colors are freed beginning with the one specified by first.
</p><p>
To allocate points in an outline, use
<code class="function">XkbAllocGeomPoints</code>.
</p><a id="idm9082" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomPoints"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomPoints</strong>(</code>XkbOutlinePtr <var class="pdparam">outline</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>outline</code></em>
    </span></p></td><td><p>
        outline for which points should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new points required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomPoints</code>
allocates space for
<em class="parameter"><code>num_needed</code></em>
points in the specified
<em class="parameter"><code>outline</code></em>.
The points are not initialized.
</p><p>
To free points in a outline, use
<code class="function">XkbFreeGeomPoints</code>.
</p><a id="idm9110" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomPoints"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomPoints</strong>(</code>XkbOutlinePtr <var class="pdparam">outline</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>outline</code></em>
    </span></p></td><td><p>
        outline in which points should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first point to be freed.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of points to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all points are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all points are freed regardless of the value of first and count. Otherwise,
the number of points specified by count are freed, beginning with the point
specified by first in the specified outline.
</p><p>
To allocate space for an arbitrary number of geometry shapes, use
<code class="function">XkbAllocGeomShapes</code>.
</p><a id="idm9151" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomShapes"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomShapes</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry for which shapes should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new shapes required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomShapes</code>
allocates space for
<em class="parameter"><code>num_needed</code></em>
shapes in the specified geometry
<em class="parameter"><code>geom</code></em>.
The shapes are not initialized.
</p><p>
To free geometry shapes, use
<code class="function">XkbFreeGeomShapes</code>.
</p><a id="idm9179" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomShapes"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomShapes</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry in which shapes should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first shape to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of shapes to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all shapes are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all shapes in the geometry are freed regardless of the values of first and
count. Otherwise, count shapes are freed, beginning with the shape specified by
first.
</p><p>
To allocate geometry sections, use
<code class="function">XkbAllocGeomSections</code>.
</p><a id="idm9220" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomSections"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomSections</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry for which sections should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new sections required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomSections</code>
allocates num_needed sections and adds them to the geometry geom. No
initialization of the sections is done.
</p><p>
To free geometry sections, use
<code class="function">XkbFreeGeomSections</code>.
</p><a id="idm9246" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomSections"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomSections</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry in which sections should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first section to be freed.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of sections to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all sections are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all sections are freed regardless of the value of first and count. Otherwise,
the number of sections specified by count are freed, beginning with the section
specified by first in the specified geometry.
</p><p>
To allocate rows in a section, use
<code class="function">XkbAllocGeomRows</code>.
</p><a id="idm9287" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomRows"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomRows</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section for which rows should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new rows required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomRows</code>
allocates num_needed rows and adds them to the section. No initialization of
the rows is done.
</p><p>
To free rows in a section, use
<code class="function">XkbFreeGeomRows</code>.
</p><a id="idm9313" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomRows"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomRows</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section in which rows should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first row to be freed.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of rows to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all rows are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all rows are freed regardless of the value of first and count. Otherwise, the
number of rows specified by count are freed, beginning with the row specified
by first in the specified section.
</p><p>
To allocate overlays in a section, use
<code class="function">XkbAllocGeomOverlays</code>.
</p><a id="idm9354" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomOverlays"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomOverlays</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section for which overlays should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new overlays required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomRows</code>
allocates num_needed overlays and adds them to the section. No initialization
of the overlays is done.
</p><p>
To free rows in an section, use
<code class="function">XkbFreeGeomOverlays</code>.
</p><a id="idm9380" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomOverlays"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomOverlays</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section in which overlays should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first overlay to be freed.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of overlays to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all overlays are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all overlays are freed regardless of the value of first and count. Otherwise,
the number of overlays specified by count are freed, beginning with the overlay
specified by first in the specified section.
</p><p>
To allocate rows in a overlay, use
<code class="function">XkbAllocGeomOverlayRows</code>.
</p><a id="idm9421" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomOverlayRows"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomOverlayRows</strong>(</code>XkbSectionPtr <var class="pdparam">overlay</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>overlay</code></em>
    </span></p></td><td><p>
        section for which rows should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new rows required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomOverlayRows</code>
allocates num_needed rows and adds them to the overlay. No initialization of
the rows is done.
</p><p>
To free rows in an overlay, use
<code class="function">XkbFreeGeomOverlayRows</code>.
</p><a id="idm9447" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomOverlayRows"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomOverlayRows</strong>(</code>XkbSectionPtr <var class="pdparam">overlay</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>overlay</code></em>
    </span></p></td><td><p>
        section in which rows should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first row to be freed.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of rows to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all rows are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all rows are freed regardless of the value of first and count. Otherwise, the
number of rows specified by count are freed, beginning with the row specified
by first in the specified overlay.
</p><p>
To allocate keys in an overlay row, use
<code class="function">XkbAllocGeomOverlayKeys</code>.
</p><a id="idm9488" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomOverlayKeys"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomOverlayKeys</strong>(</code>XkbRowPtr <var class="pdparam">row</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        section for which rows should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new rows required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomOverlayKeys</code>
allocates num_needed keys and adds them to the row. No initialization of the
keys is done.
</p><p>
To free keys in an overlay row, use
<code class="function">XkbFreeGeomOverlayKeys</code>.
</p><a id="idm9514" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomOverlayKeys"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomOverlayKeys</strong>(</code>XkbRowPtr <var class="pdparam">row</var>, int <var class="pdparam">first</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>row</code></em>
    </span></p></td><td><p>
        row in which keys should be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        first key to be freed.
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of keys to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all keys are freed
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
all keys are freed regardless of the value of first and count. Otherwise, the
number of keys specified by count are freed, beginning with the key specified
by first in the specified row.
</p><p>
To allocate doodads that are global to a keyboard geometry, use
<code class="function">XkbAllocGeomDoodads</code>.
</p><a id="idm9555" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomDoodads"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomDoodads</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry for which doodads should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new doodads required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomDoodads</code>
allocates num_needed doodads and adds them to the specified geometry
<em class="parameter"><code>geom</code></em>.
No initialization of the doodads is done.
</p><p>
To allocate doodads that are specific to a section, use
<code class="function">XkbAllocGeomSectionDoodads</code>.
</p><a id="idm9582" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeomSectionDoodads"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeomSectionDoodads</strong>(</code>XkbSectionPtr <var class="pdparam">section</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>section</code></em>
    </span></p></td><td><p>
        section for which doodads should be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of new doodads required
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeomSectionDoodads</code>
allocates num_needed doodads and adds them to the specified
<em class="parameter"><code>section</code></em>.
No initialization of the doodads is done.
</p><p>
To free geometry doodads, use
<code class="function">XkbFreeGeomDoodads</code>.
</p><a id="idm9609" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeomDoodads"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeomDoodads</strong>(</code>XkbDoodadPtr <var class="pdparam">doodads</var>, int <var class="pdparam">count</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>doodads</code></em>
    </span></p></td><td><p>
        doodads to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count</code></em>
    </span></p></td><td><p>
        number of doodads to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ all doodads are freed
      </p></td></tr></tbody></table></div><p>
If
<em class="parameter"><code>free_all</code></em>
is
<span class="symbol">True</span>,
all doodads in the array are freed, regardless of the value of count.
Otherwise, count doodads are freed.
</p><p>
To allocate an entire geometry, use
<code class="function">XkbAllocGeometry</code>.
</p><a id="idm9644" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocGeometry"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocGeometry</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, XkbGeometrySizesPtr <var class="pdparam">sizes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description for which geometry is to be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sizes</code></em>
    </span></p></td><td><p>
        initial sizes for all geometry components
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocGeometry</code>
allocates a keyboard geometry and adds it to the keyboard description
specified by xkb. The keyboard description should be obtained via the
XkbGetKeyboard or XkbAllockeyboard functions. The sizes parameter specifies the
number of elements to be reserved for the subcomponents of the keyboard
geometry and can be zero or more. These subcomponents include the properties,
colors, shapes, sections, and doodads.
</p><p>
To free an entire geometry, use
<code class="function">XkbFreeGeometry</code>.
</p><a id="idm9670" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeGeometry"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeGeometry</strong>(</code>XkbGeometryPtr <var class="pdparam">geom</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>geom</code></em>
    </span></p></td><td><p>
        geometry to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of geometry components to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ the entire geometry is freed.
      </p></td></tr></tbody></table></div><p>
The values of which and free_all determine how much of the specified geometry
is freed. The valid values for which are:

</p><pre class="programlisting">
#define      XkbGeomPropertiesMask  (1&lt;&lt;0)
#define      XkbGeomColorsMask      (1&lt;&lt;1)
#define      XkbGeomShapesMask      (1&lt;&lt;2)
#define      XkbGeomSectionsMask    (1&lt;&lt;3)
#define      XkbGeomDoodadsMask     (1&lt;&lt;4)
#define      XkbGeomAllMask         (0x1f)
</pre><p>
If free_all is
<span class="symbol">True</span>,
the entire geometry is freed regardless of the value of which. Otherwise, the
portions of the geometry specified by which are freed.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Xkb_Keyboard_Mapping"></a>Chapter 14. Xkb Keyboard Mapping</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Notation_and_Terminology">Notation and Terminology</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Core_Implementation">Core Implementation</a></span></dt><dt><span class="sect2"><a href="#Xkb_Implementation">Xkb Implementation</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Map_Components_from_the_Server">Getting Map Components from the Server</a></span></dt><dt><span class="sect1"><a href="#Changing_Map_Components_in_the_Server">Changing Map Components in the Server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_XkbMapChangesRec_Structure">The XkbMapChangesRec Structure</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Changes_to_Map_Components">Tracking Changes to Map Components</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Client_and_Server_Maps">Allocating and Freeing Client and Server Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Allocating_an_Empty_Client_Map">Allocating an Empty Client Map</a></span></dt><dt><span class="sect2"><a href="#Freeing_a_Client_Map">Freeing a Client Map</a></span></dt><dt><span class="sect2"><a href="#Allocating_an_Empty_Server_Map">Allocating an Empty Server Map</a></span></dt><dt><span class="sect2"><a href="#Freeing_a_Server_Map">Freeing a Server Map</a></span></dt></dl></dd></dl></div><p>
The Xkb keyboard mapping contains all the information the server and clients
need to interpret key events. This chapter provides an overview of the
terminology used to describe an Xkb keyboard mapping and introduces common
utilities for manipulating the keyboard mapping.
</p><p>
The mapping consists of two components, a server map and a client map. The
<em class="firstterm">client map</em>
<a id="idm9709" class="indexterm"></a>
<a id="idm9711" class="indexterm"></a>
is the collection of information a client needs to interpret key events
from the keyboard. It contains a global list of key types and an array of key
symbol maps, each of which describes the symbols bound to a key and the rules
to be used to interpret those symbols. The
<em class="firstterm">server map</em>
<a id="idm9715" class="indexterm"></a>
<a id="idm9717" class="indexterm"></a>
contains the information the server needs to interpret key events. This
includes actions and behaviors for each key, explicit components for a key, and
the virtual modifiers and the per-key virtual modifier mapping.
</p><p>
For detailed information on particular components of the keyboard map, refer to
<a class="xref" href="#Xkb_Client_Keyboard_Mapping" title="Chapter 15. Xkb Client Keyboard Mapping">Chapter 15, <em>Xkb Client Keyboard Mapping</em></a>, and
<a class="xref" href="#Xkb_Server_Keyboard_Mapping" title="Chapter 16. Xkb Server Keyboard Mapping">Chapter 16, <em>Xkb Server Keyboard Mapping</em></a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Notation_and_Terminology"></a>Notation and Terminology</h2></div></div></div><a id="idm9725" class="indexterm"></a><a id="idm9727" class="indexterm"></a><p>
The graphic characters or control functions that may be accessed by one key are
logically arranged in groups and levels, where
<em class="structfield"><code>group</code></em>
and
<em class="structfield"><code>level</code></em>
are defined as in the ISO9995 standard:
</p><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">Group:</span></p></td><td><p>
A logical state of a keyboard providing access to a collection of
graphic characters. Usually these graphic characters logically belong together
and may be arranged on several levels within a group.
      </p></td></tr><tr><td><p><span class="term">Level:</span></p></td><td><p>
One of several states (normally 2 or 3) governing which graphic
character is produced when a graphic key is actuated. In certain cases the
level may also affect function keys.
      </p></td></tr></tbody></table></div><p>
These definitions, taken from the ISO standard, refer to graphic keys and
characters. In the context of Xkb, Group and Level are not constrained to
graphic keys and characters; they may be used with any key to access any
character the key is capable of generating.
</p><p>
Level is often referred to as <span class="quote">“<span class="quote">Shift Level</span>”</span>.
Levels are numbered sequentially starting at one.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Shift level is derived from the modifier state, but not necessarily
in the same way for all keys. For example, the
<span class="symbol">Shift</span>
modifier selects shift level 2 on most keys, but for keypad keys the modifier
bound to
<span class="keysym">Num_Lock</span>
(that is, the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier) also selects shift level 2.</p></div><p>
For example, consider the following key (the gray characters indicate symbols
that are implied or expected but are not actually engraved on the key):
</p><div class="figure"><a id="figure14.1"></a><p class="title"><strong>Figure 14.1. Shift Levels and Groups</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-14.svg"></object></div></div></div><br class="figure-break" /><p>
This key has two groups, indicated by the columns, and each group has two shift
levels. For the first group (Group1), the symbol shift level one is
<span class="keysym">a</span>,
and the symbol for shift level two is
<span class="keysym">A</span>.
For the second group, the symbol for shift level one is
<span class="keysym">æ</span>,
and the symbol for shift level two is
<span class="keysym">Æ</span>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Core_Implementation"></a>Core Implementation</h3></div></div></div><p>
The standard interpretation rules for the core X keymap only allow clients to
access keys such as the one shown in <a class="link" href="#figure14.1" title="Figure 14.1. Shift Levels and Groups">Figure 14.1</a>. That is, clients using the
standard interpretation rules can only access one of four keysyms for any given
<span class="symbol">KeyPress</span>
event — two different symbols in two different groups.
</p><p>
In general, the
<span class="symbol">Shift</span>
modifier, the
<span class="symbol">Lock</span>
modifier, and the modifier bound to the
<span class="keysym">Num_Lock</span>
key are used to change between shift level 1 and shift level 2. To switch
between groups, the core implementation uses the modifier bound to the
<span class="keysym">Mode_switch</span>
key. When the
<span class="keysym">Mode_switch</span>
modifier is set, the keyboard is logically in Group 2. When the
<span class="keysym">Mode_switch</span>
modifier is not set, the keyboard is logically in Group 1.
</p><p>
The core implementation does not clearly specify the behavior of keys. For
example, the locking behavior of the
<span class="emphasis"><em>CapsLock</em></span>
and
<span class="keysym">Num_Lock</span>
keys depends on the vendor.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Xkb_Implementation"></a>Xkb Implementation</h3></div></div></div><p>
Xkb extends the core implementation by providing access to up to four keyboard
groups with up to 63 shift levels per key
<a href="#ftn.idm9778" class="footnote" id="idm9778"><sup class="footnote">[6]</sup></a>. In
addition, Xkb provides precise specifications regarding the behavior of keys.
In Xkb, modifier state and the current group are independent (with the
exception of compatibility mapping, discussed in <a class="xref" href="#The_Xkb_Compatibility_Map" title="Chapter 17. The Xkb Compatibility Map">Chapter 17, <em>The Xkb Compatibility Map</em></a>).
</p><p>
Xkb handles switching between groups via key actions, independent of any
modifier state information. Key actions are in the server map component and are
described in detail in <a class="link" href="#Actions_for_Changing_Group_State" title="Actions for Changing Group State">section 16.1.4</a>.
</p><p>
Xkb handles shift levels by associating a key type with each group on each key.
Each key type defines the shift levels available for the groups on keys of its
type and specifies the modifier combinations necessary to access each level.
</p><p>
For example, Xkb allows key types where the
<span class="symbol">Control</span>
modifier can be used to access the shift level two of a key. Key types are in
the client map component and are described in detail in <a class="link" href="#Key_Types" title="Key Types">section 15.2</a>.
</p><p>
Xkb provides precise specification of the behavior of a key using key
behaviors. Key behaviors are in the server map component and are described in
detail in <a class="link" href="#Key_Behavior" title="Key Behavior">section 16.2</a>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Getting_Map_Components_from_the_Server"></a>Getting Map Components from the Server</h2></div></div></div><p>
Xkb provides two functions to obtain the keyboard mapping components from the
server. The first function,
<code class="function">XkbGetMap</code>,
allocates an
<span class="structname">XkbDescRec</span>
structure, retrieves mapping components from the server, and stores them in
the
<span class="structname">XkbDescRec</span>
structure it just allocated. The second function,
<code class="function">XkbGetUpdatedMap</code>,
retrieves mapping components from the server and stores them in an
<span class="structname">XkbDescRec</span>
structure that has previously been allocated.
</p><p>
To allocate an
<span class="structname">XkbDescRec</span>
structure and populate it with the server’s keyboard client map and server
map, use
<code class="function">XkbGetMap</code>.
<code class="function">XkbGetMap</code>
is similar to
<code class="function">XkbGetKeyboard</code>
(see <a class="link" href="#Obtaining_a_Keyboard_Description_from_the_Server" title="Obtaining a Keyboard Description from the Server">section 6.2</a>), but is used only for obtaining the address of an
<span class="structname">XkbDescRec</span>
structure that is populated with keyboard mapping components. It allows finer
control over which substructures of the keyboard mapping components are to be
populated.
<code class="function">XkbGetKeyboard</code>
always returns fully populated components, while
<code class="function">XkbGetMap</code>
can be instructed to return a partially populated component.
</p><a id="idm9806" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetMap"></a><p><code class="funcdef">XkbDescPtr <strong class="fsfunc">XkbGetMap</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">device_spec</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask selecting subcomponents to populate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device_id, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>which</code></em>
mask is a bitwise inclusive OR of the masks defined in
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>. Only those
portions of the keyboard server map and the keyboard client maps that are
specified in
<em class="parameter"><code>which</code></em>
are allocated and populated.
</p><p>
In addition to allocating and obtaining the server map and the client map,
<code class="function">XkbGetMap</code>
also sets the
<em class="parameter"><code>device_spec</code></em>,
the
<em class="structfield"><code>min_key_code</code></em>,
and
<em class="structfield"><code>max_key_code</code></em>
fields of the keyboard description.
</p><p>
<code class="function">XkbGetMap</code>
is synchronous; it queries the server for the desired information, waits for a
reply, and then returns. If successful,
<code class="function">XkbGetMap</code>
returns a pointer to the
<span class="structname">XkbDescRec</span>
structure it allocated. If unsuccessful,
<code class="function">XkbGetMap</code>
returns
<span class="symbol">NULL</span>.
When unsuccessful, one of the following protocol errors is also generated:
<span class="errorname">BadAlloc</span>
(unable to allocate the
<span class="structname">XkbDescRec</span>
structure),
<span class="errorname">BadValue</span>
(some mask bits in
<em class="parameter"><code>which</code></em>
are undefined),
or
<span class="errorname">BadImplementation</span>
(a compatible version of the Xkb extension is not available in the server). To
free the returned data, use
<code class="function">XkbFreeClientMap</code>.
</p><p>
Xkb also provides convenience functions to get partial component definitions
from the server. These functions are specified in the
<span class="quote">“<span class="quote">convenience functions</span>”</span>
column in <a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>.
Refer to the sections listed in the table for more
information on these functions.
</p><div class="table"><a id="table14.1"></a><p class="title"><strong>Table 14.1. Xkb Mapping Component Masks and Convenience Functions</strong></p><div class="table-contents"><table class="table" summary="Xkb Mapping Component Masks and Convenience Functions" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /><col align="left" class="c5" /><col align="left" class="c6" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Value</th><th align="left">Map</th><th align="left">Fields</th><th align="left">Convenience Functions</th><th align="left">Section</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbKeyTypesMask</span></td><td align="left">(1&lt;&lt;0)</td><td align="left">client</td><td align="left">
      <p><em class="structfield"><code>types</code></em></p>
      <p><em class="structfield"><code>size_types</code></em></p>
      <p><em class="structfield"><code>num_types</code></em></p>
    </td><td align="left">
      <p><code class="function">XkbGetKeyTypes</code></p>
      <p><code class="function">XkbResizeKeyType</code></p>
      <p><code class="function">XkbCopyKeyType</code></p>
      <p><code class="function">XkbCopyKeyTypes</code></p>
    </td><td align="left"><a class="link" href="#Key_Types" title="Key Types">15.2</a></td></tr><tr><td align="left"><span class="symbol">XkbKeySymsMask</span></td><td align="left">(1&lt;&lt;1)</td><td align="left">client</td><td align="left">
      <p><em class="structfield"><code>syms</code></em></p>
      <p><em class="structfield"><code>size_syms</code></em></p>
      <p><em class="structfield"><code>num_syms</code></em></p>
      <p><em class="structfield"><code>key_sym_map</code></em></p>
    </td><td align="left">
      <p><code class="function">XkbGetKeySyms</code></p>
      <p><code class="function">XkbResizeKeySyms</code></p>
      <p><code class="function">XkbChangeTypes­OfKey</code></p>
    </td><td align="left"><a class="link" href="#Key_Symbol_Map" title="Key Symbol Map">15.3</a></td></tr><tr><td align="left"><span class="symbol">XkbModifierMapMask</span></td><td align="left">(1&lt;&lt;2)</td><td align="left">client</td><td align="left"><em class="structfield"><code>modmap</code></em></td><td align="left"><code class="function">XkbGetKeyModifier­Map</code></td><td align="left"><a class="link" href="#The_Per_Key_Modifier_Map" title="The Per-Key Modifier Map">15.4</a></td></tr><tr><td align="left"><span class="symbol">XkbExplicitComponentsMask</span></td><td align="left">(1&lt;&lt;3)</td><td align="left">server</td><td align="left"><em class="structfield"><code>explicit</code></em></td><td align="left"><code class="function">XkbGetKeyExplicit­Components</code></td><td align="left"><a class="link" href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server" title="Explicit Components—Avoiding Automatic Remapping by the Server">16.3</a></td></tr><tr><td align="left"><span class="symbol">XkbKeyActionsMask</span></td><td align="left">(1&lt;&lt;4)</td><td align="left">server</td><td align="left">
      <p><em class="structfield"><code>key_acts</code></em></p>
      <p><em class="structfield"><code>acts</code></em></p>
      <p><em class="structfield"><code>num_acts</code></em></p>
      <p><em class="structfield"><code>size_acts</code></em></p>
    </td><td align="left">
      <p><code class="function">XkbGetKeyActions</code></p>
      <p><code class="function">XkbResizeKey­Actions</code></p>
    </td><td align="left"><a class="link" href="#Key_Actions" title="Key Actions">16.1</a></td></tr><tr><td align="left"><span class="symbol">XkbKeyBehaviorsMask</span></td><td align="left">(1&lt;&lt;5)</td><td align="left">server</td><td align="left"><em class="structfield"><code>behaviors</code></em></td><td align="left"><code class="function">XkbGetKey­Behaviors</code></td><td align="left"><a class="link" href="#Key_Behavior" title="Key Behavior">16.2</a></td></tr><tr><td align="left"><span class="symbol">XkbVirtualModsMask</span></td><td align="left">(1&lt;&lt;6)</td><td align="left">server</td><td align="left"><em class="structfield"><code>vmods</code></em></td><td align="left"><code class="function">XkbGetVirtualMods</code></td><td align="left"><a class="link" href="#Virtual_Modifier_Mapping" title="Virtual Modifier Mapping">16.4</a></td></tr><tr><td align="left"><span class="symbol">XkbVirtualModMapMask</span></td><td align="left">(1&lt;&lt;7)</td><td align="left">server</td><td align="left"><em class="structfield"><code>vmodmap</code></em></td><td align="left"><code class="function">XkbGetVirtualMod­Map</code></td><td align="left"><a class="link" href="#Virtual_Modifier_Mapping" title="Virtual Modifier Mapping">16.4</a></td></tr></tbody></table></div></div><br class="table-break" /><p>
Xkb defines combinations of these masks for convenience:

</p><pre class="programlisting">
#define  XkbResizableInfoMask      (XkbKeyTypesMask)
#define  XkbAllClientInfoMask      (XkbKeyTypesMask | XkbKeySymsMask |
                                    XkbModifierMapMask)
#define  XkbAllServerInfoMask      (XkbExplicitComponentsMask |
                                    XkbKeyActionsMask| XkbKeyBehaviorsMask |
                                    XkbVirtualModsMask | XkbVirtualModMapMask)
#define  XkbAllMapComponentsMask   (XkbAllClientInfoMask|XkbAllServerInfoMask)
</pre><p>
Key types, symbol maps, and actions are all interrelated: changes in one
require changes in the others. The convenience functions make it easier to edit
these components and handle the interdependencies.
</p><p>
To update the client or server map information in an existing keyboard
description, use <code class="function">XkbGetUpdatedMap</code>.
</p><a id="idm10005" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetUpdatedMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetUpdatedMap</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask selecting subcomponents to populate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to be updated
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>which</code></em>
parameter is a bitwise inclusive OR of the masks in
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>.
If the needed components of the
<em class="parameter"><code>xkb</code></em>
structure are not already allocated,
<code class="function">XkbGetUpdatedMap</code>
allocates them.
<code class="function">XkbGetUpdatedMap</code>
fetches the requested information for the device specified in the
<span class="structname">XkbDescRec</span>
passed in the
<em class="parameter"><code>xkb</code></em>
parameter.
</p><p>
<code class="function">XkbGetUpdatedMap</code>
is synchronous; it queries the server for the desired information, waits for a
reply, and then returns. If successful,
<code class="function">XkbGetUpdatedMap</code>
returns
<span class="symbol">Success</span>.
If unsuccessful,
<code class="function">XkbGetUpdatedMap</code>
returns one of the following:
<span class="errorname">BadAlloc</span>
(unable to allocate a component in the
<span class="structname">XkbDescRec</span>
structure),
<span class="errorname">BadValue</span>
(some mask bits in
<em class="parameter"><code>which</code></em>
are undefined),
<span class="errorname">BadImplementation</span>
(a compatible version of the Xkb extension is not available in the server or
the reply from the server was invalid).
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Changing_Map_Components_in_the_Server"></a>Changing Map Components in the Server</h2></div></div></div><p>
There are two ways to make changes to map components: either change a local
copy of the keyboard map and call
<code class="function">XkbSetMap</code>
to send the modified map to the server, or, to reduce network traffic, use
an
<span class="structname">XkbMapChangesRec</span>
structure and call <code class="function">XkbChangeMap</code>.
</p><a id="idm10058" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetMap"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetMap</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask selecting subcomponents to update
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        description from which new values are taken
      </p></td></tr></tbody></table></div><p>
Use
<code class="function">XkbSetMap</code>
to send a complete new set of values for entire components (for example, all
symbols, all actions, and so on) to the server. The
<em class="parameter"><code>which</code></em>
parameter specifies the components to be sent to the server, and is a bitwise
inclusive OR of the masks listed in
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>. The
<em class="parameter"><code>xkb</code></em>
parameter is a pointer to an
<span class="structname">XkbDescRec</span>
structure and contains the information to be copied to the server. For each
bit set in the
<em class="parameter"><code>which</code></em>
parameter,
<code class="function">XkbSetMap</code>
takes the corresponding structure values from the
<em class="parameter"><code>xkb</code></em>
parameter and sends it to the server specified by
<em class="parameter"><code>dpy</code></em>.
</p><p>
If any components specified by
<em class="parameter"><code>which</code></em>
are not present in the
<em class="parameter"><code>xkb</code></em>
parameter,
<code class="function">XkbSetMap</code>
returns
<span class="symbol">False</span>.
Otherwise, it sends the update request to the server and returns
<span class="symbol">True</span>.
<code class="function">XkbSetMap</code>
can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadLength</span>,
and
<span class="errorname">BadValue</span>
protocol errors.
</p><p>
Key types, symbol maps, and actions are all interrelated; changes in one
require changes in the others. Xkb provides functions to make it easier to edit
these components and handle the interdependencies.
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a> lists these
helper functions and provides a pointer to where they are defined.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_XkbMapChangesRec_Structure"></a>The XkbMapChangesRec Structure</h3></div></div></div><a id="idm10111" class="indexterm"></a><p>
Use the
<span class="structname">XkbMapChangesRec</span>
structure to identify and track partial modifications to the mapping
components and to reduce the amount of traffic between the server and clients.
</p><pre class="programlisting">
typedef struct _XkbMapChanges {
    unsigned short    changed;              /* identifies valid components
                                               in structure */
    KeyCode           min_key_code;         /* lowest numbered keycode for
                                               device */
    KeyCode           max_key_code;         /* highest numbered keycode for
                                               device */
    unsigned char     first_type;           /* index of first key <em class="structfield"><code>type</code></em>
                                               modified */
    unsigned char     num_types;            /* # types modified */
    KeyCode           first_key_sym;        /* first key whose <em class="structfield"><code>key_sym_map</code></em>
                                               changed */
    unsigned char     num_key_syms;         /* # <em class="structfield"><code>key_sym_map</code></em>
                                               entries changed */
    KeyCode           first_key_act;        /* first key whose <em class="structfield"><code>key_acts</code></em>
                                               entry changed */
    unsigned char     num_key_acts;         /* # <em class="structfield"><code>key_acts</code></em>
                                               entries changed */
    KeyCode           first_key_behavior;   /* first key whose <em class="structfield"><code>behaviors</code></em>
                                               changed */
    unsigned char     num_key_behaviors;    /* # <em class="structfield"><code>behaviors</code></em>
                                               entries changed */
    KeyCode           first_key_explicit;   /* first key whose <em class="structfield"><code>explicit</code></em>
                                               entry changed */
    unsigned char     num_key_explicit;     /* # <em class="structfield"><code>explicit</code></em>
                                               entries changed */
    KeyCode           first_modmap_key;     /* first key whose <em class="structfield"><code>modmap</code></em>
                                               entry changed */
    unsigned char     num_modmap_keys;      /* # <em class="structfield"><code>modmap</code></em>
                                               entries changed */
    KeyCode           first_vmodmap_key;    /* first key whose <em class="structfield"><code>vmodmap</code></em>
                                               changed */
    unsigned char     num_vmodmap_keys;     /* # <em class="structfield"><code>vmodmap</code></em>
                                               entries changed */
    unsigned char     pad1;                 /* reserved */
    unsigned short    vmods;                /* mask indicating which <em class="structfield"><code>vmods</code></em>
                                               changed */
} <span class="structname">XkbMapChangesRec</span>, *XkbMapChangesPtr;
</pre><p>
The
<em class="structfield"><code>changed</code></em>
field identifies the map components that have changed in an
<span class="structname">XkbDescRec</span>
structure and may contain any of the bits in
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>, which are also shown
in <a class="link" href="#table14.2" title="Table 14.2. XkbMapChangesRec Masks">Table 14.2</a>. Every 1 bit in
<em class="structfield"><code>changed</code></em>
also identifies which other fields in the
<span class="structname">XkbMapChangesRec</span>
structure contain valid values, as indicated in
<a class="link" href="#table14.2" title="Table 14.2. XkbMapChangesRec Masks">Table 14.2</a>. The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields are for reference only; they are ignored on any requests sent to the
server and are always updated by the server whenever it returns the data for an
<span class="structname">XkbMapChangesRec</span>.
</p><div class="table"><a id="table14.2"></a><p class="title"><strong>Table 14.2. XkbMapChangesRec Masks</strong></p><div class="table-contents"><table class="table" summary="XkbMapChangesRec Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Valid XkbMapChangesRec Fields</th><th align="left">XkbDescRec Field Containing Changed Data</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbKeyTypesMask</span></td><td align="left">
<em class="structfield"><code>first_type</code></em>,
<em class="structfield"><code>num_types</code></em>
    </td><td align="left">
<em class="structfield"><code>map-&gt;type[first_type]</code></em> ..
<em class="structfield"><code>map-&gt;type[first_type + num_types - 1]</code></em>
    </td></tr><tr><td align="left"><span class="symbol">XkbKeySymsMask</span></td><td align="left">
<em class="structfield"><code>first_key_sym</code></em>,
<em class="structfield"><code>num_key_syms</code></em>
    </td><td align="left">
<em class="structfield"><code>map-&gt;key_sym_map[first_key_sym]</code></em> ..
<em class="structfield"><code>map-&gt;key_sym_map[first_key_sym + num_key_syms - 1]</code></em>
    </td></tr><tr><td align="left"><span class="symbol">XkbModifierMapMask</span></td><td align="left">
<em class="structfield"><code>first_modmap_key</code></em>,
<em class="structfield"><code>num_modmap_keys</code></em>
    </td><td align="left">
<em class="structfield"><code>map-&gt;modmap[first_modmap_key]</code></em> ..
<em class="structfield"><code>map-&gt;modmap[first_modmap_key + num_modmap_keys-1]</code></em>
    </td></tr><tr><td align="left"><span class="symbol">XkbExplicitComponentsMask</span></td><td align="left">
<em class="structfield"><code>first_key_explicit</code></em>,
<em class="structfield"><code>num_key_explicit</code></em>
    </td><td align="left">
<em class="structfield"><code>server-&gt;explicit[first_key_explicit]</code></em> ..
<em class="structfield"><code>server-&gt;explicit[first_key_explicit + num_key_explicit - 1]</code></em>
    </td></tr><tr><td align="left"><span class="symbol">XkbKeyActionsMask</span></td><td align="left">
<em class="structfield"><code>first_key_act</code></em>,
<em class="structfield"><code>num_key_acts</code></em>
    </td><td align="left">
<em class="structfield"><code>server-&gt;key_acts[first_key_act]</code></em> ..
<em class="structfield"><code>server-&gt;key_acts[first_key_act + num_key_acts - 1]</code></em>
    </td></tr><tr><td align="left"><span class="symbol">XkbKeyBehaviorsMask</span></td><td align="left">
<em class="structfield"><code>first_key_behavior</code></em>,
<em class="structfield"><code>num_key_behaviors</code></em>
    </td><td align="left">
<em class="structfield"><code>server-&gt;behaviors[first_key_behavior]</code></em> ..
<em class="structfield"><code>server-&gt;behaviors[first_key_behavior + num_key_behaviors - 1]</code></em>
    </td></tr><tr><td align="left"><span class="symbol">XkbVirtualModsMask</span></td><td align="left"><em class="structfield"><code>vmods</code></em></td><td align="left"><em class="structfield"><code>server-&gt;vmods[*]</code></em></td></tr><tr><td align="left"><span class="symbol">XkbVirtualModMapMask</span></td><td align="left">
<em class="structfield"><code>first_vmodmap_key</code></em>,
<em class="structfield"><code>num_vmodmap_keys</code></em>
    </td><td align="left">
<em class="structfield"><code>server-&gt;vmodmap[first_vmodmap_key]</code></em> ..
<em class="structfield"><code>server-&gt;vmodmap[first_vmodmap_key + num_vmodmap_keys - 1]</code></em>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
To update only partial components of a keyboard description, modify the
appropriate fields in the server and map components of a local copy of the
keyboard description, then call
<code class="function">XkbChangeMap</code>
with an
<span class="structname">XkbMapChangesRec</span>
structure indicating which components have changed.
</p><a id="idm10229" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeMap"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbChangeMap</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbMapChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        description from which new values are taken
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        identifies component parts to update
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbChangeMap</code>
copies any components specified by the
<em class="parameter"><code>changes</code></em>
structure from the keyboard description,
<em class="parameter"><code>xkb</code></em>,
to the X server specified by
<em class="parameter"><code>dpy</code></em>.
</p><p>
If any components specified by
<em class="parameter"><code>changes</code></em>
are not present in the
<em class="parameter"><code>xkb</code></em>
parameter,
<code class="function">XkbChangeMap</code>
returns
<span class="symbol">False</span>.
Otherwise, it sends a request to the server and returns
<span class="symbol">True</span>.
</p><p>
<code class="function">XkbChangeMap</code>
can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadLength</span>,
and
<span class="errorname">BadValue</span>
protocol errors.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Changes_to_Map_Components"></a>Tracking Changes to Map Components</h2></div></div></div><a id="idm10276" class="indexterm"></a><a id="idm10280" class="indexterm"></a><p>
The Xkb extension reports
<span class="symbol">XkbMapNotify</span>
events to clients wanting notification whenever a map component of the Xkb
description for a device changes. There are many different types of Xkb
keyboard map changes. Xkb uses an event detail mask to identify each type of
change. The event detail masks are identical to the masks listed in
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>.
</p><p>
To receive
<span class="symbol">XkbMapNotify</span>
events under all possible conditions, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) and pass
<span class="symbol">XkbMapNotifyMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
To receive
<span class="symbol">XkbMapNotify</span>
events only under certain conditions, use
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbMapNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying the desired map changes in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
using mask bits from <a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>.
</p><p>
The structure for
<span class="symbol">XkbMapNotify</span>
events is:

</p><pre class="programlisting">
typedef struct {
    int            type;         /* Xkb extension base event code */
    unsigned long  serial;       /* X server serial number for event */
    Bool           send_event;   /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;      /* server connection where event generated */
    Time           time;         /* server time when event generated */
    int            xkb_type;     /* <span class="symbol">XkbMapNotify</span> */
    int            device;       /* Xkb device ID, will not be <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int   changed;      /* identifies valid fields in rest of event */
    unsigned int   resized;      /* reserved */
    int            first_type;   /* index of first key <em class="structfield"><code>type</code></em> modified */
    int            num_types     /* # types modified */
    KeyCode        min_key_code; /* minimum keycode for device */
    KeyCode        max_key_code; /* maximum keycode for device */
    KeyCode        first_key_sym; /* first key whose <em class="structfield"><code>key_sym_map</code></em> changed */
    KeyCode        first_key_act; /* first key whose <em class="structfield"><code>key_acts</code></em> entry changed */
    KeyCode        first_key_behavior; /* first key whose <em class="structfield"><code>behaviors</code></em> changed */
    KeyCode        first_key_explicit; /* first key whose <em class="structfield"><code>explicit</code></em> entry changed */
    KeyCode        first_modmap_key;   /* first key whose <em class="structfield"><code>modmap</code></em> entry changed */
    KeyCode        first_vmodmap_key;  /* # <em class="structfield"><code>modmap</code></em> entries changed */
    int            num_key_syms;       /* # <em class="structfield"><code>key_sym_map</code></em> entries changed */
    int            num_key_acts;       /* # <em class="structfield"><code>key_acts</code></em> entries changed */
    int            num_key_behaviors;  /* # <em class="structfield"><code>behaviors</code></em> entries changed */
    int            num_key_explicit;   /* # <em class="structfield"><code>explicit</code></em> entries changed */
    int            num_modmap_keys;    /* # <em class="structfield"><code>modmap</code></em> entries changed */
    int            num_vmodmap_keys;   /* # <em class="structfield"><code>vmodmap</code></em> entries changed */
    unsigned int   vmods;              /* mask indicating which <em class="structfield"><code>vmods</code></em> changed */
} <span class="structname">XkbMapNotifyEvent</span>;
</pre><p>
The
<em class="structfield"><code>changed</code></em>
field specifies the map components that have changed and is the bitwise
inclusive OR of the mask bits defined in
<a class="link" href="#table14.1" title="Table 14.1. Xkb Mapping Component Masks and Convenience Functions">Table 14.1</a>. The other fields in this
event are interpreted as the like-named fields in an
<span class="structname">XkbMapChangesRec</span>
(see <a class="link" href="#The_XkbMapChangesRec_Structure" title="The XkbMapChangesRec Structure">section 14.3.1</a>). The
<span class="structname">XkbMapNotifyEvent</span>
structure also has an additional
<em class="structfield"><code>resized</code></em>
field that is reserved for future use.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_Client_and_Server_Maps"></a>Allocating and Freeing Client and Server Maps</h2></div></div></div><p>
Calling
<code class="function">XkbGetMap</code>
(see <a class="link" href="#Getting_Map_Components_from_the_Server" title="Getting Map Components from the Server">section 14.2</a>) should be sufficient for most applications to get client
and server maps. As a result, most applications do not need to directly
allocate client and server maps.
</p><p>
If you change the number of key types or construct map components without
loading the necessary components from the X server, do not allocate any map
components directly using
<code class="function">malloc</code>
or
<code class="function">Xmalloc</code>.
Instead, use the Xkb allocators,
<code class="function">XkbAllocClientMap</code>,
and
<code class="function">XkbAllocServerMap</code>.
</p><p>
Similarly, use the Xkb destructors,
<code class="function">XkbFreeClientMap</code>,
and
<code class="function">XkbFreeServerMap</code>
instead of
<code class="function">free</code>
or
<code class="function">Xfree</code>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Allocating_an_Empty_Client_Map"></a>Allocating an Empty Client Map</h3></div></div></div><p>
To allocate and initialize an empty client map description record, use
<code class="function">XkbAllocClientMap</code>.
</p><a id="idm10348" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocClientMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocClientMap</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">type_count</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description in which to allocate client map
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask selecting map components to allocate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>type_count</code></em>
    </span></p></td><td><p>
        value of <em class="structfield"><code>num_types</code></em> field in map to be allocated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocClientMap</code>
allocates and initializes an empty client map in the
<em class="structfield"><code>map</code></em>
field of the keyboard description specified by
<em class="parameter"><code>xkb</code></em>.
The
<em class="parameter"><code>which</code></em>
parameter specifies the particular components of the client map structure to
allocate and is a mask composed by a bitwise inclusive OR of one or more of the
masks shown in <a class="link" href="#table14.3" title="Table 14.3. XkbAllocClientMap Masks">Table 14.3</a>.
</p><div class="table"><a id="table14.3"></a><p class="title"><strong>Table 14.3. XkbAllocClientMap Masks</strong></p><div class="table-contents"><table class="table" summary="XkbAllocClientMap Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbKeyTypesMask</span></td><td align="left">
The
<em class="parameter"><code>type_count</code></em>
field specifies the number of entries to preallocate for the
<em class="structfield"><code>types</code></em>
field of the client map. If the
<em class="parameter"><code>type_count</code></em>
field is less than
<span class="symbol">XkbNumRequiredTypes</span>
(see <a class="link" href="#The_Canonical_Key_Types" title="The Canonical Key Types">section 15.2.1</a>), returns
<span class="errorname">BadValue</span>.
</td></tr><tr><td align="left"><span class="symbol">XkbKeySymsMask</span></td><td align="left">
The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter are used to allocate the
<em class="structfield"><code>syms</code></em>
and
<em class="structfield"><code>key_sym_map</code></em>
fields of the client map. The fields are allocated to contain the maximum
number of entries necessary for
<em class="structfield"><code>max_key_code</code></em>
−
<em class="structfield"><code>min_key_code</code></em>
+ 1 keys.
</td></tr><tr><td align="left"><span class="symbol">XkbModifierMapMask</span></td><td align="left">
The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter are used to allocate the
<em class="structfield"><code>modmap</code></em>
field of the client map. The field is allocated to contain the maximum number
of entries necessary for
<em class="structfield"><code>max_key_code</code></em>
−
<em class="structfield"><code>min_key_code</code></em>
+ 1 keys.
</td></tr></tbody></table></div></div><br class="table-break" /><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter must be legal values if the
<span class="symbol">XkbKeySymsMask</span>
or
<span class="symbol">XkbModifierMapMask</span>
masks are set in the
<em class="parameter"><code>which</code></em>
parameter. If they are not valid,
<code class="function">XkbAllocClientMap</code>
returns
<span class="errorname">BadValue</span>.
</p></div><p>
If the client map of the keyboard description is not
<span class="symbol">NULL</span>,
and any fields are already allocated in the client map,
<code class="function">XkbAllocClientMap</code>
does not overwrite the existing values; it simply ignores that part of the
request. The only exception is the
<em class="structfield"><code>types</code></em>
array. If
<em class="parameter"><code>type_count</code></em>
is greater than the current
<em class="structfield"><code>num_types</code></em>
field of the client map,
<code class="function">XkbAllocClientMap</code>
resizes the
<em class="structfield"><code>types</code></em>
array and resets the
<em class="structfield"><code>num_types</code></em>
field accordingly.
</p><p>
If
<code class="function">XkbAllocClientMap</code>
is successful, it returns
<span class="symbol">Success</span>.
Otherwise, it can return either
<span class="errorname">BadMatch</span>,
<span class="errorname">BadAlloc</span>,
or
<span class="errorname">BadValue</span>
errors.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Freeing_a_Client_Map"></a>Freeing a Client Map</h3></div></div></div><p>
To free memory used by the client map member of an
<span class="structname">XkbDescRec</span>
structure, use
<code class="function">XkbFreeClientMap</code>.
</p><a id="idm10455" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeClientMap"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeClientMap</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description containing client map to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask identifying components of map to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span>
         ⇒ free all client components and map itself
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbFreeClientMap</code>
frees the components of client map specified by
<em class="parameter"><code>which</code></em>
in the
<span class="structname">XkbDescRec</span>
structure specified by the
<em class="parameter"><code>xkb</code></em>
parameter and sets the corresponding structure component values to
<span class="symbol">NULL</span>.
The
<em class="parameter"><code>which</code></em>
parameter specifies a combination of the client map masks shown in
<a class="link" href="#table14.3" title="Table 14.3. XkbAllocClientMap Masks">Table 14.3</a>.
</p><p>
If
<em class="parameter"><code>free_all</code></em>
is
<span class="symbol">True</span>,
<em class="parameter"><code>which</code></em>
is ignored;
<code class="function">XkbFreeClientMap</code>
frees every non-
<span class="symbol">NULL</span>
structure component in the client map, frees the
<span class="structname">XkbClientMapRec</span>
structure referenced by the
<em class="structfield"><code>map</code></em>
member of the
<em class="parameter"><code>xkb</code></em>
parameter, and sets the
<em class="structfield"><code>map</code></em>
member to
<span class="symbol">NULL</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Allocating_an_Empty_Server_Map"></a>Allocating an Empty Server Map</h3></div></div></div><p>
To allocate and initialize an empty server map description record, use
<code class="function">XkbAllocServerMap</code>.
</p><a id="idm10508" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocServerMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocServerMap</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">count_acts</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description in which to allocate server map
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask selecting map components to allocate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>count_acts</code></em>
    </span></p></td><td><p>
        value of <em class="structfield"><code>num_acts</code></em> field in map to be allocated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocServerMap</code>
allocates and initializes an empty server map in the
<em class="structfield"><code>server</code></em>
field of the keyboard description specified by
<em class="parameter"><code>xkb</code></em>.
The
<em class="parameter"><code>which</code></em>
parameter specifies the particular components of the server map structure to
allocate, as specified in <a class="link" href="#table14.4" title="Table 14.4. XkbAllocServerMap Masks">Table 14.4</a>.
</p><div class="table"><a id="table14.4"></a><p class="title"><strong>Table 14.4. XkbAllocServerMap Masks</strong></p><div class="table-contents"><table class="table" summary="XkbAllocServerMap Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbExplicitComponentsMask</span></td><td align="left">
The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter are used to allocate the
<em class="structfield"><code>explicit</code></em>
field of the server map.
    </td></tr><tr><td align="left"><span class="symbol">XkbKeyActionsMask</span></td><td align="left">
The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter are used to allocate the
<em class="structfield"><code>key_acts</code></em>
field of the server map. The
<em class="parameter"><code>count_acts</code></em>
parameter is used to allocate the
<em class="structfield"><code>acts</code></em>
field of the server map.
    </td></tr><tr><td align="left"><span class="symbol">XkbKeyBehaviorsMask</span></td><td align="left">
The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter are used to allocate the
<em class="structfield"><code>behaviors</code></em>
field of the server map.
    </td></tr><tr><td align="left"><span class="symbol">XkbVirtualModMapMask</span></td><td align="left">
The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter are used to allocate the
<em class="structfield"><code>vmodmap</code></em>
field of the server map.
    </td></tr></tbody></table></div></div><br class="table-break" /><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
fields of the
<em class="parameter"><code>xkb</code></em>
parameter must be legal values. If they are not valid,
<code class="function">XkbAllocServerMap</code>
returns
<span class="errorname">BadValue</span>.
</p></div><p>
If the server map of the keyboard description is not
<span class="symbol">NULL</span>
and any fields are already allocated in the server map,
<code class="function">XkbAllocServerMap</code>
does not overwrite the existing values. The only exception is with the
<em class="structfield"><code>acts</code></em>
array. If the
<em class="parameter"><code>count_acts</code></em>
parameter is greater than the current
<em class="structfield"><code>num_acts</code></em>
field of the server map,
<code class="function">XkbAllocServerMap</code>
resizes the
<em class="structfield"><code>acts</code></em>
array and resets the
<em class="structfield"><code>num_acts</code></em>
field accordingly.
</p><p>
If
<code class="function">XkbAllocServerMap</code>
is successful, it returns
<span class="symbol">Success</span>.
Otherwise, it can return either
<span class="errorname">BadMatch</span>
or
<span class="errorname">BadAlloc</span>
errors.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Freeing_a_Server_Map"></a>Freeing a Server Map</h3></div></div></div><p>
To free memory used by the server member of an
<span class="structname">XkbDescRec</span>
structure, use
<code class="function">XkbFreeServerMap</code>.
</p><a id="idm10614" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeServerMap"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeServerMap</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description containing server map to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask identifying components of map to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span>
         ⇒ free all server map components and server itself
      </p></td></tr></tbody></table></div><p>
The
<code class="function">XkbFreeServerMap</code>
function frees the specified components of server map in the
<span class="structname">XkbDescRec</span>
structure specified by the
<em class="parameter"><code>xkb</code></em>
parameter and sets the corresponding structure component values to
<span class="symbol">NULL</span>.
The
<em class="parameter"><code>which</code></em>
parameter specifies a combination of the server map masks and is a bitwise
inclusive OR of the masks listed in
<a class="link" href="#table14.4" title="Table 14.4. XkbAllocServerMap Masks">Table 14.4</a>. If
<em class="parameter"><code>free_all</code></em>
is
<span class="symbol">True</span>,
<em class="parameter"><code>which</code></em>
is ignored and
<code class="function">XkbFreeServerMap</code>
frees every non-
<span class="symbol">NULL</span>
structure component in the server map, frees the
<span class="structname">XkbServerMapRec</span>
structure referenced by the
<em class="structfield"><code>server</code></em>
member of the
<em class="parameter"><code>xkb</code></em>
parameter, and sets the
<em class="structfield"><code>server</code></em>
member to
<span class="symbol">NULL</span>.
</p></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm9778" class="footnote"><p><a href="#idm9778" class="para"><sup class="para">[6] </sup></a>
The core implementation restricts the number of symbols per key to 255.
With four groups, this allows for up to 63 symbols (or shift levels) per
group. Most keys will only have a few shift levels.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Xkb_Client_Keyboard_Mapping"></a>Chapter 15. Xkb Client Keyboard Mapping</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#The_XkbClientMapRec_Structure">The XkbClientMapRec Structure</a></span></dt><dt><span class="sect1"><a href="#Key_Types">Key Types</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_Canonical_Key_Types">The Canonical Key Types</a></span></dt><dt><span class="sect2"><a href="#Getting_Key_Types_from_the_Server">Getting Key Types from the Server</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Levels_in_a_Key_Type">Changing the Number of Levels in a Key Type</a></span></dt><dt><span class="sect2"><a href="#Copying_Key_Types">Copying Key Types</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Key_Symbol_Map">Key Symbol Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Per_Key_Key_Type_Indices">Per-Key Key Type Indices</a></span></dt><dt><span class="sect2"><a href="#Per_Key_Group_Information">Per-Key Group Information</a></span></dt><dt><span class="sect2"><a href="#Key_Width">Key Width</a></span></dt><dt><span class="sect2"><a href="#Offset_in_to_the_Symbol_Map">Offset in to the Symbol Map</a></span></dt><dt><span class="sect2"><a href="#Getting_the_Symbol_Map_for_Keys_from_the_Server">Getting the Symbol Map for Keys from the Server</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Groups_and_Types_Bound_to_a_Key">Changing the Number of Groups and Types Bound to a Key</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Symbols_Bound_to_a_Key">Changing the Number of Symbols Bound to a Key</a></span></dt></dl></dd><dt><span class="sect1"><a href="#The_Per_Key_Modifier_Map">The Per-Key Modifier Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Getting_the_Per_Key_Modifier_Map_from_the_Server">Getting the Per-Key Modifier Map from the Server</a></span></dt></dl></dd></dl></div><a id="idm10663" class="indexterm"></a><a id="idm10665" class="indexterm"></a><p>
The Xkb client map for a keyboard is the collection of information a client
needs to interpret key events from the keyboard. It contains a global list of
key types and an array of key symbol maps, each of which describes the symbols
bound to a key and the rules to be used to interpret those symbols.
</p><p>
<a class="link" href="#figure15.1" title="Figure 15.1. Xkb Client Map">Figure 15.1</a> shows the relationships between elements in the client map:
</p><div class="figure"><a id="figure15.1"></a><p class="title"><strong>Figure 15.1. Xkb Client Map</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-15.svg"></object></div></div></div><br class="figure-break" /><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_XkbClientMapRec_Structure"></a>The XkbClientMapRec Structure</h2></div></div></div><a id="idm10678" class="indexterm"></a><p>
The
<em class="structfield"><code>map</code></em>
field of the complete Xkb keyboard description (see <a class="link" href="#The_XkbDescRec_Structure" title="The XkbDescRec Structure">section 6.1</a>) is a pointer
to the Xkb client map, which is of type
<span class="structname">XkbClientMapRec</span>:

</p><pre class="programlisting">
typedef struct {                   /* Client Map */
    unsigned char   size_types;    /* # occupied entries in <em class="structfield"><code>types</code></em> */
    unsigned char   num_types;     /* # entries in <em class="structfield"><code>types</code></em> */
    XkbKeyTypePtr   types;         /* vector of key types used by this keymap */
    unsigned short  size_syms;     /* length of the <em class="structfield"><code>syms</code></em> array */
    unsigned short  num_syms;      /* # entries in <em class="structfield"><code>syms</code></em> */
    KeySym *        syms;          /* linear 2d tables of keysyms, 1 per key */
    XkbSymMapPtr    key_sym_map;   /* 1 per keycode, maps keycode to <em class="structfield"><code>syms</code></em> */
    unsigned char * modmap;        /* 1 per keycode, real mods bound to key */
} <span class="structname">XkbClientMapRec</span>, *XkbClientMapPtr;
</pre><p>
The following sections describe each of the elements of the
<span class="structname">XkbClientMapRec</span>
structure in more detail.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Key_Types"></a>Key Types</h2></div></div></div><a id="idm10696" class="indexterm"></a><a id="idm10699" class="indexterm"></a><p>
Key types are used to determine the shift level of a key given the current
state of the keyboard. The set of all possible key types for the Xkb keyboard
description are held in the
<em class="structfield"><code>types</code></em>
field of the client map, whose total size is stored in
<em class="structfield"><code>size_types</code></em>,
and whose total number of valid entries is stored in
<em class="structfield"><code>num_types</code></em>.
Key types are defined using the following structures:

</p><pre class="programlisting">
typedef struct {                     /* Key Type */
    XkbModsRec        mods;          /* modifiers used to compute shift level */
    unsigned char     num_levels;    /* total # shift levels, do not
                                        modify directly */
    unsigned char     map_count;     /* # entries in <em class="structfield"><code>map</code></em>, <em class="structfield"><code>preserve</code></em>
                                        (if non-<span class="symbol">NULL</span>) */
    XkbKTMapEntryPtr  map;           /* vector of modifiers for each
                                        shift level */
    XkbModsPtr        preserve;      /* mods to preserve for
                                        corresponding <em class="structfield"><code>map</code></em> entry */
    Atom              name;          /* name of key type */
    Atom *            level_names;   /* array of names of each shift level */
} <span class="structname">XkbKeyTypeRec</span>, *XkbKeyTypePtr;
</pre><p>

</p><pre class="programlisting">
typedef struct {                     /* Modifiers for a key type */
    Bool              active;        /* <span class="symbol">True</span> ⇒ entry active when
                                        determining shift level */
    unsigned char     level;         /* shift level if modifiers match <em class="structfield"><code>mods</code></em> */
    XkbModsRec        mods;          /* mods needed for this level to be
                                        selected */
} <span class="structname">XkbKTMapEntryRec</span>, *XkbKTMapEntryPtr;
</pre><p>
The
<em class="structfield"><code>mods</code></em>
field of a key type is an
<span class="structname">XkbModsRec</span>
(see <a class="link" href="#Modifier_Definitions" title="Modifier Definitions">section 7.2</a>) specifying the modifiers the key type uses when calculating
the shift level, and can be composed of both the core modifiers and virtual
modifiers. To set the modifiers associated with a key type, modify the
<em class="structfield"><code>real_mods</code></em>
and
<em class="structfield"><code>vmods</code></em>
fields of the
<em class="structfield"><code>mods</code></em>
<span class="structname">XkbModsRec</span>
accordingly. The
<em class="structfield"><code>mask</code></em>
field of the
<span class="structname">XkbModsRec</span>
is reserved for use by Xkb and is calculated from the
<em class="structfield"><code>real_mods</code></em>
and
<em class="structfield"><code>vmods</code></em>
fields.
</p><p>
The
<em class="structfield"><code>num_levels</code></em>
field holds the total number of shift levels for the key type. Xkb uses
<em class="structfield"><code>num_levels</code></em>
to ensure the array of symbols bound to a key is large enough. Do not modify
<em class="structfield"><code>num_levels</code></em>
directly to change the number if shift levels for a key type. Instead, use
<code class="function">XkbResizeKeyType</code>
(see <a class="link" href="#Changing_the_Number_of_Levels_in_a_Key_Type" title="Changing the Number of Levels in a Key Type">section 15.2.3</a>).
</p><p>
The
<em class="structfield"><code>map</code></em>
field is a vector of
<span class="structname">XkbKTMapEntryRec</span>
structures, with
<em class="structfield"><code>map_count</code></em>
entries, that specify the modifier combinations for each possible shift level.
Each map entry contains an
<em class="structfield"><code>active</code></em>
field, a
<em class="structfield"><code>mods</code></em>
field, and a
<em class="structfield"><code>level</code></em>
field. The
<em class="structfield"><code>active</code></em>
field determines whether the modifier combination listed in the
<em class="structfield"><code>mods</code></em>
field should be considered when determining shift level. If
<em class="structfield"><code>active</code></em>
is
<span class="symbol">False</span>,
this
<em class="structfield"><code>map</code></em>
entry is ignored. If
<em class="structfield"><code>active</code></em>
is
<span class="symbol">True</span>,
the
<em class="structfield"><code>level</code></em>
field of the
<em class="structfield"><code>map</code></em>
entry specifies the shift level to use when the current modifier combination
matches the combination specified in the
<em class="structfield"><code>mods</code></em>
field of the
<em class="structfield"><code>map</code></em>
entry.
</p><p>
Any combination of modifiers not explicitly listed somewhere in the
<em class="structfield"><code>map</code></em>
yields shift level one. In addition,
<em class="structfield"><code>map</code></em>
entries specifying unbound virtual modifiers are not considered.
</p><p>
Any modifiers specified in
<em class="structfield"><code>mods</code></em>
are normally
<span class="emphasis"><em>consumed</em></span>
by
<code class="function">XkbTranslateKeyCode</code>
(see <a class="link" href="#X_Library_Functions_Affected_by_Xkb" title="X Library Functions Affected by Xkb">section 12.1.3</a>). For those rare occasions a modifier
<span class="emphasis"><em>should</em></span>
be considered despite having been used to look up a symbol, key types include
an optional
<em class="structfield"><code>preserve</code></em>
field. If a
<em class="structfield"><code>preserve</code></em>
member of a key type is not
<span class="symbol">NULL</span>,
it represents a list of modifiers where each entry corresponds directly to
one of the key type’s
<em class="structfield"><code>map</code></em>.
Each entry lists the modifiers that should
<span class="emphasis"><em>not</em></span>
be consumed if the matching map entry is used to determine shift level.
</p><p>
Each shift level has a name and these names are held in the
<em class="structfield"><code>level_names</code></em>
array, whose length is
<em class="structfield"><code>num_levels</code></em>.
The type itself also has a name, which is held in the
<em class="structfield"><code>name</code></em>
field.
</p><p>
For example, consider how the server handles the following possible symbolic
description of a possible key type (note that the format used to specify
keyboard mappings in the server database is not specified by the Xkb extension,
although this format is one possible example):
</p><div class="table"><a id="table15.1"></a><p class="title"><strong>Table 15.1. Example Key Type</strong></p><div class="table-contents"><table class="table" summary="Example Key Type" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Symbolic Description</th><th align="left">Key Type Data Structure</th></tr></thead><tbody><tr><td align="left">type "ALPHATHREE" {</td><td align="left">Xkb-&gt;map-&gt;types[i].name</td></tr><tr><td align="left">modifiers = Shift+Lock+LevelThree;</td><td align="left">Xkb-&gt;map-&gt;types[i].mods</td></tr><tr><td align="left"><span class="emphasis"><em>map[None]= Level1;</em></span></td><td align="left">Xkb-&gt;map-&gt;types[i].map[0]</td></tr><tr><td align="left"><span class="emphasis"><em>map[Lock]= Level1;</em></span></td><td align="left">Xkb-&gt;map-&gt;types[i].map[1]</td></tr><tr><td align="left">map[Shift]= Level2;</td><td align="left">Xkb-&gt;map-&gt;types[i].map[2]</td></tr><tr><td align="left">map[LevelThree]= Level3;</td><td align="left">Xkb-&gt;map-&gt;types[i].map[3]</td></tr><tr><td align="left">map[Shift+LevelThree]= Level3;</td><td align="left">Xkb-&gt;map-&gt;types[i].map[4]</td></tr><tr><td align="left"><span class="emphasis"><em>preserve[None]= None;</em></span></td><td align="left">Xkb-&gt;map-&gt;types[i].preserve[0]</td></tr><tr><td align="left">preserve[Lock]= Lock;</td><td align="left">Xkb-&gt;map-&gt;types[i].preserve[1]</td></tr><tr><td align="left"><span class="emphasis"><em>preserve[Shift]= None;</em></span></td><td align="left">Xkb-&gt;map-&gt;types[i].preserve[2]</td></tr><tr><td align="left"><span class="emphasis"><em>preserve[LevelThree]= None;</em></span></td><td align="left">Xkb-&gt;map-&gt;types[i].preserve[3]</td></tr><tr><td align="left"><span class="emphasis"><em>preserve[Shift+Level3]= None;</em></span> </td><td align="left">Xkb-&gt;map-&gt;types[i].preserve[4]</td></tr><tr><td align="left">level_name[Level1]= "Base";</td><td align="left">Xkb-&gt;map-&gt;types[i].level_names[0]</td></tr><tr><td align="left">level_name[Level2]= "Caps";</td><td align="left">Xkb-&gt;map-&gt;types[i].level_names[1]</td></tr><tr><td align="left">level_name[Level3]= "Level3";</td><td align="left">Xkb-&gt;map-&gt;types[i].level_names[2]</td></tr><tr><td align="left">};</td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>name</code></em>
of the example key type is "ALPHATHREE," and the modifiers it pays attention
to are
<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>,
and the virtual modifier
<span class="emphasis"><em>LevelThree</em></span>.
There are three shift levels. The name of shift level one is "Base," the name
of shift level two is "Caps," and the name of shift level three is "Level3."
</p><p>
Given the combination of the
<em class="structfield"><code>map</code></em>
and
<em class="structfield"><code>preserve</code></em>
specifications, there are five
<em class="structfield"><code>map</code></em>
entries. The first map entry specifies that shift level one is to be used if
no modifiers are set. The second entry specifies the
<span class="symbol">Lock</span>
modifier alone also yields shift level one. The third entry specifies the
<span class="symbol">Shift</span>
modifier alone yields shift level two. The fourth and fifth entries specify
that the virtual
<span class="emphasis"><em>LevelThree</em></span>
modifier alone, or in combination with the
<span class="symbol">Shift</span>
modifier, yields shift level three.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Shift level three can be reached only if the virtual modifier
<span class="emphasis"><em>LevelThree</em></span>
is bound to a real modifier (see <a class="link" href="#Virtual_Modifier_Mapping" title="Virtual Modifier Mapping">section 16.4</a>). If
<span class="emphasis"><em>LevelThree</em></span>
is not bound to a real modifier, the
<em class="structfield"><code>map</code></em>
entries associated with it are ignored.</p></div><p>
Because the
<span class="symbol">Lock</span>
modifier is to be preserved for further event processing, the
<em class="structfield"><code>preserve</code></em>
list is not
<span class="symbol">NULL</span>
and parallels the
<em class="structfield"><code>map</code></em>
list. All
<em class="structfield"><code>preserve</code></em>
entries, except for the one corresponding to the
<em class="structfield"><code>map</code></em>
entry that specifies the
<span class="symbol">Lock</span>
modifier, do not list any modifiers. For the
<em class="structfield"><code>map</code></em>
entry that specifies the
<span class="symbol">Lock</span>
modifier, the corresponding
<em class="structfield"><code>preserve</code></em>
list entry lists the
<span class="symbol">Lock</span>
modifier, meaning do not consume the
<span class="symbol">Lock</span>
modifier. In this particular case, the preserved modifier is passed to Xlib
translation functions and causes them to notice that the
<span class="symbol">Lock</span>
modifier is set; consequently, the Xlib functions apply the appropriate
capitalization rules to the symbol. Because this preserve entry is set only for
a modifier that yields shift level one, the capitalization occurs only for
level-one symbols.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_Canonical_Key_Types"></a>The Canonical Key Types</h3></div></div></div><p>
Xkb allows up to
<span class="symbol">XkbMaxKeyTypes</span>
(255) key types to be defined, but requires at least
<span class="symbol">XkbNumRequiredTypes</span>
(4) predefined types to be in a key map. These predefined key types are
referred to as the canonical key types and describe the types of keys available
on most keyboards. The definitions for the canonical key types are held in the
first
<span class="symbol">XkbNumRequiredTypes</span>
entries of the
<em class="structfield"><code>types</code></em>
field of the client map and are indexed using the following constants:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="symbol">XkbOneLevelIndex</span></td></tr><tr><td><span class="symbol">XkbTwoLevelIndex</span></td></tr><tr><td><span class="symbol">XkbAlphabeticIndex</span></td></tr><tr><td><span class="symbol">XkbKeypadIndex</span></td></tr></table><p>
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="ONE_LEVEL"></a>ONE_LEVEL</h4></div></div></div><p>
The ONE_LEVEL key type describes groups that have only one symbol. The default
ONE_LEVEL key type has no map entries and does not pay attention to any
modifiers. A symbolic representation of this key type could look like the
following:
</p><div class="literallayout"><p><br />
    type "ONE_LEVEL" {<br />
          modifiers = None;<br />
          map[None]= Level1;<br />
          level_name[Level1]= "Any";<br />
    };<br />
</p></div><p>
The description of the ONE_LEVEL key type is stored in the
<em class="structfield"><code>types</code></em>
[
<span class="symbol">XkbOneLevelIndex</span>
] entry of the client key map.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="TWO_LEVEL"></a>TWO_LEVEL</h4></div></div></div><p>
The TWO_LEVEL key type describes groups that consist of two symbols but are
neither alphabetic nor numeric keypad keys. The default TWO_LEVEL type uses
only the
<span class="symbol">Shift</span>
modifier. It returns shift level two if
<span class="symbol">Shift</span>
is set, and level one if it is not. A symbolic representation of this key type
could look like the following:
</p><div class="literallayout"><p><br />
    type "TWO_LEVEL" {<br />
          modifiers = Shift;<br />
          map[Shift]= Level2;<br />
          level_name[Level1]= "Base";<br />
          level_name[Level2]= "Shift";<br />
    };<br />
</p></div><p>
The description of the TWO_LEVEL key type is stored in the
<em class="structfield"><code>types</code></em>
[
<span class="symbol">XkbTwoLevelIndex</span>
] entry of the client key map.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="ALPHABETIC"></a>ALPHABETIC</h4></div></div></div><p>
The ALPHABETIC key type describes groups consisting of two symbols: the
lowercase form of a symbol followed by the uppercase form of the same symbol.
The default ALPHABETIC type implements locale-sensitive <span class="quote">“<span class="quote">Shift cancels
CapsLock</span>”</span> behavior using both the
<span class="symbol">Shift</span>
and
<span class="symbol">Lock</span>
modifiers as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If
<span class="symbol">Shift</span>
and
<span class="symbol">Lock</span>
are both set, the default ALPHABETIC type yields level one.
  </p></li><li class="listitem"><p>
If
<span class="symbol">Shift</span>
alone is set, it yields level two.
  </p></li><li class="listitem"><p>
If
<span class="symbol">Lock</span>
alone is set, it yields level one, but preserves the
<span class="symbol">Lock</span>
modifier so Xlib notices and applies the appropriate capitalization rules. The
Xlib functions are locale-sensitive and apply different capitalization rules
for different locales.
  </p></li><li class="listitem"><p>
If neither
<span class="symbol">Shift</span>
nor
<span class="symbol">Lock</span>
is set, it yields level one.
  </p></li></ul></div><p>
A symbolic representation of this key type could look like the following:
</p><div class="literallayout"><p><br />
    type "ALPHABETIC" {<br />
          modifiers = Shift+Lock;<br />
          map[Shift]= Level2;<br />
          preserve[Lock]= Lock;<br />
          level_name[Level1]= "Base";<br />
          level_name[Level2]= "Caps";<br />
    };<br />
</p></div><p>
The description of the ALPHABETIC key type is stored in the
<em class="structfield"><code>types</code></em>
[
<span class="symbol">XkbAlphabeticIndex</span>
] entry of the client key map.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="KEYPAD"></a>KEYPAD</h4></div></div></div><p>
The KEYPAD key type describes groups that consist of two symbols, at least one
of which is a numeric keypad symbol. The numeric keypad symbol is assumed to
reside at level two. The default KEYPAD key type implements
<span class="quote">“<span class="quote">Shift cancels NumLock</span>”</span> behavior using the Shift modifier
and the real modifier bound to the virtual modifier named
<span class="quote">“<span class="quote">NumLock</span>”</span>, known as the
<span class="emphasis"><em>NumLock</em></span>
modifier, as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If
<span class="symbol">Shift</span>
and
<span class="emphasis"><em>NumLock</em></span>
are both set, the default KEYPAD type yields level one.
  </p></li><li class="listitem"><p>
If
<span class="symbol">Shift</span>
alone is set, it yields level two.
  </p></li><li class="listitem"><p>
If
<span class="emphasis"><em>NumLock</em></span>
alone is set, it yields level two.
  </p></li><li class="listitem"><p>
If neither
<span class="symbol">Shift</span>
nor
<span class="emphasis"><em>NumLock</em></span>
is set, it yields level one.
  </p></li></ul></div><p>
A symbolic representation of this key type could look like the following:
</p><div class="literallayout"><p><br />
    type "KEYPAD" {<br />
          modifiers = Shift+NumLock;<br />
          map[None]= Level1;<br />
          map[Shift]= Level2;<br />
          map[NumLock]= Level2;<br />
          map[Shift+NumLock]= Level1;<br />
          level_name[Level1]= "Base";<br />
          level_name[Level2]= "Caps";<br />
    };<br />
</p></div><p>
The description of the KEYPAD key type is stored in the
<em class="structfield"><code>types</code></em>
[
<span class="symbol">XkbKeypadIndex</span>
] entry of the client key map.
</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="Initializing_the_Canonical_Key_Types_in_a_New_Client_Map"></a>Initializing the Canonical Key Types in a New Client Map</h4></div></div></div><p>
To set the definitions of the canonical key types in a client map to their
default values, use
<code class="function">XkbInitCanonicalKeyTypes</code>.
</p><a id="idm10957" class="indexterm"></a><div class="funcsynopsis"><a id="XkbInitCanonicalKeyTypes"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbInitCanonicalKeyTypes</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, int <var class="pdparam">keypadVMod</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description containing client map to initialize
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of types to initialize
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keypadVMod</code></em>
    </span></p></td><td><p>
        index of NumLock virtual modifier
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbInitCanonicalKeyTypes</code>
initializes the first
<span class="symbol">XkbNumRequiredTypes</span>
key types of the keyboard specified by the
<em class="parameter"><code>xkb</code></em>
parameter to their default values. The
<em class="parameter"><code>which</code></em>
parameter specifies what canonical key types to initialize and is a bitwise
inclusive OR of the following masks:
<span class="symbol">XkbOneLevelMask</span>,
<span class="symbol">XkbTwoLevelMask</span>,
<span class="symbol">XkbAlphabeticMask</span>,
and
<span class="symbol">XkbKeypadMask</span>.
Only those canonical types specified by the
<em class="parameter"><code>which</code></em>
mask are initialized.
</p><p>
If
<span class="symbol">XkbKeypadMask</span>
is set in the
<em class="parameter"><code>which</code></em>
parameter,
<code class="function">XkbInitCanonicalKeyTypes</code>
looks up the
<span class="emphasis"><em>NumLock</em></span>
named virtual modifier to determine which virtual modifier to use when
initializing the KEYPAD key type. If the
<span class="emphasis"><em>NumLock</em></span>
virtual modifier does not exist,
<code class="function">XkbInitCanonicalKeyTypes</code>
creates it.
</p><p>
<code class="function">XkbInitCanonicalKeyTypes</code>
normally returns Success. It returns
<span class="errorname">BadAccess</span>
if the Xkb extension has not been properly initialized, and
<span class="errorname">BadAccess</span>
if the
<em class="parameter"><code>xkb</code></em>
parameter is not valid.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Getting_Key_Types_from_the_Server"></a>Getting Key Types from the Server</h3></div></div></div><p>
To obtain the list of available key types in the server’s keyboard mapping,
use
<code class="function">XkbGetKeyTypes</code>.
</p><a id="idm11012" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyTypes"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeyTypes</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        index to first type to get, 0 ⇒ 1st type
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        number of key types to be returned
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description containing client map to update
      </p></td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
<code class="function">XkbGetKeyTypes</code>
is used to obtain descriptions of the key types themselves, not the key types
bound to individual keys. To obtain the key types bound to an individual key,
refer to the
<em class="structfield"><code>key_sym_map</code></em>
field of the client map (see <a class="link" href="#Per_Key_Key_Type_Indices" title="Per-Key Key Type Indices">section 15.3.1</a>).</p></div><p>
<code class="function">XkbGetKeyTypes</code>
queries the server for the desired types, waits for a reply, and returns the
desired types in the
<em class="structfield"><code>xkb-&gt;map-&gt;types</code></em>.
If successful, it returns Success.
</p><p>
<code class="function">XkbGetKeyTypes</code>
returns
<span class="errorname">BadAccess</span>
if the Xkb extension has not been properly initialized and
<span class="errorname">BadValue</span>
if the combination of
<em class="parameter"><code>first</code></em>
and
<em class="parameter"><code>num</code></em>
results in numbers out of valid range.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_the_Number_of_Levels_in_a_Key_Type"></a>Changing the Number of Levels in a Key Type</h3></div></div></div><p>
To change the number of levels in a key type, use
<code class="function">XkbResizeKeyType</code>.
</p><a id="idm11066" class="indexterm"></a><div class="funcsynopsis"><a id="XkbResizeKeyType"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbResizeKeyType</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, int <var class="pdparam">type_ndx</var>, int <var class="pdparam">map_count</var>, Bool <var class="pdparam">want_preserve</var>, int <var class="pdparam">new_num_lvls</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description containing client map to update
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>type_ndx</code></em>
    </span></p></td><td><p>
        index in xkb-&gt;map-&gt;types of type to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>map_count</code></em>
    </span></p></td><td><p>
        total # of map entries needed for the type
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>want_preserve</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span>
         ⇒ list of preserved modifiers is necessary
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new_num_lvls</code></em>
    </span></p></td><td><p>
        new max # of levels for type
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbResizeKeyType</code>
changes the type specified by
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>map-&gt;types</code></em>
[
<em class="parameter"><code>type_ndx</code></em>
], and reallocates the symbols and actions bound to all keys that use the type,
if necessary.
<code class="function">XkbResizeKeyType</code>
updates only the local copy of the types in
<em class="parameter"><code>xkb</code></em>;
to update the server’s copy for the physical device, use
<code class="function">XkbSetMap</code>
or
<code class="function">XkbChangeMap</code>
after calling
<code class="function">XkbResizeKeyType</code>.
</p><p>
The
<em class="parameter"><code>map_count</code></em>
parameter specifies the total number of map entries needed for the type, and
can be zero or greater. If
<em class="parameter"><code>map_count</code></em>
is zero,
<code class="function">XkbResizeKeyType</code>
frees the existing
<em class="structfield"><code>map</code></em>
and
<em class="structfield"><code>preserve</code></em>
entries for the type if they exist and sets them to
<span class="symbol">NULL</span>.
</p><p>
The
<em class="parameter"><code>want_preserve</code></em>
parameter specifies whether a
<em class="structfield"><code>preserve</code></em>
list for the key should be created. If
<em class="parameter"><code>want_preserve</code></em>
is
<span class="symbol">True</span>,
the
<em class="structfield"><code>preserve</code></em>
list with
<em class="parameter"><code>map_count</code></em>
entries is allocated or reallocated if it already exists. Otherwise, if
<em class="parameter"><code>want_preserve</code></em>
is
<span class="symbol">False</span>,
the
<em class="structfield"><code>preserve</code></em>
field is freed if necessary and set to
<span class="symbol">NULL</span>.
</p><p>
The
<em class="parameter"><code>new_num_lvls</code></em>
parameter specifies the new maximum number of shift levels for the type and is
used to calculate and resize the symbols and actions bound to all keys that use
the type.
</p><p>
If
<em class="parameter"><code>type_ndx</code></em>
does not specify a legal type,
<em class="parameter"><code>new_num_lvls</code></em>
is less than 1, or the
<em class="parameter"><code>map_count</code></em>
is less than zero,
<code class="function">XkbResizeKeyType</code>
returns
<span class="errorname">BadValue</span>.
If
<code class="function">XkbResizeKeyType</code>
encounters any problems with allocation, it returns
<span class="errorname">BadAlloc</span>.
Otherwise, it returns
<span class="symbol">Success</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Copying_Key_Types"></a>Copying Key Types</h3></div></div></div><p>
Use
<code class="function">XkbCopyKeyType</code>
and
<code class="function">XkbCopyKeyTypes</code>
to copy one or more
<span class="structname">XkbKeyTypeRec</span>
structures.
</p><a id="idm11155" class="indexterm"></a><div class="funcsynopsis"><a id="XkbCopyKeyType"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbCopyKeyType</strong>(</code>XkbKeyTypePtr <var class="pdparam">from</var>, XkbKeyTypePtr <var class="pdparam">into</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>from</code></em>
    </span></p></td><td><p>
        pointer to XkbKeyTypeRec to be copied
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>into</code></em>
    </span></p></td><td><p>
        pointer to XkbKeyTypeRec to be changed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbCopyKeyType</code>
copies the key type specified by
<em class="parameter"><code>from</code></em>
to the key type specified by
<em class="parameter"><code>into</code></em>.
Both must point to legal
<span class="structname">XkbKeyTypeRec</span>
structures. Xkb assumes
<em class="parameter"><code>from</code></em>
and
<em class="parameter"><code>into</code></em>
point to different places. As a result, overlaps can be fatal.
<code class="function">XkbCopyKeyType</code>
frees any existing
<em class="structfield"><code>map</code></em>,
<em class="structfield"><code>preserve</code></em>,
and
<em class="structfield"><code>level_names</code></em>
in
<em class="parameter"><code>into</code></em>
prior to copying. If any allocation errors occur while copying
<em class="parameter"><code>from</code></em>
to
<em class="parameter"><code>into</code></em>,
<code class="function">XkbCopyKeyType</code>
returns
<span class="errorname">BadAlloc</span>.
Otherwise,
<code class="function">XkbCopyKeyType</code>
copies
<em class="parameter"><code>from</code></em>
to
<em class="parameter"><code>into</code></em>
and returns
<span class="symbol">Success</span>.
</p><a id="idm11197" class="indexterm"></a><div class="funcsynopsis"><a id="XkbCopyKeyTypes"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbCopyKeyTypes</strong>(</code>XkbKeyTypePtr <var class="pdparam">from</var>, XkbKeyTypePtr <var class="pdparam">into</var>, int <var class="pdparam">num_types</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>from</code></em>
    </span></p></td><td><p>
        pointer to array of XkbKeyTypeRecs to copy
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>into</code></em>
    </span></p></td><td><p>
        pointer to array of XkbKeyTypeRecs to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_types</code></em>
    </span></p></td><td><p>
        number of types to copy
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbCopyKeyTypes</code>
copies
<em class="parameter"><code>num_types</code></em>
<span class="structname">XkbKeyTypeRec</span>
structures from the array specified by
<em class="parameter"><code>from</code></em>
into the array specified by
<em class="parameter"><code>into</code></em>.
It is intended for copying between, rather than within, keyboard
descriptions, so it doesn’t check for overlaps. The same rules that apply to
the
<em class="parameter"><code>from</code></em>
and
<em class="parameter"><code>into</code></em>
parameters in
<code class="function">XkbCopyKeyType</code>
apply to each entry of the
<em class="parameter"><code>from</code></em>
and
<em class="parameter"><code>into</code></em>
arrays of
<code class="function">XkbCopyKeyTypes</code>.
If any allocation errors occur while copying
<em class="parameter"><code>from</code></em>
to
<em class="parameter"><code>into</code></em>,
<code class="function">XkbCopyKeyTypes</code>
returns
<span class="errorname">BadAlloc</span>.
Otherwise,
<code class="function">XkbCopyKeyTypes</code>
copies
<em class="parameter"><code>from</code></em>
to
<em class="parameter"><code>into</code></em>
and returns
<span class="symbol">Success</span>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Key_Symbol_Map"></a>Key Symbol Map</h2></div></div></div><a id="idm11248" class="indexterm"></a><p>
The entire list of key symbols for the keyboard mapping is held in the
<em class="structfield"><code>syms</code></em>
field of the client map. Whereas the core keyboard mapping is a
two-dimensional array of
<span class="type">KeySym</span>s
whose rows are indexed by keycode, the
<em class="structfield"><code>syms</code></em>
field of Xkb is a linear list of
<span class="type">KeySym</span>s
that needs to be indexed uniquely for each key. This section describes the key
symbol map and the methods for determining the symbols bound to a key.
</p><p>
The reason the
<em class="structfield"><code>syms</code></em>
field is a linear list of
<span class="type">KeySym</span>s
is to reduce the memory consumption associated with a keymap; because Xkb
allows individual keys to have multiple shift levels and a different number of
groups per key, a single two-dimensional array of
<span class="type">KeySym</span>s
would potentially be very large and sparse. Instead, Xkb provides a small
two-dimensional array of
<span class="type">KeySym</span>s
for each key. To store all of these individual arrays, Xkb concatenates each
array together in the
<em class="structfield"><code>syms</code></em>
field of the client map.
</p><p>
In order to determine which
<span class="type">KeySym</span>s
in the
<em class="structfield"><code>syms</code></em>
field are associated with each keycode, the client map contains an array of
key symbol mappings, held in the
<em class="structfield"><code>key_sym_map</code></em>
field. The
<em class="structfield"><code>key_sym_map</code></em>
field is an array of
<span class="structname">XkbSymMapRec</span>
structures indexed by keycode. The
<em class="structfield"><code>key_sym_map</code></em>
array has
<em class="structfield"><code>min_key_code</code></em>
unused entries at the start to allow direct indexing using a keycode. All
keycodes falling between the minimum and maximum legal keycodes, inclusive,
have
<em class="structfield"><code>key_sym_map</code></em>
arrays, whether or not any key actually yields that code. The
<span class="structname">KeySymMapRec</span>
structure is defined as follows:

</p><pre class="programlisting">
#define XkbNumKbdGroups            4
#define XkbMaxKbdGroup            (XkbNumKbdGroups-1)

typedef struct {                 /* map to keysyms for a single keycode */
    unsigned char     kt_index[XkbNumKbdGroups];
                                         /* key type index for each group */
    unsigned char     group_info;        /* # of groups and out of range
                                            group handling */
    unsigned char     width;             /* max # of shift levels for key */
    unsigned short    offset;            /* index to keysym table in
                                            <em class="structfield"><code>syms</code></em> array */
} <span class="structname">XkbSymMapRec</span>, *XkbSymMapPtr;
</pre><p>
These fields are described in detail in the following sections.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Per_Key_Key_Type_Indices"></a>Per-Key Key Type Indices</h3></div></div></div><p>
The
<em class="structfield"><code>kt_index</code></em>
array of the
<span class="structname">XkbSymMapRec</span>
structure contains the indices of the key types (see <a class="link" href="#Key_Types" title="Key Types">section 15.2</a>) for each
possible group of symbols associated with the key. To obtain the index of a key
type or the pointer to a key type, Xkb provides the following macros, to access
the key types:
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The array of key types is of fixed width and is large enough to
hold key types for the maximum legal number of groups
(<span class="symbol">XkbNumKbdGroups</span>,
currently four); if a key has fewer than
<span class="symbol">XkbNumKbdGroups</span>
groups, the extra key types are reported but ignored.</p></div><a id="idm11286" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyTypeIndex"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyTypeIndex</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var>, int <var class="pdparam">group</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>group</code></em>
    </span></p></td><td><p>
        group index
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyTypeIndex</code>
computes an index into the
<em class="structfield"><code>types</code></em>
vector of the client map in
<em class="parameter"><code>xkb</code></em>
from the given
<em class="parameter"><code>keycode</code></em>
and
<em class="parameter"><code>group</code></em>
index.
</p><a id="idm11321" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyType"></a><p><code class="funcdef">XkbKeyTypePtr <strong class="fsfunc">XkbKeyType</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var>, int <var class="pdparam">group</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>group</code></em>
    </span></p></td><td><p>
        group index
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyType</code>
returns a pointer to the key type in the
<em class="structfield"><code>types</code></em>
vector of the client map in
<em class="parameter"><code>xkb</code></em>
corresponding to the given
<em class="parameter"><code>keycode</code></em>
and
<em class="parameter"><code>group</code></em>
index.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Per_Key_Group_Information"></a>Per-Key Group Information</h3></div></div></div><p>
The
<em class="structfield"><code>group_info</code></em>
field of an
<span class="structname">XkbSymMapRec</span>
is an encoded value containing the number of groups of symbols bound to the
key as well as the specification of the treatment of out-of-range groups. It is
legal for a key to have zero groups, in which case it also has zero symbols and
all events from that key yield
<span class="symbol">NoSymbol</span>.
To obtain the number of groups of symbols bound to the key, use
<code class="function">XkbKeyNumGroups</code>.
To change the number of groups bound to a key, use
<code class="function">XkbChangeTypesOfKey</code>
(see <a class="link" href="#Changing_the_Number_of_Groups_and_Types_Bound_to_a_Key" title="Changing the Number of Groups and Types Bound to a Key">section 15.3.6</a>). To obtain a mask that determines the treatment of
out-of-range groups, use
<code class="function">XkbKeyGroupInfo</code>
and
<code class="function">XkbOutOfRangeGroupInfo</code>.
</p><p>
The keyboard controls (see <a class="xref" href="#Keyboard_Controls" title="Chapter 10. Keyboard Controls">Chapter 10, <em>Keyboard Controls</em></a>) contain a
<em class="structfield"><code>groups_wrap</code></em>
field specifying the handling of illegal groups on a global basis. That is,
when the user performs an action causing the effective group to go out of the
legal range, the
<em class="structfield"><code>groups_wrap</code></em>
field specifies how to normalize the effective keyboard group to a group that
is legal for the keyboard as a whole, but there is no guarantee that the
normalized group will be within the range of legal groups for any individual
key. The per-key
<em class="structfield"><code>group_info</code></em>
field specifies how a key treats a legal effective group if the key does not
have a type specified for the group of concern. For example, the
<span class="keycap"><strong>Enter</strong></span>
key usually has just one group defined. If the user performs an action causing
the global keyboard group to change to
<span class="emphasis"><em>Group2</em></span>,
the
<em class="structfield"><code>group_info</code></em>
field for the
<span class="keycap"><strong>Enter</strong></span>
key describes how to handle this situation.
</p><p>
Out-of-range groups for individual keys are mapped to a legal group using the
same options as are used for the overall keyboard group. The particular type of
mapping used is controlled by the bits set in the
<em class="structfield"><code>group_info</code></em>
flag, as shown in <a class="link" href="#table15.2" title="Table 15.2. group_info Range Normalization">Table 15.2</a>.
See <a class="link" href="#The_GroupsWrap_Control" title="The GroupsWrap Control">section 10.7.1</a>
for more details on the normalization methods in this table.
</p><div class="table"><a id="table15.2"></a><p class="title"><strong>Table 15.2. group_info Range Normalization</strong></p><div class="table-contents"><table class="table" summary="group_info Range Normalization" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Bits set in group_info</th><th align="left">Normalization method</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbRedirectIntoRange</span></td><td align="left"><span class="symbol">XkbRedirectIntoRange</span></td></tr><tr><td align="left"><span class="symbol">XkbClampIntoRange</span></td><td align="left"><span class="symbol">XkbClampIntoRange</span></td></tr><tr><td align="left">none of the above</td><td align="left"><span class="symbol">XkbWrapIntoRange</span></td></tr></tbody></table></div></div><br class="table-break" /><p>
Xkb provides the following macros to access group information:
</p><a id="idm11405" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyNumGroups"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyNumGroups</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyNumGroups</code>
returns the number of groups of symbols bound to the key corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11430" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyGroupInfo"></a><p><code class="funcdef">unsigned char <strong class="fsfunc">XkbKeyGroupInfo</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyGroupInfo</code>
returns the
<em class="structfield"><code>group_info</code></em>
field from the
<span class="structname">XkbSymMapRec</span>
structure associated with the key corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11457" class="indexterm"></a><div class="funcsynopsis"><a id="XkbOutOfRangeGroupInfo"></a><p><code class="funcdef">unsigned char <strong class="fsfunc">XkbOutOfRangeGroupInfo</strong>(</code>unsigned char <var class="pdparam">grp_inf</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>grp_inf</code></em>
    </span></p></td><td><p>
        group_info field of <span class="structname">XkbSymMapRec</span>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbOutOfRangeGroupInfo</code>
returns only the out-of-range processing information from the
<em class="structfield"><code>group_info</code></em>
field of an
<span class="structname">XkbSymMapRec</span>
structure.
</p><a id="idm11477" class="indexterm"></a><div class="funcsynopsis"><a id="XkbOutOfRangeGroupNumber"></a><p><code class="funcdef">unsigned char <strong class="fsfunc">XkbOutOfRangeGroupNumber</strong>(</code>unsigned char <var class="pdparam">grp_inf</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>grp_inf</code></em>
    </span></p></td><td><p>
        group_info field of <span class="structname">XkbSymMapRec</span>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbOutOfRangeGroupNumber</code>
returns the out-of-range group number, represented as a group index, from the
<em class="structfield"><code>group_info</code></em>
field of an
<span class="structname">XkbSymMapRec</span>
structure.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Key_Width"></a>Key Width</h3></div></div></div><p>
The maximum number of shift levels for a type is also referred to as the width
of a key type. The
<em class="structfield"><code>width</code></em>
field of the
<em class="structfield"><code>key_sym_map</code></em>
entry for a key contains the width of the widest type associated with the key.
The
<em class="structfield"><code>width</code></em>
field cannot be explicitly changed; it is updated automatically whenever the
symbols or set of types bound to a key are changed.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Offset_in_to_the_Symbol_Map"></a>Offset in to the Symbol Map</h3></div></div></div><p>
The key width and number of groups associated with a key are used to form a
small two-dimensional array of
<span class="type">KeySym</span>s
for a key. This array may be different sizes for different keys. The array for
a single key is stored as a linear list, in row-major order. The arrays for all
of the keys are stored in the
<em class="structfield"><code>syms</code></em>
field of the client map. There is one row for each group associated with a key
and one column for each level. The index corresponding to a given group and
shift level is computed as:
</p><div class="literallayout"><p><br />
     idx = group_index * key_width + shift_level<br />
</p></div><p>
The
<em class="structfield"><code>offset</code></em>
field of the
<em class="structfield"><code>key_sym_map</code></em>
entry for a key is used to access the beginning of the array.
</p><p>
Xkb provides the following macros for accessing the
<em class="structfield"><code>width</code></em>
and
<em class="structfield"><code>offset</code></em>
for individual keys, as well as macros for accessing the two-dimensional array
of symbols bound to the key:
</p><a id="idm11515" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyGroupsWidth"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyGroupsWidth</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyGroupsWidth</code>
computes the maximum width associated with the key corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11540" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyGroupWidth"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyGroupWidth</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var>, int <var class="pdparam">grp</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>grp</code></em>
    </span></p></td><td><p>
        group of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyGroupWidth</code>
computes the width of the type associated with the group
<em class="parameter"><code>grp</code></em>
for the key corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11573" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeySymsOffset"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeySymsOffset</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeySymsOffset</code>
returns the offset of the two-dimensional array of keysyms for the key
corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11598" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyNumSyms"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyNumSyms</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyNumSyms</code>
returns the total number of keysyms for the key corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11623" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeySymsPtr"></a><p><code class="funcdef">KeySym *<strong class="fsfunc">XkbKeySymsPtr</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeySymsPtr</code>
returns the pointer to the two-dimensional array of keysyms for the key
corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><a id="idm11648" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeySymEntry"></a><p><code class="funcdef">KeySym <strong class="fsfunc">XkbKeySymEntry</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var>, int <var class="pdparam">shift</var>, int <var class="pdparam">grp</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>shift</code></em>
    </span></p></td><td><p>
        shift level of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>grp</code></em>
    </span></p></td><td><p>
        group of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeySymEntry</code>
returns the
<span class="type">KeySym</span>
corresponding to shift level
<em class="parameter"><code>shift</code></em>
and group
<em class="parameter"><code>grp</code></em>
from the two-dimensional array of keysyms for the key corresponding to
<em class="parameter"><code>keycode</code></em>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Getting_the_Symbol_Map_for_Keys_from_the_Server"></a>Getting the Symbol Map for Keys from the Server</h3></div></div></div><p>
To obtain the symbols for a subset of the keys in a keyboard description, use
<code class="function">XkbGetKeySyms</code>:

</p><a id="idm11694" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeySyms"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeySyms</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        keycode of first key to get
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        number of keycodes for which syms desired
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description to be updated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeySyms</code>
sends a request to the server to obtain the set of keysyms bound to
<em class="parameter"><code>num</code></em>
keys starting with the key whose keycode is
<em class="parameter"><code>first</code></em>.
It waits for a reply and returns the keysyms in the
<em class="structfield"><code>map.syms</code></em>
field of
<em class="parameter"><code>xkb</code></em>.
If successful,
<code class="function">XkbGetKeySyms</code>
returns
<span class="symbol">Success</span>.
The
<em class="parameter"><code>xkb</code></em>
parameter must be a pointer to a valid Xkb keyboard description.
</p><p>
If the client
<em class="structfield"><code>map</code></em>
in the
<em class="parameter"><code>xkb</code></em>
parameter has not been allocated,
<code class="function">XkbGetKeySyms</code>
allocates and initializes it before obtaining the symbols.
</p><p>
If a compatible version of Xkb is not available in the server or the Xkb
extension has not been properly initialized,
<code class="function">XkbGetKeySyms</code>
returns
<span class="errorname">BadAccess</span>.
If
<em class="parameter"><code>num</code></em>
is less than 1 or greater than
<span class="symbol">XkbMaxKeyCount</span>,
<code class="function">XkbGetKeySyms</code>
returns
<span class="errorname">BadValue</span>.
If any allocation errors occur,
<code class="function">XkbGetKeySyms</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_the_Number_of_Groups_and_Types_Bound_to_a_Key"></a>Changing the Number of Groups and Types Bound to a Key</h3></div></div></div><p>
To change the number of groups and the types bound to a key, use
<code class="function">XkbChangeTypesOfKey</code>.
</p><a id="idm11756" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeTypesOfKey"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbChangeTypesOfKey</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, int <var class="pdparam">key</var>, int <var class="pdparam">n_groups</var>, unsigned int <var class="pdparam">groups</var>, int *<var class="pdparam">new_types_in</var>, XkbMapChangesPtr <var class="pdparam">p_changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to be changed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>key</code></em>
    </span></p></td><td><p>
        keycode for key of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>n_groups</code></em>
    </span></p></td><td><p>
        new number of groups for key
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>groups</code></em>
    </span></p></td><td><p>
        mask indicating groups to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new_types_in</code></em>
    </span></p></td><td><p>
        indices for new groups specified in <em class="parameter"><code>groups</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>p_changes</code></em>
    </span></p></td><td><p>
        notes changes made to <em class="parameter"><code>xkb</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbChangeTypesOfKey</code>
reallocates the symbols and actions bound to the key, if necessary, and
initializes any new symbols or actions to
<span class="symbol">NoSymbol</span>
or
<span class="emphasis"><em>NoAction</em></span>,
as appropriate. If the
<em class="parameter"><code>p_changes</code></em>
parameter is not
<span class="symbol">NULL</span>,
<code class="function">XkbChangeTypesOfKey</code>
adds the
<span class="symbol">XkbKeySymsMask</span>
to the
<em class="structfield"><code>changes</code></em>
field of
<em class="parameter"><code>p_changes</code></em>
and modifies the
<em class="structfield"><code>first_key_sym</code></em>
and
<em class="structfield"><code>num_key_syms</code></em>
fields of
<em class="parameter"><code>p_changes</code></em>
to include the
<em class="parameter"><code>key</code></em>
that was changed. See <a class="link" href="#The_XkbMapChangesRec_Structure" title="The XkbMapChangesRec Structure">section 14.3.1</a> for more information on the
<span class="type">XkbMapChangesPtr</span>
structure. If successful,
<code class="function">XkbChangeTypesOfKey</code>
returns
<span class="symbol">Success</span>.
</p><p>
The
<em class="parameter"><code>n_groups</code></em>
parameter specifies the new number of groups for the key. The
<em class="parameter"><code>groups</code></em>
parameter is a mask specifying the groups for which new types are supplied and
is a bitwise inclusive OR of the following masks:
<span class="symbol">XkbGroup1Mask</span>,
<span class="symbol">XkbGroup2Mask</span>,
<span class="symbol">XkbGroup3Mask</span>,
and
<span class="symbol">XkbGroup4Mask</span>.
</p><p>
The
<em class="parameter"><code>new_types_in</code></em>
parameter is an integer array of length
<em class="parameter"><code>n_groups</code></em>.
Each entry represents the type to use for the associated group and is an
index into
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>map-&gt;types</code></em>.
The
<em class="parameter"><code>new_types_in</code></em>
array is indexed by group index; if
<em class="parameter"><code>n_groups</code></em>
is four and
<em class="parameter"><code>groups</code></em>
only has
<span class="symbol">XkbGroup1Mask</span>
and
<span class="symbol">XkbGroup3Mask</span>
set,
<em class="parameter"><code>new_types_in</code></em>
looks like this:
</p><div class="literallayout"><p><br />
     new_types_in[0] = type for Group1<br />
     new_types_in[1] = ignored<br />
     new_types_in[2] = type for Group3<br />
     new_types_in[3] = ignored<br />
</p></div><p>
For convenience, Xkb provides the following constants to use as indices to the
groups:
</p><div class="table"><a id="table15.3"></a><p class="title"><strong>Table 15.3. Group Index Constants</strong></p><div class="table-contents"><table class="table" summary="Group Index Constants" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Constant Name</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbGroup1Index</span></td><td align="left">0</td></tr><tr><td align="left"><span class="symbol">XkbGroup2Index</span></td><td align="left">1</td></tr><tr><td align="left"><span class="symbol">XkbGroup3Index</span></td><td align="left">2</td></tr><tr><td align="left"><span class="symbol">XkbGroup4Index</span></td><td align="left">3</td></tr></tbody></table></div></div><br class="table-break" /><p>
If the Xkb extension has not been properly initialized,
<code class="function">XkbChangeTypesOfKey</code>
returns
<span class="errorname">BadAccess</span>.
If the
<em class="parameter"><code>xkb</code></em>
parameter it not valid (that is, it is
<span class="symbol">NULL</span>
or it does not contain a valid client map),
<code class="function">XkbChangeTypesOfKey</code>
returns
<span class="errorname">BadMatch</span>.
If the
<em class="parameter"><code>key</code></em>
is not a valid keycode,
<em class="parameter"><code>n_groups</code></em>
is greater than
<span class="symbol">XkbNumKbdGroups</span>,
or the
<em class="parameter"><code>groups</code></em>
mask does not contain any of the valid group mask bits,
<code class="function">XkbChangeTypesOfKey</code>
returns
<span class="errorname">BadValue</span>.
If it is necessary to resize the key symbols or key actions arrays and any
allocation errors occur,
<code class="function">XkbChangeTypesOfKey</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_the_Number_of_Symbols_Bound_to_a_Key"></a>Changing the Number of Symbols Bound to a Key</h3></div></div></div><p>
To change the number of symbols bound to a key, use
<code class="function">XkbResizeKeySyms</code>.
</p><a id="idm11891" class="indexterm"></a><div class="funcsynopsis"><a id="XkbResizeKeySyms"></a><p><code class="funcdef">KeySym *<strong class="fsfunc">XkbResizeKeySyms</strong>(</code>XkbDescRec *<var class="pdparam">xkb</var>, int <var class="pdparam">key</var>, int <var class="pdparam">needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to be changed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>key</code></em>
    </span></p></td><td><p>
        keycode for key to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>needed</code></em>
    </span></p></td><td><p>
        new number of keysyms required for key
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbResizeKeySyms</code>
reserves the space needed for
<em class="parameter"><code>needed</code></em>
keysyms and returns a pointer to the beginning of the new array that holds the
keysyms. It adjusts the
<em class="structfield"><code>offset</code></em>
field of the
<em class="structfield"><code>key_sym_map</code></em>
entry for the key if necessary and can also change the
<em class="structfield"><code>syms</code></em>,
<em class="structfield"><code>num_syms</code></em>,
and
<em class="structfield"><code>size_syms</code></em>
fields of
<em class="structfield"><code>xkb-&gt;map</code></em>
if it is necessary to reallocate the
<em class="structfield"><code>syms</code></em>
array.
<code class="function">XkbResizeKeySyms</code>
does not modify either the width or number of groups associated with the key.
</p><p>
If
<em class="parameter"><code>needed</code></em>
is greater than the current number of keysyms for the key,
<code class="function">XkbResizeKeySyms</code>
initializes all new keysyms in the array to
<span class="symbol">NoSymbol</span>.
</p><p>
Because the number of symbols needed by a key is normally computed as width *
number of groups, and
<code class="function">XkbResizeKeySyms</code>
does not modify either the width or number of groups for the key, a
discrepancy exists upon return from
<code class="function">XkbResizeKeySyms</code>
between the space allocated for the keysyms and the number required. The
unused entries in the list of symbols returned by
<code class="function">XkbResizeKeySyms</code>
are not preserved across future calls to any of the map editing functions, so
you must update the key symbol mapping (which updates the width and number of
groups for the key) before calling another allocator function. A call to
<code class="function">XkbChangeTypesOfKey</code>
will update the mapping.
</p><p>
If any allocation errors occur while resizing the number of symbols bound to
the key,
<code class="function">XkbResizeKeySyms</code>
returns
<span class="symbol">NULL</span>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A change to the number of symbols bound to a key should be
accompanied by a change in the number of actions bound to a key. Refer to
<a class="link" href="#Changing_the_Number_of_Actions_Bound_to_a_Key" title="Changing the Number of Actions Bound to a Key">section 16.1.16</a> for more information on changing the number of actions bound to
a key.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_Per_Key_Modifier_Map"></a>The Per-Key Modifier Map</h2></div></div></div><p>
The
<em class="structfield"><code>modmap</code></em>
entry of the client map is an array, indexed by keycode, specifying the real
modifiers bound to a key. Each entry is a mask composed of a bitwise inclusive
OR of the legal real modifiers:
<span class="symbol">ShiftMask</span>,
<span class="symbol">LockMask</span>,
<span class="symbol">ControlMask</span>,
<span class="symbol">Mod1Mask</span>,
<span class="symbol">Mod2Mask</span>,
<span class="symbol">Mod3Mask</span>,
<span class="symbol">Mod4Mask</span>,
and
<span class="symbol">Mod5Mask</span>.
If a bit is set in a
<em class="structfield"><code>modmap</code></em>
entry, the corresponding key is bound to that modifier.
</p><p>
Pressing or releasing the key bound to a modifier changes the modifier set and
unset state. The particular manner in which the modifier set and unset state
changes is determined by the behavior and actions assigned to the key (see
<a class="xref" href="#Xkb_Server_Keyboard_Mapping" title="Chapter 16. Xkb Server Keyboard Mapping">Chapter 16, <em>Xkb Server Keyboard Mapping</em></a>).
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Getting_the_Per_Key_Modifier_Map_from_the_Server"></a>Getting the Per-Key Modifier Map from the Server</h3></div></div></div><p>
To update the modifier map for one or more of the keys in a keyboard
description, use
<code class="function">XkbGetKeyModifierMap</code>.
</p><a id="idm11965" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyModifierMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeyModifierMap</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        keycode of first key to get
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        number of keys for which information is desired
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to update
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyModifierMap</code>
sends a request to the server for the modifier mappings for
<em class="parameter"><code>num</code></em>
keys starting with the key whose keycode is
<em class="parameter"><code>first</code></em>.
It waits for a reply and places the results in the
<em class="parameter"><code>xkb</code></em>-&gt;map-&gt;modmap array. If successful,
<code class="function">XkbGetKeyModifierMap</code>
returns
<span class="symbol">Success</span>.
</p><p>
If the map component of the
<em class="parameter"><code>xkb</code></em>
parameter has not been allocated,
<code class="function">XkbGetKeyModifierMap</code>
allocates and initializes it.
</p><p>
If a compatible version of Xkb is not available in the server or the Xkb
extension has not been properly initialized,
<code class="function">XkbGetKeySyms</code>
returns
<span class="errorname">BadAccess</span>.
If any allocation errors occur while obtaining the modifier map,
<code class="function">XkbGetKeyModifierMap</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Xkb_Server_Keyboard_Mapping"></a>Chapter 16. Xkb Server Keyboard Mapping</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Key_Actions">Key Actions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#The_XkbAction_Structure">The XkbAction Structure</a></span></dt><dt><span class="sect2"><a href="#The_XkbAnyAction_Structure">The XkbAnyAction Structure</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_Modifiers_State">Actions for Changing Modifiers’ State</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_Group_State">Actions for Changing Group State</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Moving_the_Pointer">Actions for Moving the Pointer</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Simulating_Pointer_Button_Press_and_Release">Actions for Simulating Pointer Button Press and Release</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_the_Pointer_Button_Simulated">Actions for Changing the Pointer Button Simulated</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Locking_Modifiers_and_Group">Actions for Locking Modifiers and Group</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_the_Active_Screen">Actions for Changing the Active Screen</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Changing_Boolean_Controls_State">Actions for Changing Boolean Controls State</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Generating_Messages">Actions for Generating Messages</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Generating_a_Different_Keycode">Actions for Generating a Different Keycode</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Generating_DeviceButtonPress_and_DeviceButtonRelease">Actions for Generating DeviceButtonPress and DeviceButtonRelease</a></span></dt><dt><span class="sect2"><a href="#Actions_for_Simulating_Events_from_Device_Valuators">Actions for Simulating Events from Device Valuators</a></span></dt><dt><span class="sect2"><a href="#Obtaining_Key_Actions_for_Keys_from_the_Server">Obtaining Key Actions for Keys from the Server</a></span></dt><dt><span class="sect2"><a href="#Changing_the_Number_of_Actions_Bound_to_a_Key">Changing the Number of Actions Bound to a Key</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Key_Behavior">Key Behavior</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Radio_Groups_2">Radio Groups</a></span></dt><dt><span class="sect2"><a href="#The_XkbBehavior_Structure">The XkbBehavior Structure</a></span></dt><dt><span class="sect2"><a href="#Obtaining_Key_Behaviors_for_Keys_from_the_Server">Obtaining Key Behaviors for Keys from the Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server">Explicit Components—Avoiding Automatic Remapping by the Server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Obtaining_Explicit_Components_for_Keys_from_the_Server">Obtaining Explicit Components for Keys from the Server</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Virtual_Modifier_Mapping">Virtual Modifier Mapping</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Obtaining_Virtual_Modifier_Bindings_from_the_Server">Obtaining Virtual Modifier Bindings from the Server</a></span></dt><dt><span class="sect2"><a href="#Obtaining_Per_Key_Virtual_Modifier_Mappings_from_the_Server">Obtaining Per-Key Virtual Modifier Mappings from the Server</a></span></dt></dl></dd></dl></div><a id="idm12018" class="indexterm"></a><a id="idm12020" class="indexterm"></a><p>
The
<em class="structfield"><code>server</code></em>
field of the complete Xkb keyboard description (see <a class="link" href="#The_XkbDescRec_Structure" title="The XkbDescRec Structure">section 6.1</a>) is a pointer
to the Xkb server map.
</p><p>
<a class="link" href="#figure16.1" title="Figure 16.1. Server Map Relationships">Figure 16.1</a> shows the relationships between elements in the server map:
</p><div class="figure"><a id="figure16.1"></a><p class="title"><strong>Figure 16.1. Server Map Relationships</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-16.svg"></object></div></div></div><br class="figure-break" /><p><a id="XkbServerMapRec"></a>
<a id="idm12034" class="indexterm"></a>
The Xkb server map contains the information the server needs to interpret key
events and is of type
<span class="structname">XkbServerMapRec</span>:

</p><pre class="programlisting">
#define XkbNumVirtualMods            16

typedef struct {                       /* Server Map */
    unsigned short     num_acts;       /* # of occupied entries in <em class="structfield"><code>acts</code></em> */
    unsigned short     size_acts;      /* # of entries in <em class="structfield"><code>acts</code></em> */
    XkbAction *        acts;           /* linear 2d tables of key actions,
                                          1 per keycode */
    XkbBehavior *      behaviors;      /* key behaviors, 1 per keycode */
    unsigned short *   key_acts;       /* index into <em class="structfield"><code>acts</code></em>, 1 per keycode */
    unsigned char *    explicit;       /* explicit overrides of core
                                          remapping, 1 per key */
    unsigned char      vmods[XkbNumVirtualMods];  /* real mods bound
                                                     to virtual mods */
    unsigned short *   vmodmap;        /* virtual mods bound to key,
                                          1 per keycode */
} <span class="structname">XkbServerMapRec</span>, *XkbServerMapPtr;
</pre><p>
The
<em class="structfield"><code>num_acts</code></em>,
<em class="structfield"><code>size_acts</code></em>,
<em class="structfield"><code>acts</code></em>,
and
<em class="structfield"><code>key_acts</code></em>
fields specify the key actions, defined in <a class="link" href="#Key_Actions" title="Key Actions">section 16.1</a>. The
<em class="structfield"><code>behaviors</code></em>
field describes the behavior for each key and is defined in <a class="link" href="#Key_Behavior" title="Key Behavior">section 16.2</a>. The
<em class="structfield"><code>explicit</code></em>
field describes the explicit components for a key and is defined in
<a class="link" href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server" title="Explicit Components—Avoiding Automatic Remapping by the Server">section 16.3</a>. The
<em class="structfield"><code>vmods</code></em>
and the
<em class="structfield"><code>vmodmap</code></em>
fields describe the virtual modifiers and the per-key virtual modifier mapping
and are defined in <a class="link" href="#Virtual_Modifier_Mapping" title="Virtual Modifier Mapping">section 16.4</a>.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Key_Actions"></a>Key Actions</h2></div></div></div><p>
A key action defines the effect key presses and releases have on the internal
state of the server. For example, the expected key action associated with
pressing the
<span class="symbol">Shift</span>
key is to set the
<span class="symbol">Shift</span>
modifier. There is zero or one key action associated with each keysym bound to
each key.
</p><p>
Just as the entire list of key symbols for the keyboard mapping is held in the
<em class="structfield"><code>syms</code></em>
field of the client map, the entire list of key actions for the keyboard
mapping is held in the
<em class="structfield"><code>acts</code></em>
array of the server map. The total size of
<em class="structfield"><code>acts</code></em>
is specified by
<em class="structfield"><code>size_acts</code></em>,
and the number of entries is specified by
<em class="structfield"><code>num_acts</code></em>.
</p><p>
The
<em class="structfield"><code>key_acts</code></em>
array, indexed by keycode, describes the actions associated with a key. The
<em class="structfield"><code>key_acts</code></em>
array has
<em class="structfield"><code>min_key_code</code></em>
unused entries at the start to allow direct indexing using a keycode. If a
<em class="structfield"><code>key_acts</code></em>
entry is
<span class="emphasis"><em>zero</em></span>,
it means the key does not have any actions associated with it. If an entry is
not
<span class="emphasis"><em>zero</em></span>,
the entry represents an index into the
<em class="structfield"><code>acts</code></em>
field of the server map, much as the
<em class="structfield"><code>offset</code></em>
field of a
<span class="structname">KeySymMapRec</span>
structure is an index into the
<em class="structfield"><code>syms</code></em>
field of the client map.
</p><p>
The reason the
<em class="structfield"><code>acts</code></em>
field is a linear list of
<span class="structname">XkbAction</span>s
is to reduce the memory consumption associated with a keymap. Because Xkb
allows individual keys to have multiple shift levels and a different number of
groups per key, a single two-dimensional array of
<span class="type">KeySym</span>s
would potentially be very large and sparse. Instead, Xkb provides a small
two-dimensional array of
<span class="structname">XkbAction</span>s
for each key. To store all of these individual arrays, Xkb concatenates each
array together in the
<em class="structfield"><code>acts</code></em>
field of the server map.
</p><p>
The key action structures consist only of fields of type char or unsigned char.
This is done to optimize data transfer when the server sends bytes over the
wire. If the fields are anything but bytes, the server has to sift through all
of the actions and swap any nonbyte fields. Because they consist of nothing but
bytes, it can just copy them out.
</p><p>
Xkb provides the following macros, to simplify accessing information pertaining
to key actions:
</p><a id="idm12086" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyHasActions"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbKeyHasActions</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyHasActions</code>
returns
<span class="symbol">True</span>
if the key corresponding to
<em class="parameter"><code>keycode</code></em>
has any actions associated with it; otherwise, it returns
<span class="symbol">False</span>.
</p><a id="idm12113" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyNumActions"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyNumActions</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyNumActions</code>
computes the number of actions associated with the key corresponding to
<em class="parameter"><code>keycode</code></em>.
This should be the same value as the result of
<code class="function">XkbKeyNumSyms</code>
(see <a class="link" href="#Key_Width" title="Key Width">section 15.3.3</a>).
</p><a id="idm12140" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyActionsPtr"></a><p><code class="funcdef">XkbKeyActionPtr <strong class="fsfunc">XkbKeyActionsPtr</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyActionsPtr</code>
returns a pointer to the two-dimensional array of key actions associated with
the key corresponding to
<em class="parameter"><code>keycode</code></em>.
Use
<code class="function">XkbKeyActionsPtr</code>
only if the key actually has some actions associated with it, that is,
<code class="function">XkbKeyNumActions</code>
(xkb, keycode) returns something greater than zero.
</p><a id="idm12167" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyAction"></a><p><code class="funcdef">XkbAction <strong class="fsfunc">XkbKeyAction</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var>, int <var class="pdparam">idx</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>idx</code></em>
    </span></p></td><td><p>
        index for group and shift level
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyAction</code>
returns the key action indexed by
<em class="parameter"><code>idx</code></em>
in the two-dimensional array of key actions associated with the key
corresponding to
<em class="parameter"><code>keycode</code></em>.
<em class="parameter"><code>idx</code></em>
may be computed from the group and shift level of interest as follows:
</p><div class="literallayout"><p><br />
     idx = group_index * key_width + shift_level<br />
</p></div><a id="idm12202" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyActionEntry"></a><p><code class="funcdef">XkbAction <strong class="fsfunc">XkbKeyActionEntry</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">keycode</var>, int <var class="pdparam">shift</var>, int <var class="pdparam">grp</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>keycode</code></em>
    </span></p></td><td><p>
        keycode of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>shift</code></em>
    </span></p></td><td><p>
        shift level within group
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>grp</code></em>
    </span></p></td><td><p>
        group index for group of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyActionEntry</code>
returns the key action corresponding to group
<em class="parameter"><code>grp</code></em>
and shift level
<em class="parameter"><code>shift</code></em>
from the two-dimensional table of key actions associated with the key
corresponding to
<em class="parameter"><code>keycode</code></em>.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_XkbAction_Structure"></a>The XkbAction Structure</h3></div></div></div><a id="idm12245" class="indexterm"></a><p>
The description for an action is held in an
<span class="structname">XkbAction</span>
structure, which is a union of all possible Xkb action types:

</p><pre class="programlisting">
typedef union _XkbAction {
    XkbAnyAction              any;
    XkbModAction              mods;
    XkbGroupAction            group;
    XkbISOAction              iso;
    XkbPtrAction              ptr;
    XkbPtrBtnAction           btn;
    XkbPtrDfltAction          dflt;
    XkbSwitchScreenAction     screen;
    XkbCtrlsAction            ctrls;
    XkbMessageAction          msg;
    XkbRedirectKeyAction      redirect;
    XkbDeviceBtnAction        devbtn;
    XkbDeviceValuatorAction   devval;
    unsigned char             type;
} <span class="structname">XkbAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field is provided for convenience and is the same as the type field in the
individual structures. The following sections describe the individual
structures for each action in detail.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_XkbAnyAction_Structure"></a>The XkbAnyAction Structure</h3></div></div></div><a id="idm12256" class="indexterm"></a><p>
The
<span class="structname">XkbAnyAction</span>
structure is a convenience structure that refers to any of the actions:

</p><pre class="programlisting">
#define      XkbAnyActionDataSize       7

typedef struct _XkbAnyAction {
    unsigned char    type;            /* type of action; determines interpretation for data */
    unsigned char    data[XkbAnyActionDataSize];
} <span class="structname">XkbAnyAction</span>;
</pre><p>
The
<em class="structfield"><code>data</code></em>
field represents a structure for an action, and its interpretation depends on
the
<em class="structfield"><code>type</code></em>
field. The valid values for the
<em class="structfield"><code>type</code></em>
field, and the data structures associated with them are shown in
<a class="link" href="#table16.1" title="Table 16.1. Action Types">Table 16.1</a>:
</p><div class="table"><a id="table16.1"></a><p class="title"><strong>Table 16.1. Action Types</strong></p><div class="table-contents"><table class="table" summary="Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Structure for Data</th><th align="left">XkbAction Union Member</th><th align="left">Section</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_NoAction</span></td><td align="left">
<span class="symbol">XkbSA_NoAction</span>
means the server does not perform an action for the key; this action does not
have an associated data structure.
    </td><td align="left">any</td><td align="left"> </td></tr><tr><td align="left">
<p><span class="symbol">XkbSA_SetMods</span></p>
<p><span class="symbol">XkbSA_LatchMods</span></p>
<p><span class="symbol">XkbSA_LockMods</span></p>
    </td><td align="left"><p><span class="structname">XkbModAction</span></p></td><td align="left">mods</td><td align="left"><a class="link" href="#Actions_for_Changing_Modifiers_State" title="Actions for Changing Modifiers’ State">16.1.3</a></td></tr><tr><td align="left">
<p><span class="symbol">XkbSA_SetGroup</span></p>
<p><span class="symbol">XkbSA_LatchGroup</span></p>
<p><span class="symbol">XkbSA_LockGroup</span></p>
    </td><td align="left"><span class="structname">XkbGroupAction</span></td><td align="left">group</td><td align="left"><a class="link" href="#Actions_for_Changing_Group_State" title="Actions for Changing Group State">16.1.4</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_MovePtr</span></td><td align="left"><span class="structname">XkbPtrAction</span></td><td align="left">ptr</td><td align="left"><a class="link" href="#Actions_for_Moving_the_Pointer" title="Actions for Moving the Pointer">16.1.5</a></td></tr><tr><td align="left">
<p><span class="symbol">XkbSA_PtrBtn</span></p>
<p><span class="symbol">XkbSA_LockPtrBtn</span></p>
    </td><td align="left"><span class="structname">XkbPtrBtnAction</span></td><td align="left">btn</td><td align="left"><a class="link" href="#Actions_for_Simulating_Pointer_Button_Press_and_Release" title="Actions for Simulating Pointer Button Press and Release">16.1.6</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_SetPtrDflt</span></td><td align="left"><span class="structname">XkbPtrDfltAction</span></td><td align="left">dflt</td><td align="left"><a class="link" href="#Actions_for_Changing_the_Pointer_Button_Simulated" title="Actions for Changing the Pointer Button Simulated">16.1.7</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_ISOLock</span></td><td align="left"><span class="structname">XkbISOAction</span></td><td align="left">iso</td><td align="left"><a class="link" href="#Actions_for_Locking_Modifiers_and_Group" title="Actions for Locking Modifiers and Group">16.1.8</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_SwitchScreen</span></td><td align="left"><span class="structname">XkbSwitchScreenAction</span></td><td align="left">screen</td><td align="left"><a class="link" href="#Actions_for_Changing_the_Active_Screen" title="Actions for Changing the Active Screen">16.1.9</a></td></tr><tr><td align="left">
<p><span class="symbol">XkbSA_SetControls</span></p>
<p><span class="symbol">XkbSA_LockControls</span></p>
    </td><td align="left"><span class="structname">XkbCtrlsAction</span></td><td align="left">ctrls</td><td align="left"><a class="link" href="#Actions_for_Changing_Boolean_Controls_State" title="Actions for Changing Boolean Controls State">16.1.10</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_ActionMessage</span></td><td align="left"><span class="structname">XkbMessageAction</span></td><td align="left">msg</td><td align="left"><a class="link" href="#Actions_for_Generating_Messages" title="Actions for Generating Messages">16.1.11</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_RedirectKey</span></td><td align="left"><span class="structname">XkbRedirectKeyAction</span></td><td align="left">redirect</td><td align="left"><a class="link" href="#Actions_for_Generating_a_Different_Keycode" title="Actions for Generating a Different Keycode">16.1.12</a></td></tr><tr><td align="left">
<p><span class="symbol">XkbSA_DeviceBtn</span></p>
<p><span class="symbol">XkbSA_LockDeviceBtn</span></p>
    </td><td align="left"><span class="structname">XkbDeviceBtnAction</span></td><td align="left">devbtn</td><td align="left"><a class="link" href="#Actions_for_Generating_DeviceButtonPress_and_DeviceButtonRelease" title="Actions for Generating DeviceButtonPress and DeviceButtonRelease">16.1.13</a></td></tr><tr><td align="left"><span class="symbol">XkbSA_DeviceValuator</span></td><td align="left"><span class="structname">XkbDeviceValuatorAction</span></td><td align="left">devval</td><td align="left"><a class="link" href="#Actions_for_Simulating_Events_from_Device_Valuators" title="Actions for Simulating Events from Device Valuators">16.1.14</a></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Changing_Modifiers_State"></a>Actions for Changing Modifiers’ State</h3></div></div></div><a id="idm12407" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbModAction</span>
structure change the state of the modifiers when keys are pressed and released
(see <a class="xref" href="#Virtual_Modifiers" title="Chapter 7. Virtual Modifiers">Chapter 7, <em>Virtual Modifiers</em></a> for a discussion of modifiers):

</p><pre class="programlisting">
typedef struct _XkbModAction {
    unsigned char     type;         /* <span class="symbol">XkbSA_{Set|Latch|Lock}Mods</span> */
    unsigned char     flags;        /* with <em class="structfield"><code>type</code></em>, controls the effect
                                       on modifiers */
    unsigned char     mask;         /* same as <em class="structfield"><code>mask</code></em> field of
                                       a modifier description */
    unsigned char     real_mods;    /* same as <em class="structfield"><code>real_mods</code></em> field of
                                       a modifier description */
    unsigned char     vmods1;       /* derived from <em class="structfield"><code>vmods</code></em> field of
                                       a modifier description */
    unsigned char     vmods2;       /* derived from <em class="structfield"><code>vmods</code></em> field of
                                       a modifier description */
} <span class="structname">XkbModAction</span>;
</pre><p>
In the following description, the term
<em class="firstterm">action modifiers</em>
<a id="idm12423" class="indexterm"></a>
<a id="idm12425" class="indexterm"></a>
means the real modifier bits associated with this action. Depending on the
value of
<em class="structfield"><code>flags</code></em>
(see <a class="link" href="#table16.3" title="Table 16.3. Modifier Action Flags">Table 16.3</a>),
these are designated either in the
<em class="structfield"><code>mask</code></em>
field of the
<span class="structname">XkbModAction</span>
structure itself or the real modifiers bound to the key for which the action
is being used. In the latter case, this is the client
<em class="structfield"><code>map</code></em>-&gt;<em class="structfield"><code>modmap</code></em>
[
<em class="parameter"><code>keycode</code></em>
] field.
</p><p>
The
<em class="structfield"><code>type</code></em>
field can have any of the values shown in
<a class="link" href="#table16.2" title="Table 16.2. Modifier Action Types">Table 16.2</a>.
</p><div class="table"><a id="table16.2"></a><p class="title"><strong>Table 16.2. Modifier Action Types</strong></p><div class="table-contents"><table class="table" summary="Modifier Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_SetMods</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
A key press adds any action modifiers to the keyboard’s base modifiers.
    </p></li><li class="listitem"><p>
A key release clears any action modifiers in the keyboard’s base modifiers,
provided no other key affecting the same modifiers is logically down.
    </p></li><li class="listitem"><p>
If no other keys are physically depressed when this key is released, and
<span class="symbol">XkbSA_ClearLocks</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, the key release unlocks any action modifiers.
    </p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LatchMods</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Key press and key release events have the same effect as for
<span class="symbol">XkbSA_SetMods</span>;
if no keys are physically depressed when this key is released, key release
events have the following additional effects:
    </p></li><li class="listitem"><p>
Modifiers unlocked due to
<span class="symbol">XkbSA_ClearLocks</span>
have no further effect.
    </p></li><li class="listitem"><p>
If
<span class="symbol">XkbSA_LatchToLock</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, a key release locks and then unlatches any remaining action modifiers
that are already latched.
    </p></li><li class="listitem"><p>
A key release latches any action modifiers not used by the
<span class="symbol">XkbSA_ClearLocks</span>
and
<span class="symbol">XkbSA_LatchToLock</span>
flags.
    </p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockMods</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
A key press sets the base state of any action modifiers. If
<span class="symbol">XkbSA_LockNoLock</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, a key press also sets the locked state of any action modifiers.
    </p></li><li class="listitem"><p>
A key release clears any action modifiers in the keyboard’s base modifiers,
provided no other key that affects the same modifiers is down. If
<span class="symbol">XkbSA_LockNoUnlock</span>
is not set in the
<em class="structfield"><code>flags</code></em>
field, and any of the action modifiers were locked before the corresponding
key press occurred, a key release unlocks them.
    </p></li></ul></div>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.3" title="Table 16.3. Modifier Action Flags">Table 16.3</a>.
A general meaning is given in the table, but the exact meaning depends on
the action <em class="structfield"><code>type</code></em>.
</p><div class="table"><a id="table16.3"></a><p class="title"><strong>Table 16.3. Modifier Action Flags</strong></p><div class="table-contents"><table class="table" summary="Modifier Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_UseModMapMods</span></td><td align="left">
If set, the action modifiers are determined by the modifiers bound by the
modifier mapping of the key. Otherwise, the action modifiers are set to the
modifiers specified by the
<em class="structfield"><code>mask</code></em>,
<em class="structfield"><code>real_mods</code></em>,
<em class="structfield"><code>vmods1</code></em>,
and
<em class="structfield"><code>vmods2</code></em>
fields.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ClearLocks</span></td><td align="left">
If set and no keys are physically depressed when this key transition
occurs, the server unlocks any action modifiers.
   </td></tr><tr><td align="left"><span class="symbol">XkbSA_LatchToLock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LatchMods</span>,
the server locks the action modifiers if they are already latched.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoLock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockMods</span>,
the server only unlocks the action modifiers.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoUnlock</span></td><td align="left">
If set, and the action is
<span class="symbol">XkbSA_LockMods</span>,
the server only locks the action modifiers.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
If
<span class="symbol">XkbSA_UseModMapMods</span>
is not set in the
<em class="structfield"><code>flags</code></em>
field, the
<em class="structfield"><code>mask</code></em>,
<em class="structfield"><code>real_mods</code></em>,
<em class="structfield"><code>vmods1</code></em>,
and
<em class="structfield"><code>vmods2</code></em>
fields are used to determine the action modifiers. Otherwise they are ignored
and the modifiers bound to the key (client
<em class="structfield"><code>map</code></em>-&gt;<em class="structfield"><code>modmap</code></em>
[
<em class="parameter"><code>keycode</code></em>
]) are used instead.
</p><p>
The
<em class="structfield"><code>mask</code></em>,
<em class="structfield"><code>real_mods</code></em>,
<em class="structfield"><code>vmods1</code></em>,
and
<em class="structfield"><code>vmods2</code></em>
fields represent the components of an Xkb modifier description
(see <a class="link" href="#Modifier_Definitions" title="Modifier Definitions">section 7.2</a>). While the
<em class="structfield"><code>mask</code></em>
and
<em class="structfield"><code>real_mods</code></em>
fields correspond directly to the
<em class="structfield"><code>mask</code></em>
and
<em class="structfield"><code>real_mods</code></em>
fields of an Xkb modifier description, the
<em class="structfield"><code>vmods1</code></em>
and
<em class="structfield"><code>vmods2</code></em>
fields are combined to correspond to the
<em class="structfield"><code>vmods</code></em>
field of an Xkb modifier description. Xkb provides the following macros, to
convert between the two formats:
</p><a id="idm12557" class="indexterm"></a><div class="funcsynopsis"><a id="XkbModActionVMods"></a><p><code class="funcdef">unsigned short <strong class="fsfunc">XkbModActionVMods</strong>(</code>XkbAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract virtual mods
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbModActionVMods</code>
returns the
<em class="structfield"><code>vmods1</code></em>
and
<em class="structfield"><code>vmods2</code></em>
fields of
<em class="parameter"><code>act</code></em>
converted to the
<em class="structfield"><code>vmods</code></em>
format of an Xkb modifier description.
</p><a id="idm12578" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetModActionVMods"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSetModActionVMods</strong>(</code>XkbAction <var class="pdparam">act</var>, unsigned short <var class="pdparam">vmods</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set vmods
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>vmods</code></em>
    </span></p></td><td><p>
        virtual mods to set
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetModActionVMods</code>
sets the
<em class="structfield"><code>vmods1</code></em>
and
<em class="structfield"><code>vmods2</code></em>
fields of
<em class="parameter"><code>act</code></em>
using the
<em class="parameter"><code>vmods</code></em>
format of an Xkb modifier description.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Despite the fact that the first parameter of these two macros is of
type XkbAction, these macros may be used only with Actions of type
<span class="structname">XkbModAction</span>
and
<span class="structname">XkbISOAction</span>.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Changing_Group_State"></a>Actions for Changing Group State</h3></div></div></div><a id="idm12612" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbGroupAction</span>
structure change the current group state when keys are pressed and released
(see <a class="xref" href="#Keyboard_State" title="Chapter 5. Keyboard State">Chapter 5, <em>Keyboard State</em></a> for a description of groups and keyboard state):

</p><pre class="programlisting">
typedef struct _XkbGroupAction {
    unsigned char   type;       /* <span class="symbol">XkbSA_{Set|Latch|Lock}Group</span> */
    unsigned char   flags;      /* with <em class="structfield"><code>type</code></em> , controls the effect on groups */
    char            group_XXX;  /* represents a group index or delta */
} <span class="structname">XkbGroupAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field can have any of the following values:
</p><div class="table"><a id="table16.4"></a><p class="title"><strong>Table 16.4. Group Action Types</strong></p><div class="table-contents"><table class="table" summary="Group Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_SetGroup</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If the
<span class="symbol">XkbSA_GroupAbsolute</span>
bit is set in the
<em class="structfield"><code>flags</code></em>
field, key press events change the base keyboard group to the group specified
by the
<em class="structfield"><code>group_XXX</code></em>
field. Otherwise, key press events change the base keyboard group by adding
the
<em class="structfield"><code>group_XXX</code></em>
field to the base keyboard group. In either case, the resulting effective
keyboard group is brought back into range depending on the value of the
<em class="structfield"><code>groups_wrap</code></em>
field of the controls structure (see <a class="link" href="#The_GroupsWrap_Control" title="The GroupsWrap Control">section 10.7.1</a>).
    </p></li><li class="listitem"><p>
If a key with an
<span class="symbol">XkbSA_ISOLock</span>
action (see <a class="link" href="#Actions_for_Locking_Modifiers_and_Group" title="Actions for Locking Modifiers and Group">section 16.1.8</a>) is pressed while this key is down, the key release
of this key has no effect. Otherwise, the key release cancels the effects of
the key press.
    </p></li><li class="listitem"><p>
If the
<span class="symbol">XkbSA_ClearLocks</span>
bit is set in the flags field, and no keys are physically depressed when this
key is released, the key release also sets the locked keyboard group to
<span class="emphasis"><em>Group1</em></span>.
</p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LatchGroup</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Key press and key release events have the same effect as for
<span class="symbol">XkbSA_SetGroup</span>;
if no keys are physically depressed when this key is released, key release
events have the following additional effects.
    </p></li><li class="listitem"><p>
If the
<span class="symbol">XkbSA_LatchToLock</span>
bit is set in the
<em class="structfield"><code>flags</code></em>
field and the latched keyboard group index is nonzero, the key release adds
the delta applied by the corresponding key press to the locked keyboard group
and subtracts it from the latched keyboard group. The locked and effective
keyboard group are brought back into range according to the value of the
<em class="structfield"><code>groups_wrap</code></em>
field of the controls structure.
    </p></li><li class="listitem"><p>
Otherwise, the key press adds the key press delta to the latched keyboard group.
    </p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockGroup</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If the
<span class="symbol">XkbSA_GroupAbsolute</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, key press events set the locked keyboard group to the group specified
by the
<em class="structfield"><code>group_XXX</code></em>
field. Otherwise, key press events add the group specified by the
<em class="structfield"><code>group_XXX</code></em>
field to the locked keyboard group. In either case, the resulting locked and
effective keyboard groups are brought back into range depending on the value of
the
<em class="structfield"><code>groups_wrap</code></em>
field of the controls structure.
    </p></li><li class="listitem"><p>
A key release has no effect.
    </p></li></ul></div>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.5" title="Table 16.5. Group Action Flags">Table 16.5</a>.
A general meaning is given in the table, but the exact meaning depends on
the action
<em class="structfield"><code>type</code></em>.
</p><div class="table"><a id="table16.5"></a><p class="title"><strong>Table 16.5. Group Action Flags</strong></p><div class="table-contents"><table class="table" summary="Group Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_ClearLocks</span></td><td align="left">
If set and no keys are physically depressed when this key transition occurs,
the server sets the locked keyboard group to
<span class="emphasis"><em>Group1</em></span>
on a key release.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LatchToLock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LatchGroup</span>,
the server locks the action group if it is already latched.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_GroupAbsolute</span></td><td align="left">
If set, the
<em class="structfield"><code>group_XXX</code></em>
field represents an absolute group number. Otherwise, it represents a group
delta to be added to the current group to determine the new group number.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>group_XXX</code></em>
field represents a signed character. Xkb provides the following macros to
convert between a signed integer value and a signed character:
</p><a id="idm12715" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSAGroup"></a><p><code class="funcdef">int <strong class="fsfunc">XkbSAGroup</strong>(</code>XkbAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract group
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSAGroup</code>
returns the
<em class="structfield"><code>group_XXX</code></em>
field of
<em class="parameter"><code>act</code></em>
converted to a signed int.
</p><a id="idm12734" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSASetGroup"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSASetGroup</strong>(</code>XkbAction <var class="pdparam">act</var>, int <var class="pdparam">grp</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to set group
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>grp</code></em>
    </span></p></td><td><p>
        group index to set in <em class="structfield"><code>group_XXX</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSASetGroup</code>
sets the
<em class="structfield"><code>group_XXX</code></em>
field of
<em class="parameter"><code>act</code></em>
from the group index
<em class="parameter"><code>grp</code></em>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Despite the fact that the first parameter of these two macros is of
type XkbAction, these macros may only be used with Actions of type
<span class="structname">XkbGroupAction</span>
and
<span class="structname">XkbISOAction</span>.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Moving_the_Pointer"></a>Actions for Moving the Pointer</h3></div></div></div><a id="idm12768" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbPtrAction</span>
structure move the pointer when keys are pressed and released:

</p><pre class="programlisting">
typedef struct _XkbPtrAction {
    unsigned char      type;      /* <span class="symbol">XkbSA_MovePtr</span> */
    unsigned char      flags;     /* determines type of pointer motion */
    unsigned char      high_XXX;  /* x coordinate, high bits */
    unsigned char      low_XXX;   /* y coordinate, low bits */
    unsigned char      high_YYY;  /* x coordinate, high bits */
    unsigned char      low_YYY;   /* y coordinate, low bits */
} <span class="structname">XkbPtrAction</span>;
</pre><p>
If the
<span class="emphasis"><em>MouseKeys</em></span>
control is not enabled (see <a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">section 10.5.1</a>),
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events are treated as though the action is
<span class="symbol">XkbSA_NoAction</span>.
</p><p>
If the
<span class="emphasis"><em>MouseKeys</em></span>
control is enabled, a server action of type
<span class="symbol">XkbSA_MovePtr</span>
instructs the server to generate core pointer
<span class="symbol">MotionNotify</span>
events rather than the usual
<span class="symbol">KeyPress</span>
event, and the corresponding
<span class="symbol">KeyRelease</span>
event disables any mouse keys timers that were created as a result of handling
the
<span class="symbol">XkbSA_MovePtr</span>
action.
</p><p>
The
<em class="structfield"><code>type</code></em>
field of the
<span class="structname">XkbPtrAction</span>
structure is always
<span class="symbol">XkbSA_MovePtr</span>.
</p><p>
The
<em class="structfield"><code>flags</code></em>
field is a bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.6" title="Table 16.6. Pointer Action Types">Table 16.6</a>.
</p><div class="table"><a id="table16.6"></a><p class="title"><strong>Table 16.6. Pointer Action Types</strong></p><div class="table-contents"><table class="table" summary="Pointer Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Action Type</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_NoAcceleration</span></td><td align="left">
If not set, and the
<span class="emphasis"><em>MouseKeysAccel</em></span>
control is enabled (see <a class="link" href="#The_MouseKeysAccel_Control" title="The MouseKeysAccel Control">section 10.5.2</a>), the
<span class="symbol">KeyPress</span>
initiates a mouse keys timer for this key; every time the timer expires, the
cursor moves.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_MoveAbsoluteX</span></td><td align="left">If set, the X portion of the structure specifies the new pointer X
coordinate. Otherwise, the X portion is added to the current pointer X
coordinate to determine the new pointer X coordinate.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_MoveAbsoluteY</span></td><td align="left">
If set, the Y portion of the structure specifies the new
pointer Y coordinate. Otherwise, the Y portion is added
to the current pointer Y coordinate to determine the new pointer Y coordinate.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
Each of the X and Y coordinates of the
<span class="structname">XkbPtrAction</span>
structure is composed of two signed 16-bit values, that is, the X coordinate
is composed of
<em class="structfield"><code>high_XXX</code></em>
and
<em class="structfield"><code>low_XXX</code></em>,
and similarly for the Y coordinate. Xkb provides the following macros, to
convert between a signed integer and two signed 16-bit values in
<span class="structname">XkbPtrAction</span>
structures:
</p><a id="idm12826" class="indexterm"></a><div class="funcsynopsis"><a id="XkbPtrActionX"></a><p><code class="funcdef">int <strong class="fsfunc">XkbPtrActionX</strong>(</code>XkbPtrAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract X
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbPtrActionX</code>
returns the
<em class="structfield"><code>high_XXX</code></em>
and
<em class="structfield"><code>low_XXX</code></em>
fields of
<em class="parameter"><code>act</code></em>
converted to a signed int.
</p><a id="idm12846" class="indexterm"></a><div class="funcsynopsis"><a id="XkbPtrActionY"></a><p><code class="funcdef">int <strong class="fsfunc">XkbPtrActionY</strong>(</code>XkbPtrAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract Y
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbPtrActionY</code>
returns the
<em class="structfield"><code>high_YYY</code></em>
and
<em class="structfield"><code>low_YYY</code></em>
fields of
<em class="parameter"><code>act</code></em>
converted to a signed int.
</p><a id="idm12866" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetPtrActionX"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSetPtrActionX</strong>(</code>XkbPtrAction <var class="pdparam">act</var>, int <var class="pdparam">x</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set X
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>x</code></em>
    </span></p></td><td><p>
        new value to set
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetPtrActionX</code>
sets the
<em class="structfield"><code>high_XXX</code></em>
and
<em class="structfield"><code>low_XXX</code></em>
fields of
<em class="parameter"><code>act</code></em>
from the signed integer value
<em class="parameter"><code>x</code></em>.
</p><a id="idm12894" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetPtrActionY"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSetPtrActionY</strong>(</code>XkbPtrAction <var class="pdparam">act</var>, int <var class="pdparam">y</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set Y
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>y</code></em>
    </span></p></td><td><p>
        new value to set
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetPtrActionX</code>
sets the
<em class="structfield"><code>high_YYY</code></em>
and
<em class="structfield"><code>low_YYY</code></em>
fields of
<em class="parameter"><code>act</code></em>
from the signed integer value
<em class="parameter"><code>y</code></em>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Simulating_Pointer_Button_Press_and_Release"></a>Actions for Simulating Pointer Button Press and Release</h3></div></div></div><a id="idm12924" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbPtrBtnAction</span>
structure simulate the press and release of pointer buttons when keys are
pressed and released:

</p><pre class="programlisting">
typedef struct _XkbPtrBtnAction {
    unsigned char   type;     /* <span class="symbol">XkbSA_PtrBtn</span>, <span class="symbol">XkbSA_LockPtrBtn</span> */
    unsigned char   flags;    /* with <em class="structfield"><code>type</code></em>, controls the effect
                                 on pointer buttons */
    unsigned char   count;    /* controls number of ButtonPress and
                                 ButtonRelease events */
    unsigned char   button;   /* pointer button to simulate */
} <span class="structname">XkbPtrBtnAction</span>;
</pre><p>
If the
<span class="emphasis"><em>MouseKeys</em></span>
(see <a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">section 10.5.1</a>) control is not enabled,
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events are treated as though the action is
<span class="symbol">XkbSA_NoAction</span>.
</p><p>
The
<em class="structfield"><code>type</code></em>
field can have any one of the values shown in
<a class="link" href="#table16.7" title="Table 16.7. Pointer Button Action Types">Table 16.7</a>.
</p><div class="table"><a id="table16.7"></a><p class="title"><strong>Table 16.7. Pointer Button Action Types</strong></p><div class="table-contents"><table class="table" summary="Pointer Button Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_PtrBtn</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If
<span class="symbol">XkbSA_UseDfltButton</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, the event is generated for the pointer button specified by the
<em class="structfield"><code>mk_dflt_btn</code></em>
attribute of the
<span class="emphasis"><em>MouseKeys</em></span>
control (see <a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">section 10.5.1</a>). Otherwise, the event is generated for the button
specified by the
<em class="structfield"><code>button</code></em>
field.
    </p></li><li class="listitem"><p>
If the mouse button specified for this action is logically down, the key press
and corresponding key release are ignored and have no effect. Otherwise, a key
press causes one or more core pointer button events instead of the usual
<span class="symbol">KeyPress</span>
event. If
<em class="structfield"><code>count</code></em>
is
<span class="emphasis"><em>zero</em></span>,
a key press generates a single
<span class="symbol">ButtonPress</span>
event; if
<em class="structfield"><code>count</code></em>
is greater than
<span class="emphasis"><em>zero</em></span>,
a key press generates
<em class="structfield"><code>count</code></em>
pairs of
<span class="symbol">ButtonPress</span>
and
<span class="symbol">ButtonRelease</span>
events.
    </p></li><li class="listitem"><p>
If
<em class="structfield"><code>count</code></em>
is
<span class="emphasis"><em>zero</em></span>,
a key release generates a core pointer
<span class="symbol">ButtonRelease</span>
that matches the event generated by the corresponding
<span class="symbol">KeyPress</span>;
if
<em class="structfield"><code>count</code></em>
is nonzero, a key release does not cause a
<span class="symbol">ButtonRelease</span>
event. A key release never generates a key
<span class="symbol">KeyRelease</span>
event.
    </p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockPtrBtn</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If the button specified by the
<span class="emphasis"><em>MouseKeys</em></span>
default button
or
<em class="structfield"><code>button</code></em>
is not locked, a key press causes a
<span class="symbol">ButtonPress</span>
event instead of a
<span class="symbol">KeyPress</span>
event and locks the button. If the button is already locked or if
<span class="symbol">XkbSA_LockNoUnlock</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, a key press is ignored and has no effect.
    </p></li><li class="listitem"><p>
If the corresponding key press was ignored, and if
<span class="symbol">XkbSA_LockNoLock</span>
is not set in the
<em class="structfield"><code>flags</code></em>
field, a key release generates a
<span class="symbol">ButtonRelease</span>
event instead of a
<span class="symbol">KeyRelease</span>
event and unlocks the specified button. If the corresponding key press locked
a button, the key release is ignored and has no effect.
    </p></li></ul></div>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.8" title="Table 16.8. Pointer Button Action Flags">Table 16.8</a>.
A general meaning is given in the table, but the exact meaning depends on
the action
<em class="structfield"><code>type</code></em>:
</p><div class="table"><a id="table16.8"></a><p class="title"><strong>Table 16.8. Pointer Button Action Flags</strong></p><div class="table-contents"><table class="table" summary="Pointer Button Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_UseDfltButton</span></td><td align="left">
If set, the action uses the pointer button specified by the
<em class="structfield"><code>mk_dflt_btn</code></em>
attribute of the
<span class="emphasis"><em>MouseKeys</em></span>
control (see <a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">section 10.5.1</a>). Otherwise, the action uses the pointer button
specified by the
<em class="structfield"><code>button</code></em>
field.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoLock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockPtrBtn</span>,
the server only unlocks the pointer button.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoUnlock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockPtrBtn</span>,
the server only locks the pointer button.
    </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Changing_the_Pointer_Button_Simulated"></a>Actions for Changing the Pointer Button Simulated</h3></div></div></div><a id="idm13039" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbPtrDfltAction</span>
structure change the
<em class="structfield"><code>mk_dflt_btn</code></em>
attribute of the
<span class="emphasis"><em>MouseKeys</em></span>
control (see <a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">section 10.5.1</a>):

</p><pre class="programlisting">
typedef struct _XkbPtrDfltAction {
    unsigned char   type;      /* <span class="symbol">XkbSA_SetPtrDflt</span> */
    unsigned char   flags;     /* controls the pointer button number */
    unsigned char   affect;    /* <span class="symbol">XkbSA_AffectDfltBtn</span> */
    char            valueXXX;  /* new default button member */
} <span class="structname">XkbPtrDfltAction</span>;
</pre><p>
If the
<span class="emphasis"><em>MouseKeys</em></span>
control is not enabled,
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events are treated as though the action is
<span class="symbol">XkbSA_NoAction</span>.
Otherwise, this action changes the
<em class="structfield"><code>mk_dflt_btn</code></em>
attribute of the
<span class="emphasis"><em>MouseKeys</em></span>
control.
</p><p>
The
<em class="structfield"><code>type</code></em>
field of the
<span class="structname">XkbPtrDfltAction</span>
structure should always be
<span class="symbol">XkbSA_SetPtrDflt</span>.
</p><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the values shown in
<a class="link" href="#table16.9" title="Table 16.9. Pointer Default Flags">Table 16.9</a>
(currently there is only one value defined).
</p><div class="table"><a id="table16.9"></a><p class="title"><strong>Table 16.9. Pointer Default Flags</strong></p><div class="table-contents"><table class="table" summary="Pointer Default Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_DfltBtnAbsolute</span></td><td align="left">
If set, the
<em class="structfield"><code>value</code></em>
field represents an absolute pointer button. Otherwise, the
<em class="structfield"><code>value</code></em>
field represents the amount to be added to the current default button.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>affect</code></em>
field specifies what changes as a result of this action. The only valid value
for the
<em class="structfield"><code>affect</code></em>
field is <span class="symbol">XkbSA_AffectDfltBtn</span>.
</p><p>
The
<em class="structfield"><code>valueXXX</code></em>
field is a signed character that represents the new button value for the
<em class="structfield"><code>mk_dflt_btn</code></em>
attribute of the
<span class="emphasis"><em>MouseKeys</em></span>
control (see <a class="link" href="#The_MouseKeys_Control" title="The MouseKeys Control">section 10.5.1</a>). If
<span class="symbol">XkbSA_DfltBtnAbsolute</span>
is set in
<em class="structfield"><code>flags</code></em>,
<em class="structfield"><code>valueXXX</code></em>
specifies the button to be used; otherwise,
<em class="structfield"><code>valueXXX</code></em>
specifies the amount to be added to the current default button. In either
case, illegal button choices are wrapped back around into range. Xkb provides
the following macros, to convert between the integer and signed character
values in
<span class="structname">XkbPtrDfltAction</span>
structures:
</p><a id="idm13095" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSAPtrDfltValue"></a><p><code class="funcdef">int <strong class="fsfunc">XkbSAPtrDfltValue</strong>(</code>XkbAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract group
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSAPtrDfltValue</code>
returns the
<em class="structfield"><code>valueXXX</code></em>
field of
<em class="parameter"><code>act</code></em>
converted to a signed int.
</p><a id="idm13114" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSASetPtrDfltValue"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSASetPtrDfltValue</strong>(</code>XkbPtrDfltAction <var class="pdparam">act</var>, int <var class="pdparam">val</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set <em class="structfield"><code>valueXXX</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>val</code></em>
    </span></p></td><td><p>
        value to set in <em class="structfield"><code>valueXXX</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSASetPtrDfltValue</code>
sets the
<em class="structfield"><code>valueXXX</code></em>
field of
<em class="parameter"><code>act</code></em>
from
<em class="parameter"><code>val</code></em>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Locking_Modifiers_and_Group"></a>Actions for Locking Modifiers and Group</h3></div></div></div><a id="idm13145" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbISOAction</span>
structure lock modifiers and the group according to the ISO9995 specification.
</p><p>
Operated by itself, the
<span class="structname">XkbISOAction</span>
is just a caps lock. Operated simultaneously with another modifier key, it
transforms the other key into a locking key. For example, press
<span class="keysym">ISO_Lock</span>,
press and release
<span class="keysym">Control_L</span>,
release
<span class="keysym">ISO_Lock</span>
ends up locking the
<span class="symbol">Control</span>
modifier.
</p><p>
The default behavior is to convert:

</p><table border="0" summary="Simple list" class="simplelist"><tr><td>{Set,Latch}Mods to: LockMods</td></tr><tr><td>{Set,Latch}Group to: LockGroup</td></tr><tr><td>SetPtrBtn to: LockPtrBtn</td></tr><tr><td>SetControls to: LockControls</td></tr></table><p>
</p><p>
The
<span class="emphasis"><em>affects</em></span>
field allows you to turn those effects on or off individually. Set
<span class="symbol">XkbSA_ISONoAffectMods</span>
to disable the first,
<span class="symbol">XkbSA_ISONoAffectGroup</span>
to disable the second, and so forth.
</p><pre class="programlisting">
typedef struct _XkbISOAction {
    unsigned char   type;        /* <span class="symbol">XkbSA_ISOLock</span> */
    unsigned char   flags;       /* controls changes to group or
                                    modifier state */
    unsigned char   mask;        /* same as <em class="structfield"><code>mask</code></em> field of
                                    a modifier description */
    unsigned char   real_mods;   /* same as <em class="structfield"><code>real_mods</code></em> field of
                                    a modifier description */
    char            group_XXX;   /* group index or delta group */
    unsigned char   affect;      /* specifies whether to affect
                                    mods, group, ptrbtn, or controls */
    unsigned char   vmods1;      /* derived from <em class="structfield"><code>vmods</code></em> field of
                                    a modifier description */
    unsigned char   vmods2;      /* derived from <em class="structfield"><code>vmods</code></em> field of
                                    a modifier description */
} <span class="structname">XkbISOAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field of the
<span class="structname">XkbISOAction</span>
structure should always be
<span class="symbol">XkbSA_ISOLock</span>.
</p><p>
The interpretation of the
<em class="structfield"><code>flags</code></em>
field depends on whether the
<span class="symbol">XkbSA_ISODfltIsGroup</span>
is set in the
<em class="structfield"><code>flags</code></em>
field or not.
</p><p>
If the
<span class="symbol">XkbSA_ISODfltIsGroup</span>
is set in the
<em class="structfield"><code>flags</code></em>
field, the action is used to change the group state. The remaining valid bits
of the
<em class="structfield"><code>flags</code></em>
field are composed of a bitwise inclusive OR using the masks shown in
<a class="link" href="#table16.10" title="Table 16.10. ISO Action Flags when XkbSA_ISODfltIsGroup is Set">Table 16.10</a>.
</p><div class="table"><a id="table16.10"></a><p class="title"><strong>Table 16.10. ISO Action Flags when XkbSA_ISODfltIsGroup is Set</strong></p><div class="table-contents"><table class="table" summary="ISO Action Flags when XkbSA_ISODfltIsGroup is Set" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_ISODfltIsGroup</span></td><td align="left">
      <p>
If set, the action is used to change the base group state. Must be set for the
remaining bits in this table to carry their interpretations.
      </p>
      <p>
A key press sets the base group as specified by the
<em class="structfield"><code>group_XXX</code></em>
field and the
<span class="symbol">XkbSA_GroupAbsolute</span>
bit of the
<em class="structfield"><code>flags</code></em>
field (see section Note). If no other actions are transformed by the
<span class="symbol">XkbSA_ISOLock</span>
action, a key release locks the group. Otherwise, a key release clears group
set by the key press.
      </p>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_GroupAbsolute</span></td><td align="left">
If set, the
<em class="structfield"><code>group_XXX</code></em>
field represents an absolute group number. Otherwise, it represents a group
delta to be added to the current group to determine the new group number.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectMods</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_SetMods</span>
or
<span class="symbol">XkbSA_LatchMods</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockMods</span>
actions instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectGroup</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_SetGroup</span>
or
<span class="symbol">XkbSA_LatchGroup</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockGroup</span>
actions instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectPtr</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_PtrBtn</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockPtrBtn</span>
actions instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectCtrls</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_SetControls</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockControls</span>
actions instead.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
If the
<span class="symbol">XkbSA_ISODfltIsGroup</span>
is not set in the
<em class="structfield"><code>flags</code></em>
field, the action is used to change the modifier state and the remaining valid
bits of the
<em class="structfield"><code>flags</code></em>
field are composed of a bitwise inclusive OR using the masks shown in
<a class="link" href="#table16.11" title="Table 16.11. ISO Action Flags when XkbSA_ISODfltIsGroup is Not Set">Table 16.11</a>.
</p><div class="table"><a id="table16.11"></a><p class="title"><strong>Table 16.11. ISO Action Flags when XkbSA_ISODfltIsGroup is Not Set</strong></p><div class="table-contents"><table class="table" summary="ISO Action Flags when XkbSA_ISODfltIsGroup is Not Set" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_ISODfltIsGroup</span> </td><td align="left">
      <p>
If not set, action is used to change the base modifier state. Must not be set
for the remaining bits in this table to carry their interpretations.
      </p>
      <p>
A key press sets the action modifiers in the keyboard’s base modifiers using
the
<em class="structfield"><code>mask</code></em>,
<em class="structfield"><code>real_mods</code></em>,
<em class="structfield"><code>vmods1</code></em>,
and
<em class="structfield"><code>vmods2</code></em>
fields (see <a class="link" href="#Actions_for_Changing_Modifiers_State" title="Actions for Changing Modifiers’ State">section 16.1.3</a>). If no other actions are transformed by the
<span class="symbol">XkbSA_ISOLock</span>
action, a key release locks the action modifiers. Otherwise, a key release
clears the base modifiers set by the key press.
      </p>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_UseModMapMods</span></td><td align="left">
If set, the action modifiers are determined by the modifiers bound by the
modifier mapping of the key. Otherwise, the action modifiers are set to the
modifiers specified by the
<em class="structfield"><code>mask</code></em>,
<em class="structfield"><code>real_mods</code></em>,
<em class="structfield"><code>vmods1</code></em>,
and
<em class="structfield"><code>vmods2</code></em>
fields.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoLock</span></td><td align="left">If set, the server only unlocks the action modifiers.</td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoUnlock</span></td><td align="left">If set, the server only locks the action modifiers. </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectMods</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_SetMods</span>
or
<span class="symbol">XkbSA_LatchMods</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockMods</span>
actions instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectGroup</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_SetGroup</span>
or
<span class="symbol">XkbSA_LatchGroup</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockGroup</span>
actions instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectPtr</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_PtrBtn</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockPtrBtn</span>
actions instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectCtrls</span></td><td align="left">
If not set, any
<span class="symbol">XkbSA_SetControls</span>
actions that occur simultaneously with the
<span class="symbol">XkbSA_ISOLock</span>
action are treated as
<span class="symbol">XkbSA_LockControls</span>
actions instead.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>group_XXX</code></em>
field represents a signed character. Xkb provides macros to convert between a
signed integer value and a signed character as shown in section Note.
</p><p>
The
<em class="structfield"><code>mask</code></em>,
<em class="structfield"><code>real_mods</code></em>,
<em class="structfield"><code>vmods1</code></em>,
and
<em class="structfield"><code>vmods2</code></em>
fields represent the components of an Xkb modifier description
(see <a class="link" href="#Modifier_Definitions" title="Modifier Definitions">section 7.2</a>). While the
<em class="structfield"><code>mask</code></em>
and
<em class="structfield"><code>real_mods</code></em>
fields correspond directly to the
<em class="structfield"><code>mask</code></em>
and
<em class="structfield"><code>real_mods</code></em>
fields of an Xkb modifier description, the
<em class="structfield"><code>vmods1</code></em>
and
<em class="structfield"><code>vmods2</code></em>
fields are combined to correspond to the
<em class="structfield"><code>vmods</code></em>
field of an Xkb modifier description. Xkb provides macros to convert between
the two formats as shown in <a class="link" href="#Actions_for_Changing_Modifiers_State" title="Actions for Changing Modifiers’ State">section 16.1.3</a>.
</p><p>
The
<em class="structfield"><code>affect</code></em>
field is composed of a bitwise inclusive OR using the masks shown in
<a class="link" href="#table16.11" title="Table 16.11. ISO Action Flags when XkbSA_ISODfltIsGroup is Not Set">Table 16.11</a>.
</p><div class="table"><a id="table16.12"></a><p class="title"><strong>Table 16.12. ISO Action Affect Field Values</strong></p><div class="table-contents"><table class="table" summary="ISO Action Affect Field Values" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Affect</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectMods</span></td><td align="left">
If
<span class="symbol">XkbSA_ISONoAffectMods</span>
is not set, any
<span class="emphasis"><em>SA_SetMods</em></span>
or
<span class="emphasis"><em>SA_LatchMods</em></span>
actions occurring simultaneously with the
<span class="structname">XkbISOAction</span>
are treated as
<span class="emphasis"><em>SA_LockMods</em></span>
instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectGroup</span></td><td align="left">
If
<span class="symbol">XkbSA_ISONoAffectGroup</span>
is not set, any
<span class="emphasis"><em>SA_SetGroup</em></span>
or
<span class="emphasis"><em>SA_LatchGroup</em></span>
actions occurring simultaneously with the
<span class="structname">XkbISOAction</span>
are treated as
<span class="emphasis"><em>SA_LockGroup</em></span>
instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectPtr</span></td><td align="left">
If
<span class="symbol">XkbSA_ISONoAffectPtr</span>
is not set, any
<span class="emphasis"><em>SA_PtrBtn</em></span>
actions occurring simultaneously with the
<span class="structname">XkbISOAction</span>
are treated as
<span class="emphasis"><em>SA_LockPtrBtn</em></span>
instead.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_ISONoAffectCtrls</span></td><td align="left">
If
<span class="symbol">XkbSA_ISONoAffectCtrls</span>
is not set, any
<span class="emphasis"><em>SA_SetControls</em></span>
actions occurring simultaneously with the
<span class="structname">XkbISOAction</span>
are treated as
<span class="emphasis"><em>SA_LockControls</em></span>
instead.
    </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Changing_the_Active_Screen"></a>Actions for Changing the Active Screen</h3></div></div></div><a id="idm13380" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbSwitchScreenAction</span>
action structure change the active screen on a multiscreen display:
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This action is optional. Servers are free to ignore the action or
any of its flags if they do not support the requested behavior. If the action
is ignored, it behaves like
<span class="symbol">XkbSA_NoAction</span>.
Otherwise, key press and key release events do not generate an event.
</p></div><pre class="programlisting">
typedef struct _XkbSwitchScreenAction {
    unsigned char   type;        /* <span class="symbol">XkbSA_SwitchScreen</span> */
    unsigned char   flags;       /* controls screen switching */
    char            screenXXX;   /* screen number or delta */
} <span class="structname">XkbSwitchScreenAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field of the
<span class="structname">XkbSwitchScreenAction</span>
structure should always be
<span class="symbol">XkbSA_SwitchScreen</span>.
</p><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.13" title="Table 16.13. Switch Screen Action Flags">Table 16.13</a>.
</p><div class="table"><a id="table16.13"></a><p class="title"><strong>Table 16.13. Switch Screen Action Flags</strong></p><div class="table-contents"><table class="table" summary="Switch Screen Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_SwitchAbsolute</span></td><td align="left">
If set, the
<em class="structfield"><code>screenXXX</code></em>
field represents the index of the new screen. Otherwise, it represents an
offset from the current screen to the new screen.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_SwitchApplication</span></td><td align="left">
If not set, the action should switch to another screen on the same
server. Otherwise, it should switch to another X server or application that
shares the same physical display.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>screenXXX</code></em>
field is a signed character value that represents either the relative or
absolute screen index, depending on the state of the
<span class="symbol">XkbSA_SwitchAbsolute</span>
bit in the
<em class="structfield"><code>flags</code></em>
field. Xkb provides the following macros to convert between the integer and
signed character value for screen numbers in
<span class="structname">XkbSwitchScreenAction</span>
structures:
</p><a id="idm13423" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSAScreen"></a><p><code class="funcdef">int <strong class="fsfunc">XkbSAScreen</strong>(</code>XkbSwitchScreenAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract screen
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSAScreen</code>
returns the
<em class="structfield"><code>screenXXX</code></em>
field of
<em class="parameter"><code>act</code></em>
converted to a signed int.
</p><a id="idm13442" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSASetScreen"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSASetScreen</strong>(</code>XkbSwitchScreenAction <var class="pdparam">act</var>, int <var class="pdparam">s</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set <em class="structfield"><code>screenXXX</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>s</code></em>
    </span></p></td><td><p>
        value to set in <em class="structfield"><code>screenXXX</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSASetScreen</code>
sets the
<em class="structfield"><code>screenXXX</code></em>
field of
<em class="parameter"><code>act</code></em>
from
<em class="parameter"><code>s</code></em>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Changing_Boolean_Controls_State"></a>Actions for Changing Boolean Controls State</h3></div></div></div><a id="idm13473" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbCtrlsAction</span>
structure change the state of the boolean controls (see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>):

</p><pre class="programlisting">
typedef struct _XkbCtrlsAction {
    unsigned char     type;        /* <span class="symbol">XkbSA_SetControls</span>,
                                      <span class="symbol">XkbSA_LockControls</span> */
    unsigned char     flags;       /* with <em class="structfield"><code>type</code></em>, controls enabling
                                      and disabling of controls */
    unsigned char     ctrls3;      /* <em class="structfield"><code>ctrls0</code></em> through <em class="structfield"><code>ctrls3</code></em>
                                      represent the boolean controls */
    unsigned char     ctrls2;      /* <em class="structfield"><code>ctrls0</code></em> through <em class="structfield"><code>ctrls3</code></em>
                                      represent the boolean controls */
    unsigned char     ctrls1;      /* <em class="structfield"><code>ctrls0</code></em> through <em class="structfield"><code>ctrls3</code></em>
                                      represent the boolean controls */
    unsigned char     ctrls0;      /* <em class="structfield"><code>ctrls0</code></em> through <em class="structfield"><code>ctrls3</code></em>
                                      represent the boolean controls */
} <span class="structname">XkbCtrlsAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field can have any one of the values shown in
<a class="link" href="#table16.14" title="Table 16.14. Controls Action Types">Table 16.14</a>.
</p><div class="table"><a id="table16.14"></a><p class="title"><strong>Table 16.14. Controls Action Types</strong></p><div class="table-contents"><table class="table" summary="Controls Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_SetControls</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
A key press enables any boolean controls specified in the
<em class="structfield"><code>ctrls</code></em>
fields that were not already enabled at the time of the key press.
    </p></li><li class="listitem"><p>
A key release disables any controls enabled by the key press.
    </p></li><li class="listitem"><p>
This action can cause
<span class="symbol">XkbControlsNotify</span>
events (see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>).
    </p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockControls</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If the
<span class="symbol">XkbSA_LockNoLock</span>
bit is not set in the
<em class="structfield"><code>flags</code></em>
field, a key press enables any controls specified in the
<em class="structfield"><code>ctrls</code></em>
fields that were not already enabled at the time of the key press.
    </p></li><li class="listitem"><p>
If the
<span class="symbol">XkbSA_LockNoUnlock</span>
bit is not set in the
<em class="structfield"><code>flags</code></em>
field, a key release disables any controls specified in the
<em class="structfield"><code>ctrls</code></em>
fields that were not already disabled at the time of the key press.
    </p></li><li class="listitem"><p>
This action can cause
<span class="symbol">XkbControlsNotify</span>
events (see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>).
    </p></li></ul></div>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.15" title="Table 16.15. Control Action Flags">Table 16.15</a>.
</p><div class="table"><a id="table16.15"></a><p class="title"><strong>Table 16.15. Control Action Flags</strong></p><div class="table-contents"><table class="table" summary="Control Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_LockNoLock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockControls</span>,
the server only disables controls.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoUnlock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockControls</span>,
the server only enables controls.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<span class="symbol">XkbSA_SetControls</span>
action implements a key that enables a boolean control when pressed and
disables it when released. The
<span class="symbol">XkbSA_LockControls</span>
action is used to implement a key that toggles the state of a boolean control
each time it is pressed and released. The
<span class="symbol">XkbSA_LockNoLock</span>
and
<span class="symbol">XkbSA_LockNoUnlock</span>
flags allow modifying the toggling behavior to only unlock or only lock the
boolean control.
</p><p>
The
<em class="structfield"><code>ctrls0</code></em>,
<em class="structfield"><code>ctrls1</code></em>,
<em class="structfield"><code>ctrls2</code></em>,
and
<em class="structfield"><code>ctrls3</code></em>
fields represent the boolean controls in the
<em class="structfield"><code>enabled_ctrls</code></em>
field of the controls structure (see <a class="link" href="#Controls_that_Enable_and_Disable_Other_Controls" title="Controls that Enable and Disable Other Controls">section 10.1</a>). Xkb provides the following
macros, to convert between the two formats:
</p><a id="idm13573" class="indexterm"></a><div class="funcsynopsis"><a id="XkbActionCtrls"></a><p><code class="funcdef">unsigned int <strong class="fsfunc">XkbActionCtrls</strong>(</code>XkbCtrlsAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract controls
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbActionCtrls</code>
returns the
<em class="structfield"><code>ctrls</code></em>
fields of
<em class="parameter"><code>act</code></em>
converted to an unsigned int.
</p><a id="idm13592" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSAActionSetCtrls"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSAActionSetCtrls</strong>(</code>XkbCtrlsAction <var class="pdparam">act</var>, unsigned int <var class="pdparam">ctrls</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set ctrls0-ctrls3
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls</code></em>
    </span></p></td><td><p>
        value to set in ctrls0-ctrls3
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSAActionSetCtrls</code>
sets the
<em class="structfield"><code>ctrls0</code></em>
through
<em class="structfield"><code>ctrls3</code></em>
fields of
<em class="parameter"><code>act</code></em>
from
<em class="parameter"><code>ctrls</code></em>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Generating_Messages"></a>Actions for Generating Messages</h3></div></div></div><a id="idm13622" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbMessageAction</span>
structure generate
<span class="symbol">XkbActionMessage</span>
events:

</p><pre class="programlisting">
#define             XkbActionMessageLength                  6

typedef struct _XkbMessageAction {
    unsigned char   type;             /* <span class="symbol">XkbSA_ActionMessage</span> */
    unsigned char   flags;            /* controls event generation via
                                         key presses and releases */
    unsigned char   message[XkbActionMessageLength];    /* message */
} <span class="structname">XkbMessageAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field of the
<span class="structname">XkbMessageAction</span>
structure should always be
<span class="symbol">XkbSA_ActionMessage</span>.
</p><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.16" title="Table 16.16. Message Action Flags">Table 16.16</a>.
</p><div class="table"><a id="table16.16"></a><p class="title"><strong>Table 16.16. Message Action Flags</strong></p><div class="table-contents"><table class="table" summary="Message Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_MessageOnPress</span></td><td align="left">
If set, key press events generate an
<span class="symbol">XkbActionMessage</span>
event that reports the keycode, event type, and contents of the
<em class="structfield"><code>message</code></em>
field.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_MessageOnRelease</span></td><td align="left">
If set, key release events generate an
<span class="symbol">XkbActionMessage</span>
event that reports the keycode, event type, and contents of the
<em class="structfield"><code>message</code></em>
field.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_MessageGenKeyEvent</span></td><td align="left">
If set, key press and key release events generate
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events, regardless of whether they generate
<span class="symbol">XkbActionMessage</span>
events.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>message</code></em>
field is an array of
<span class="symbol">XkbActionMessageLength</span>
unsigned characters and may be set to anything the keymap designer wishes.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="Detecting_Key_Action_Messages"></a>Detecting Key Action Messages</h4></div></div></div><a id="idm13672" class="indexterm"></a><a id="idm13676" class="indexterm"></a><p>
To receive
<span class="symbol">XkbActionMessage</span>
events by calling either
<code class="function">XkbSelectEvents</code>
or
<code class="function">XkbSelectEventDetails</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>).
</p><p>
To receive
<span class="symbol">XkbActionMessage</span>
events under all possible conditions, use
<code class="function">XkbSelectEvents</code>
and pass
<span class="symbol">XkbActionMessageMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
The
<span class="symbol">XkbActionMessage</span>
event has no event details. However, you can call
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbActionMessage</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying
<span class="symbol">XkbAllActionMessagesMask</span>
in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
This has the same effect as a call to
<code class="function">XkbSelectEvents</code>.
</p><p>
The structure for the
<span class="symbol">XkbActionMessage</span>
event is defined as follows:

</p><pre class="programlisting">
typedef struct _XkbActionMessage {
    int            type;             /* Xkb extension base event code */
    unsigned long  serial;           /* X server serial number for event */
    Bool           send_event;       /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;          /* server connection where event generated */
    Time           time;             /* server time when event generated */
    int            xkb_type;         /* <span class="symbol">XkbActionMessage</span> */
    int            device;           /* Xkb device ID,
                                        will not be <span class="symbol">XkbUseCoreKbd</span> */
    KeyCode        keycode;          /* keycode of key triggering event */
    Bool           press;            /* <span class="symbol">True</span> ⇒ key press,
                                        <span class="symbol">False</span> ⇒ release */
    Bool           key_event_follows;/* <span class="symbol">True</span> ⇒ KeyPress/KeyRelease follows */
    char           message[XkbActionMessageLength+1];  /* message text */
} <span class="structname">XkbActionMessageEvent</span>;
</pre><p>
The
<em class="structfield"><code>keycode</code></em>
is the keycode of the key that was pressed or released. The
<em class="structfield"><code>press</code></em>
field specifies whether the event was the result of a key press or key
release.
</p><p>
The
<em class="structfield"><code>key_event_follows</code></em>
specifies whether a
<span class="symbol">KeyPress</span>
(if
<em class="structfield"><code>press</code></em>
is
<span class="symbol">True</span>)
or
<span class="symbol">KeyRelease</span>
(if
<em class="structfield"><code>press</code></em>
is
<span class="symbol">False</span>)
event is also sent to the client. As with all other Xkb events,
<span class="structname">XkbActionMessageEvent</span>s
are delivered to all clients requesting them, regardless of the current
keyboard focus. However, the
<span class="symbol">KeyPress</span>
or
<span class="symbol">KeyRelease</span>
event that conditionally follows an
<span class="structname">XkbActionMessageEvent</span>
is sent only to the client selected by the current keyboard focus.
<em class="structfield"><code>key_event_follows</code></em>
is
<span class="symbol">True</span>
only for the client that is actually sent the following
<span class="symbol">KeyPress</span>
or
<span class="symbol">KeyRelease</span>
event.
</p><p>
The
<em class="structfield"><code>message</code></em>
field is set to the message specified in the action and is guaranteed to be
<span class="symbol">NULL</span>
-terminated; the Xkb extension forces a
<span class="symbol">NULL</span>
into
<em class="structfield"><code>message</code></em>
[
<span class="symbol">XkbActionMessageLength</span>
].
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Generating_a_Different_Keycode"></a>Actions for Generating a Different Keycode</h3></div></div></div><a id="idm13736" class="indexterm"></a><p>
Actions associated with the
<span class="structname">XkbRedirectKeyAction</span>
structure generate
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events containing a keycode different from the key that was pressed or
released:

</p><pre class="programlisting">
typedef struct      _XkbRedirectKeyAction {
    unsigned char      type;          /* <span class="symbol">XkbSA_RedirectKey</span> */
    unsigned char      new_key;       /* keycode to be put in event */
    unsigned char      mods_mask;     /* mask of real mods to be reset */
    unsigned char      mods;          /* mask of real mods to take values from */
    unsigned char      vmods_mask0;   /* first half of mask of virtual mods
                                         to be reset */
    unsigned char      vmods_mask1;   /* other half of mask of virtual mods
                                         to be reset */
    unsigned char      vmods0;        /* first half of mask of virtual mods
                                         to take values from */
    unsigned char      vmods1;        /* other half of mask of virtual mods
                                         to take values from */
} <span class="structname">XkbRedirectKeyAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field for the
<span class="structname">XkbRedirectKeyAction</span>
structure should always be
<span class="symbol">XkbSA_RedirectKey</span>.
</p><p>
Key presses cause a
<span class="symbol">KeyPress</span>
event for the key specified by the
<em class="structfield"><code>new_key</code></em>
field instead of the actual key. The state reported in this event reports the
current effective modifiers changed as follows: any real modifiers selected by
the
<em class="structfield"><code>mods_mask</code></em>
field are set to corresponding values from the
<em class="structfield"><code>mods</code></em>
field. Any real modifiers bound to the virtual modifiers specified by the
<em class="structfield"><code>vmods_mask0</code></em>
and
<em class="structfield"><code>vmods_mask1</code></em>
fields are either set or cleared, depending on the corresponding values in the
<em class="structfield"><code>vmods0</code></em>
and
<em class="structfield"><code>vmods1</code></em>
fields. If the real and virtual modifier definitions specify conflicting
values for a single modifier, the real modifier definition has priority.
</p><p>
Key releases cause a
<span class="symbol">KeyRelease</span>
event for the key specified by the
<em class="structfield"><code>new_key</code></em>
field instead of the actual key. The state for this event consists of the
effective keyboard modifiers at the time of the release, changed as described
previously.
</p><p>
The
<span class="symbol">XkbSA_RedirectKey</span>
action normally redirects to another key on the same device as the key that
caused the event, unless that device does not belong to the input extension
<span class="symbol">KeyClass</span>,
in which case this action causes an event on the core keyboard device. (The
input extension categorizes devices by breaking them into classes. Keyboards,
and other input devices with keys, are classified as KeyClass devices by the
input extension.)
</p><p>
The
<em class="structfield"><code>vmods_mask0</code></em>
and
<em class="structfield"><code>vmods_mask1</code></em>
fields actually represent one
<span class="emphasis"><em>vmods_mask</em></span>
value, as described in <a class="xref" href="#Virtual_Modifiers" title="Chapter 7. Virtual Modifiers">Chapter 7, <em>Virtual Modifiers</em></a>. Xkb provides the following macros, to
convert between the two formats:
</p><a id="idm13770" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSARedirectVModsMask"></a><p><code class="funcdef">unsigned int <strong class="fsfunc">XkbSARedirectVModsMask</strong>(</code>XkbRedirectKeyAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract vmods
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSARedirectVModsMask</code>
returns the
<em class="structfield"><code>vmods_mask0</code></em>
and
<em class="structfield"><code>vmods_mask1</code></em>
fields of
<em class="parameter"><code>act</code></em>
converted to an unsigned int.
</p><a id="idm13790" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSARedirectSetVModsMask"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSARedirectSetVModsMask</strong>(</code>XkbRedirectKeyAction <var class="pdparam">act</var>, unsigned int <var class="pdparam">vm</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set vmods
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>vm</code></em>
    </span></p></td><td><p>
        new value for virtual modifier mask
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSARedirectSetVModsMask</code>
sets the
<em class="structfield"><code>vmods_mask0</code></em>
and
<em class="structfield"><code>vmods_mask1</code></em>
fields of
<em class="parameter"><code>act</code></em>
from
<em class="parameter"><code>vm</code></em>.
</p><p>
Similarly, the
<em class="structfield"><code>vmods0</code></em>
and
<em class="structfield"><code>vmods1</code></em>
fields actually represent one
<em class="structfield"><code>vmods</code></em>
value, as described in <a class="xref" href="#Virtual_Modifiers" title="Chapter 7. Virtual Modifiers">Chapter 7, <em>Virtual Modifiers</em></a>. To convert between the two formats, Xkb
provides the following convenience macros:
</p><a id="idm13823" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSARedirectVMods"></a><p><code class="funcdef">unsigned int <strong class="fsfunc">XkbSARedirectVMods</strong>(</code>XkbRedirectKeyAction <var class="pdparam">act</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action from which to extract vmods
      </p></td></tr></tbody></table></div><p>
     <code class="function">XkbSARedirectVModsMask</code> returns the <em class="structfield"><code>vmods0</code></em>
     and <em class="structfield"><code>vmods1</code></em> fields of <em class="parameter"><code>act</code></em>
     converted to an unsigned int.
</p><a id="idm13843" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSARedirectSetVMods"></a><p><code class="funcdef">void <strong class="fsfunc">XkbSARedirectSetVMods</strong>(</code>XkbRedirectKeyAction <var class="pdparam">act</var>, unsigned int <var class="pdparam">v</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>act</code></em>
    </span></p></td><td><p>
        action in which to set vmods
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>v</code></em>
    </span></p></td><td><p>
        new value for virtual modifiers
      </p></td></tr></tbody></table></div><p>
     <code class="function">XkbSARedirectSetVModsMask</code> sets the <em class="structfield"><code>vmods0</code></em>
     and <em class="structfield"><code>vmods1</code></em> of <em class="parameter"><code>act</code></em> from <em class="parameter"><code>v</code></em>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Generating_DeviceButtonPress_and_DeviceButtonRelease"></a>Actions for Generating DeviceButtonPress and DeviceButtonRelease</h3></div></div></div><a id="idm13873" class="indexterm"></a><p>
Actions associated with
<span class="structname">XkbDeviceBtnAction</span>
structures generate
<span class="symbol">DeviceButtonPress</span>
and
<span class="symbol">DeviceButtonRelease</span>
events instead of normal
<span class="symbol">KeyPress</span>
and
<span class="symbol">KeyRelease</span>
events:

</p><pre class="programlisting">
typedef struct _XkbDeviceBtnAction {
    unsigned char    type;      /* <span class="symbol">XkbSA_DeviceBtn</span>, <span class="symbol">XkbSA_LockDeviceBtn</span> */
    unsigned char    flags;     /* with <em class="structfield"><code>type</code></em>, specifies locking or unlocking */
    unsigned char    count;     /* controls number of DeviceButtonPress
                                   and Release events */
    unsigned char    button;    /* index of button on <em class="structfield"><code>device</code></em> */
    unsigned char    device;    /* device ID of an X input extension device */
} <span class="structname">XkbDeviceBtnAction</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field can have any one of the values shown in
<a class="link" href="#table16.17" title="Table 16.17. Device Button Action Types">Table 16.17</a>.
</p><div class="table"><a id="table16.17"></a><p class="title"><strong>Table 16.17. Device Button Action Types</strong></p><div class="table-contents"><table class="table" summary="Device Button Action Types" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_DeviceBtn</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If the button specified by this action is logically down, the key press and
corresponding release are ignored and have no effect. If the device or button
specified by this action are illegal, this action behaves like
<span class="symbol">XkbSA_NoAction</span>.
    </p></li><li class="listitem"><p>
Otherwise, key presses cause one or more input extension device events instead
of the usual key press event. If the
<em class="structfield"><code>count</code></em>
field is zero, a key press generates a single
<span class="symbol">DeviceButtonPress</span>
event. If count is greater than zero, a key press event generates
<em class="structfield"><code>count</code></em>
pairs of
<span class="symbol">DeviceButtonPress</span>
and
<span class="symbol">DeviceButtonRelease</span>
events.
    </p></li><li class="listitem"><p>
If
<em class="structfield"><code>count</code></em>
is zero, a key release generates an input extension
<span class="symbol">DeviceButtonRelease</span>
event that matches the event generated by the corresponding key press. If
<em class="structfield"><code>count</code></em>
is nonzero, a key release does not cause a
<span class="symbol">DeviceButtonRelease</span>
event. Key releases never cause
<span class="symbol">KeyRelease</span>
events.
    </p></li></ul></div>
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockDeviceBtn</span></td><td align="left">
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If the device or button specified by this action are illegal, this action
behaves like <span class="symbol">XkbSA_NoAction</span>.
    </p></li><li class="listitem"><p>
Otherwise, if the specified button is not locked and the
<span class="symbol">XkbSA_LockNoLock</span>
bit is not set in the
<em class="structfield"><code>flags</code></em>
field, a key press generates an input extension
<span class="symbol">DeviceButtonPress</span>
event instead of a
<span class="symbol">KeyPress</span>
event and locks the button. If the button is already locked or if
<span class="symbol">XkbSA_LockNoLock</span>
bit is set in the
<em class="structfield"><code>flags</code></em>
field, the key press is ignored and has no effect.
    </p></li><li class="listitem"><p>
If the corresponding key press was ignored, and if the
<span class="symbol">XkbSA_LockNoUnlock</span>
bit is not set in the
<em class="structfield"><code>flags</code></em>
field, a key release generates an input extension
<span class="symbol">DeviceButtonRelease</span>
event instead of a
<span class="symbol">KeyRelease</span>
event and unlocks the button. If the corresponding key press locked a button,
the key release is ignored and has no effect.
    </p></li></ul></div>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>flags</code></em>
field is composed of the bitwise inclusive OR of the masks shown in
<a class="link" href="#table16.18" title="Table 16.18. Device Button Action Flags">Table 16.18</a>.
</p><div class="table"><a id="table16.18"></a><p class="title"><strong>Table 16.18. Device Button Action Flags</strong></p><div class="table-contents"><table class="table" summary="Device Button Action Flags" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Flag</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_LockNoLock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockDeviceBtn</span>,
the server only unlocks the button.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_LockNoUnlock</span></td><td align="left">
If set, and the action type is
<span class="symbol">XkbSA_LockDeviceBtn</span>,
the server only locks the button.
    </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Actions_for_Simulating_Events_from_Device_Valuators"></a>Actions for Simulating Events from Device Valuators</h3></div></div></div><a id="idm13970" class="indexterm"></a><p>
A
<em class="firstterm">valuator</em>
<a id="idm13975" class="indexterm"></a>
manipulates a range of values for some entity, like a mouse axis, a slider or
a dial. Actions associated with
<span class="structname">XkbDeviceValuatorAction</span>
structures are used to simulate events from one or two input extension device
valuators.
</p><pre class="programlisting">
typedef struct _XkbDeviceValuatorAction {
    unsigned char    type;        /* <span class="symbol">XkbSA_DeviceValuator</span> */
    unsigned char    device;      /* device ID */
    unsigned char    v1_what;     /* determines how valuator is
                                     to behave for valuator 1 */
    unsigned char    v1_ndx;      /* specifies a real valuator */
    unsigned char    v1_value;    /* the value for valuator 1 */
    unsigned char    v2_what;     /* determines how valuator is
                                     to behave for valuator 2 */
    unsigned char    v2_ndx;      /* specifies a real valuator */
    unsigned char    v2_value;    /* the value for valuator 1 */
} <span class="structname">XkbDeviceValuatorAction</span>;
</pre><p>
If
<em class="structfield"><code>device</code></em>
is illegal or if neither
<em class="structfield"><code>v1_ndx</code></em>
nor
<em class="structfield"><code>v2_ndx</code></em>
specifies a legal valuator, this action behaves like
<span class="symbol">XkbSA_NoAction</span>.
</p><p>
The low four bits of
<em class="structfield"><code>v1_what</code></em>
and
<em class="structfield"><code>v2_what</code></em>
specify the corresponding scale value (denoted
<em class="structfield"><code>val&lt;n&gt;Scale</code></em>
in <a class="link" href="#table16.17" title="Table 16.17. Device Button Action Types">Table 16.17</a>), if needed.
The high four bits of
<em class="structfield"><code>v1_what</code></em>
and
<em class="structfield"><code>v2_what</code></em>
specify the operation to perform to set the values. The high four bits of
<em class="structfield"><code>v1_what</code></em>
and
<em class="structfield"><code>v2_what</code></em>
can have the values shown in <a class="link" href="#table16.17" title="Table 16.17. Device Button Action Types">Table 16.17</a>;
the use of
<em class="structfield"><code>val&lt;n&gt;Scale</code></em>
is shown in that table also.
</p><div class="table"><a id="table16.19"></a><p class="title"><strong>Table 16.19. Device Valuator v&lt;n&gt;_what High Bits Values</strong></p><div class="table-contents"><table class="table" summary="Device Valuator v&lt;n&gt;_what High Bits Values" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Value of high bits</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSA_IgnoreVal</span></td><td align="left">No action</td></tr><tr><td align="left"><span class="symbol">XkbSA_SetValMin</span></td><td align="left">
<em class="structfield"><code>v&lt;n&gt;_value</code></em> is set to its minimum legal value.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_SetValCenter</span></td><td align="left">
<em class="structfield"><code>v&lt;n&gt;_value</code></em>is centered (to (max-min)/2).
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_SetValMax</span></td><td align="left">
<em class="structfield"><code>v&lt;n&gt;_value</code></em> is set to its maximum legal value.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_SetValRelative</span></td><td align="left">
<em class="structfield"><code>v&lt;n&gt;_value</code></em> * (2
<em class="structfield"><code>val&lt;n&gt;Scale</code></em>) is added to
<em class="structfield"><code>v&lt;n&gt;_value</code></em>.
    </td></tr><tr><td align="left"><span class="symbol">XkbSA_SetValAbsolute</span></td><td align="left">
<em class="structfield"><code>v&lt;n&gt;_value</code></em>
is set to (2 <em class="structfield"><code>val&lt;n&gt;Scale</code></em>).
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
Illegal values for
<span class="symbol">XkbSA_SetValRelative</span>
or
<span class="symbol">XkbSA_SetValAbsolute</span>
are clamped into range. Note that all of these possibilities are legal for
absolute valuators. For relative valuators, only
<span class="symbol">XkbSA_SetValRelative</span>
is permitted. Part of the input extension description of a device is the range
of legal values for all absolute valuators, whence the maximum and minimum
legal values shown in <a class="link" href="#table16.17" title="Table 16.17. Device Button Action Types">Table 16.17</a>.
</p><p>
The following two masks are provided as a convenience to select either portion
of
<em class="structfield"><code>v1_what</code></em>
or
<em class="structfield"><code>v2_what</code></em>:

</p><pre class="programlisting">
#define XkbSA_ValOpMask         (0x70)
#define XkbSA_ValScaleMask      (0x07)
</pre><p>
</p><p>
<em class="structfield"><code>v1_ndx</code></em>
and
<em class="structfield"><code>v2_ndx</code></em>
specify valuators that actually exists. For example, most mice have two
valuators (x and y axes) so the only legal values for a mouse would be 0 and 1.
For a dial box with eight dials, any value in the range 0..7 would be correct.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Obtaining_Key_Actions_for_Keys_from_the_Server"></a>Obtaining Key Actions for Keys from the Server</h3></div></div></div><p>
To update the actions (the
<em class="structfield"><code>key_acts</code></em>
array) for a subset of the keys in a keyboard description, use
<code class="function">XkbGetKeyActions</code>.
</p><a id="idm14057" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyActions"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeyActions</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        keycode of first key of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        number of keys desired
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        pointer to keyboard description where result is stored
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyActions</code>
sends a request to the server to obtain the actions for
<em class="parameter"><code>num</code></em>
keys on the keyboard starting with key
<em class="parameter"><code>first</code></em>.
It waits for a reply and returns the actions in the
<em class="structfield"><code>server</code></em>-&gt;<em class="structfield"><code>key_acts</code></em>
field of
<em class="parameter"><code>xkb</code></em>.
If successful,
<code class="function">XkbGetKeyActions</code>
returns
<span class="symbol">Success</span>.
The
<em class="parameter"><code>xkb</code></em>
parameter must be a pointer to a valid Xkb keyboard description.
</p><p>
If the
<em class="structfield"><code>server</code></em>
map in the
<em class="parameter"><code>xkb</code></em>
parameter has not been allocated,
<code class="function">XkbGetKeyActions</code>
allocates and initializes it before obtaining the actions.
</p><p>
If the server does not have a compatible version of Xkb, or the Xkb extension
has not been properly initialized,
<code class="function">XkbGetKeyActions</code>
returns
<span class="errorname">BadAccess</span>.
If
<em class="parameter"><code>num</code></em>
is less than 1 or greater than
<span class="symbol">XkbMaxKeyCount</span>,
<code class="function">XkbGetKeyActions</code>
returns
<span class="errorname">BadValue</span>.
If any allocation errors occur,
<code class="function">XkbGetKeyActions</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Changing_the_Number_of_Actions_Bound_to_a_Key"></a>Changing the Number of Actions Bound to a Key</h3></div></div></div><p>
To change the number of actions bound to a key, use
<code class="function">XkbResizeKeyActions</code>.
</p><a id="idm14120" class="indexterm"></a><div class="funcsynopsis"><a id="XkbResizeKeyActions"></a><p><code class="funcdef">XkbAction *<strong class="fsfunc">XkbResizeKeyActions</strong>(</code>XkbDescRec *<var class="pdparam">xkb</var>, int <var class="pdparam">key</var>, int <var class="pdparam">needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>key</code></em>
    </span></p></td><td><p>
        keycode of key to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>needed</code></em>
    </span></p></td><td><p>
        new number of actions required
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>xkb</code></em>
parameter points to the keyboard description containing the
<em class="parameter"><code>key</code></em>
whose number of actions is to be changed. The
<em class="parameter"><code>key</code></em>
parameter is the keycode of the key to change, and
<em class="parameter"><code>needed</code></em>
specifies the new number of actions required for the key.
</p><p>
<code class="function">XkbResizeKeyActions</code>
reserves the space needed for the actions and returns a pointer to the
beginning of the new array that holds the actions. It can change the
<em class="structfield"><code>acts</code></em>,
<em class="structfield"><code>num_acts</code></em>,
and
<em class="structfield"><code>size_acts</code></em>
fields of
<em class="parameter"><code>xkb</code></em>-&gt;<em class="structfield"><code>server</code></em>
if it is necessary to reallocate the
<em class="structfield"><code>acts</code></em>
array.
</p><p>
If
<em class="parameter"><code>needed</code></em>
is greater than the current number of keysyms for the key,
<code class="function">XkbResizeKeyActions</code>
initializes all new actions in the array to
<span class="emphasis"><em>NoAction</em></span>.
</p><p>
Because the number of actions needed by a key is normally computed as width *
number of groups, and
<code class="function">XkbResizeKeyActions</code>
does not modify either the width or number of groups for the key, a
discrepancy exists on return from
<code class="function">XkbResizeKeyActions</code>
between the space allocated for the actions and the number required. The
unused entries in the list of actions returned by
<code class="function">XkbResizeKeyActions</code>
are not preserved across future calls to any of the map editing functions, so
you must update the key actions (which updates the width and number of groups
for the key) before calling another allocator function. A call to
<code class="function">XkbChangeTypesOfKey</code>
updates these.
</p><p>
If any allocation errors occur while resizing the number of actions bound to
the key,
<code class="function">XkbResizeKeyActions</code>
returns
<span class="symbol">NULL</span>.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A change to the number of actions bound to a key should be
accompanied by a change in the number of symbols bound to a key. Refer to
<a class="link" href="#Changing_the_Number_of_Symbols_Bound_to_a_Key" title="Changing the Number of Symbols Bound to a Key">section 15.3.7</a> for more information on changing the number of symbols bound to
a key.</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Key_Behavior"></a>Key Behavior</h2></div></div></div><p>
Key behavior refers to the demeanor of a key. For example, the expected
behavior of the
<span class="keycap"><strong>CapsLock</strong></span>
key is that it logically locks when pressed, and then logically unlocks when
pressed again.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Radio_Groups_2"></a>Radio Groups</h3></div></div></div><p>
Keys that belong to the same radio group have the
<span class="symbol">XkbKB_RadioGroup</span>
type in the
<em class="structfield"><code>type</code></em>
field and the radio group index specified in the
<em class="structfield"><code>data</code></em>
field in the
<span class="structname">XkbBehavior</span>
structure. If the radio group has a name in the
<span class="structname">XkbNamesRec</span>
structure, the radio group index is the index into the
<em class="structfield"><code>radio_group</code></em>
array in the
<span class="structname">XkbNamesRec</span>
structure. A radio group key when pressed stays logically down until another
key in the radio group is pressed, when the first key becomes logically up and
the new key becomes logically down. Setting the
<span class="symbol">XkbKB_RGAllowNone</span>
bit in the behavior for all of the keys of the radio group means that pressing
the logically down member of the radio group causes it to logically release, in
which case none of the keys of the radio group would be logically down. If
<span class="symbol">XkbKB_RGAllowNone</span>
is not set, there is no way to release the logically down member of the group.
</p><p>
The low five bits of the
<em class="structfield"><code>data</code></em>
field of the
<span class="structname">XkbBehavior</span>
structure are the group number, the high three bits are flags. The only flag
currently defined is:

</p><pre class="programlisting">
#define      XkbKB_RGAllowNone      0x80
</pre></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="The_XkbBehavior_Structure"></a>The XkbBehavior Structure</h3></div></div></div><a id="idm14199" class="indexterm"></a><p>
The
<em class="structfield"><code>behaviors</code></em>
field of the server map is an array of
<span class="structname">XkbBehavior</span>
structures, indexed by keycode, and contains the behavior for each key. The
<span class="structname">XkbBehavior</span>
structure is defined as follows:

</p><pre class="programlisting">
typedef struct _XkbBehavior {
    unsigned char  type;              /* behavior type + optional
                                         <span class="symbol">XkbKB_Permanent</span> bit */
    unsigned char  data;
} <span class="structname">XkbBehavior</span>;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field specifies the Xkb behavior, and the value of the
<em class="structfield"><code>data</code></em>
field depends on the
<em class="structfield"><code>type</code></em>.
Xkb supports the key behaviors shown in
<a class="link" href="#table16.20" title="Table 16.20. Key Behaviors">Table 16.20</a>.
</p><div class="table"><a id="table16.20"></a><p class="title"><strong>Table 16.20. Key Behaviors</strong></p><div class="table-contents"><table class="table" summary="Key Behaviors" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /></colgroup><thead><tr><th align="left">Type</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbKB_Default</span></td><td align="left">
Press and release events are processed normally. The
<em class="structfield"><code>data</code></em>
field is unused.
    </td></tr><tr><td align="left"><span class="symbol">XkbKB_Lock</span></td><td align="left">
If a key is logically up (that is, the corresponding bit of the core key map is
cleared) when it is pressed, the key press is processed normally and the
corresponding release is ignored. If the key is logically down when pressed,
the key press is ignored but the corresponding release is processed normally.
The
<em class="structfield"><code>data</code></em>
field is unused.
    </td></tr><tr><td align="left"><span class="symbol">XkbKB_RadioGroup</span></td><td align="left">
      <p>
If another member of the radio group is logically down (all members of the
radio group have the same index, specified in
<em class="structfield"><code>data</code></em>)
when a key is pressed, the server synthesizes a key release for the member
that is logically down and then processes the new key press event normally.
      </p>
      <p>
If the key itself is logically down when pressed, the key press event is
ignored, but the processing of the corresponding key release depends on the
value of the
<span class="symbol">XkbKB_RGAllowNone</span>
bit in
<em class="structfield"><code>flags</code></em>.
If it is set, the key release is processed normally; otherwise, the key
release is also ignored.
      </p>
      <p>
All other key release events are ignored.
      </p>
    </td></tr><tr><td align="left"><span class="symbol">XkbKB_Overlay1</span></td><td align="left">
If the
<span class="emphasis"><em>Overlay1</em></span>
control is enabled (see <a class="link" href="#Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls" title="Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)">section 10.4</a>),
<em class="structfield"><code>data</code></em>
is interpreted as a keycode, and events from this key are reported as if they
came from
<em class="structfield"><code>data</code></em>’s
keycode. Otherwise, press and release events are processed normally.
    </td></tr><tr><td align="left"><span class="symbol">XkbKB_Overlay2</span></td><td align="left">
If the
<span class="emphasis"><em>Overlay2</em></span>
control is enabled (see <a class="link" href="#Controls_for_Keyboard_Overlays_Overlay1_and_Overlay2_Controls" title="Controls for Keyboard Overlays (Overlay1 and Overlay2 Controls)">section 10.4</a>),
<em class="structfield"><code>data</code></em>
is interpreted as a keycode, and events from this key are reported as if they
came from
<em class="structfield"><code>data</code></em>’s
keycode. Otherwise, press and release events are processed normally.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
Xkb also provides the mask,
<span class="symbol">XkbKB_Permanent</span>
to specify whether the key behavior type should be simulated by Xkb or whether
the key behavior describes an unalterable physical, electrical, or software
aspect of the keyboard. If the
<span class="symbol">XkbKB_Permanent</span>
bit is not set in the
<em class="structfield"><code>type</code></em>
field, Xkb simulates the behavior in software. Otherwise, Xkb relies upon the
keyboard to implement the behavior.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Obtaining_Key_Behaviors_for_Keys_from_the_Server"></a>Obtaining Key Behaviors for Keys from the Server</h3></div></div></div><p>
To obtain the behaviors (the
<em class="structfield"><code>behaviors</code></em>
array) for a subset of the keys in a keyboard description from the server, use
<code class="function">XkbGetKeyBehaviors</code>:

</p><a id="idm14269" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyBehaviors"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeyBehaviors</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        keycode of first key to get
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        number of keys for which behaviors are desired
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description to contain the result
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyBehaviors</code>
sends a request to the server to obtain the behaviors for
<em class="parameter"><code>num</code></em>
keys on the keyboard starting with the key whose keycode is
<em class="parameter"><code>first</code></em>.
It waits for a reply and returns the behaviors in the
<em class="structfield"><code>server</code></em>-&gt;<em class="structfield"><code>behaviors</code></em>
field of
<em class="parameter"><code>xkb</code></em>.
If successful,
<code class="function">XkbGetKeyBehaviors</code>
returns
<span class="symbol">Success</span>.
</p><p>
If the
<em class="structfield"><code>server</code></em>
map in the
<em class="parameter"><code>xkb</code></em>
parameter has not been allocated,
<code class="function">XkbGetKeyBehaviors</code>
allocates and initializes it before obtaining the actions.
</p><p>
If the server does not have a compatible version of Xkb, or the Xkb extension
has not been properly initialized,
<code class="function">XkbGetKeyBehaviors</code>
returns
<span class="errorname">BadAccess</span>.
If
<em class="parameter"><code>num</code></em>
is less than 1 or greater than
<span class="symbol">XkbMaxKeyCount</span>,
<code class="function">XkbGetKeyBehaviors</code>
returns
<span class="errorname">BadValue</span>.
If any allocation errors occur,
<code class="function">XkbGetKeyBehaviors</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server"></a>Explicit Components—Avoiding Automatic Remapping by the Server</h2></div></div></div><p>
Whenever a client remaps the keyboard using core protocol requests, Xkb
examines the map to determine likely default values for the components that
cannot be specified using the core protocol (see <a class="link" href="#Core_Keyboard_Mapping_to_Xkb_Keyboard_Mapping_Transformation" title="Core Keyboard Mapping to Xkb Keyboard Mapping Transformation">section 17.1.2</a> for more
information on how Xkb chooses the default values).
</p><p>
This automatic remapping might replace definitions explicitly requested by an
application, so the Xkb keyboard description defines an explicit components
mask for each key. Any aspects of the automatic remapping listed in the
explicit components mask for a key are not changed by the automatic keyboard
mapping.
</p><p>
The explicit components masks are held in the
<em class="structfield"><code>explicit</code></em>
field of the server map, which is an array indexed by keycode. Each entry in
this array is a mask that is a bitwise inclusive OR of the values shown in
<a class="link" href="#table16.21" title="Table 16.21. Explicit Component Masks">Table 16.21</a>.
</p><div class="table"><a id="table16.21"></a><p class="title"><strong>Table 16.21. Explicit Component Masks</strong></p><div class="table-contents"><table class="table" summary="Explicit Component Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Bit in Explicit Mask</th><th align="left">Value</th><th align="left">Protects Against</th></tr></thead><tbody><tr><td align="left"><span class="emphasis"><em>ExplicitKeyType1</em></span></td><td align="left">(1&lt;&lt;0)</td><td align="left">
Automatic determination of the key type associated with
<span class="emphasis"><em>Group1</em></span>.
    </td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitKeyType2</em></span></td><td align="left">(1&lt;&lt;1)</td><td align="left">
Automatic determination of the key type associated with
<span class="emphasis"><em>Group2</em></span>.
    </td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitKeyType3</em></span></td><td align="left">(1&lt;&lt;2)</td><td align="left">
Automatic determination of the key type associated with
<span class="emphasis"><em>Group3</em></span>.
    </td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitKeyType4</em></span></td><td align="left">(1&lt;&lt;3)</td><td align="left">
Automatic determination of the key type associated with
<span class="emphasis"><em>Group4</em></span>.
    </td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitInterpret</em></span></td><td align="left">(1&lt;&lt;4)</td><td align="left">
Application of any of the fields of a symbol interpretation to the
key in question.
    </td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitAutoRepeat</em></span></td><td align="left">(1&lt;&lt;5)</td><td align="left">Automatic determination of auto-repeat status for the key, as
specified in a symbol interpretation.</td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitBehavior</em></span></td><td align="left">(1&lt;&lt;6)</td><td align="left">
Automatic assignment of the
<span class="symbol">XkbKB_Lock</span>
behavior to the key, if the
<span class="symbol">XkbSI_LockingKey</span>
flag is set in a symbol interpretation.
    </td></tr><tr><td align="left"><span class="emphasis"><em>ExplicitVModMap</em></span></td><td align="left">(1&lt;&lt;7)</td><td align="left">
Automatic determination of the virtual modifier map for the key
based on the actions assigned to the key and the symbol interpretations that
match the key.
    </td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Obtaining_Explicit_Components_for_Keys_from_the_Server"></a>Obtaining Explicit Components for Keys from the Server</h3></div></div></div><p>
To obtain the explicit components (the
<em class="structfield"><code>explicit</code></em>
array) for a subset of the keys in a keyboard description, use
<code class="function">XkbGetKeyExplicitComponents</code>.
</p><a id="idm14398" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyExplicitComponents"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeyExplicitComponents</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        keycode of first key to fetch
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        number of keys for which to get explicit info
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description in which to put results
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyExplicitComponents</code>
sends a request to the server to obtain the explicit components for
<em class="parameter"><code>num</code></em>
keys on the keyboard starting with key
<em class="parameter"><code>first</code></em>.
It waits for a reply and returns the explicit components in the
<em class="structfield"><code>server</code></em>-&gt;<em class="structfield"><code>explicit</code></em>
array of
<em class="parameter"><code>xkb</code></em>.
If successful,
<code class="function">XkbGetKeyExplicitComponents</code>
returns
<span class="symbol">Success</span>.
The
<em class="parameter"><code>xkb</code></em>
parameter must be a pointer to a valid Xkb keyboard description.
</p><p>
If the
<em class="structfield"><code>server</code></em>
map in the
<em class="parameter"><code>xkb</code></em>
parameter has not been allocated,
<code class="function">XkbGetKeyExplicitComponents</code>
allocates and initializes it before obtaining the actions.
</p><p>
If the server does not have a compatible version of Xkb, or the Xkb extension
has not been properly initialized,
<code class="function">XkbGetKeyExplicitComponents</code>
returns
<span class="errorname">BadMatch</span>.
If
<em class="parameter"><code>num</code></em>
is less than 1 or greater than
<span class="symbol">XkbMaxKeyCount</span>,
<code class="function">XkbGetKeyExplicitComponents</code>
returns
<span class="errorname">BadValue</span>.
If any allocation errors occur,
<code class="function">XkbGetKeyExplicitComponents</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Virtual_Modifier_Mapping"></a>Virtual Modifier Mapping</h2></div></div></div><p>
The
<em class="structfield"><code>vmods</code></em>
member of the server map is a fixed-length array containing
<span class="symbol">XkbNumVirtualMods</span>
entries. Each entry corresponds to a virtual modifier and provides the binding
of the virtual modifier to the real modifier bits. Each entry in the
<em class="structfield"><code>vmods</code></em>
array is a bitwise inclusive OR of the legal modifier masks:
</p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="symbol">ShiftMask</span></td></tr><tr><td><span class="symbol">LockMask</span></td></tr><tr><td><span class="symbol">ControlMask</span></td></tr><tr><td><span class="symbol">Mod1Mask</span></td></tr><tr><td><span class="symbol">Mod2Mask</span></td></tr><tr><td><span class="symbol">Mod3Mask</span></td></tr><tr><td><span class="symbol">Mod4Mask</span></td></tr><tr><td><span class="symbol">Mod5Mask</span></td></tr></table><p>
The
<em class="structfield"><code>vmodmap</code></em>
member of the server map is similar to the
<em class="structfield"><code>modmap</code></em>
array of the client map (see <a class="link" href="#The_Per_Key_Modifier_Map" title="The Per-Key Modifier Map">section 15.4</a>), but is used to define the virtual
modifier mapping for each key. Like the
<em class="structfield"><code>modmap</code></em>
member, it is indexed by keycode, and each entry is a mask representing the
virtual modifiers bound to the corresponding key:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Each of the bits in a
<em class="structfield"><code>vmodmap</code></em>
entry represents an index into the
<em class="structfield"><code>vmods</code></em>
member. That is, bit 0 of a
<em class="structfield"><code>vmodmap</code></em>
entry refers to index 0 of the
<em class="structfield"><code>vmods</code></em>
array, bit 1 refers to index 1, and so on.
    </p></li><li class="listitem"><p>
If a bit is set in the
<em class="structfield"><code>vmodmap</code></em>
entry for a key, that key is bound to the corresponding virtual modifier in
the
<em class="structfield"><code>vmods</code></em>
array.
    </p></li></ul></div><p>
The
<em class="structfield"><code>vmodmap</code></em>
and
<em class="structfield"><code>vmods</code></em>
members of the server map are the <span class="quote">“<span class="quote">master</span>”</span> virtual modifier definitions. Xkb
automatically propagates any changes to these fields to all other fields that
use virtual modifier mappings.
</p><p>
The overall relationship of fields dealing with virtual modifiers in an Xkb
keyboard description are shown in <a class="link" href="#figure16.2" title="Figure 16.2. Virtual Modifier Relationships">Figure 16.2</a>.
</p><div class="figure"><a id="figure16.2"></a><p class="title"><strong>Figure 16.2. Virtual Modifier Relationships</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-17.svg"></object></div></div></div><br class="figure-break" /><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Obtaining_Virtual_Modifier_Bindings_from_the_Server"></a>Obtaining Virtual Modifier Bindings from the Server</h3></div></div></div><p>
To obtain a subset of the virtual modifier bindings (the
<em class="structfield"><code>vmods</code></em>
array) in a keyboard description, use
<code class="function">XkbGetVirtualMods</code>:

</p><a id="idm14512" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetVirtualMods"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetVirtualMods</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask indicating virtual modifier bindings to get
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description where results will be placed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetVirtualMods</code>
sends a request to the server to obtain the
<em class="structfield"><code>vmods</code></em>
entries for the virtual modifiers specified in the mask,
<em class="parameter"><code>which</code></em>,
and waits for a reply. See <a class="link" href="#Virtual_Modifier_Names_and_Masks" title="Virtual Modifier Names and Masks">section 7.1</a> for a description of how to determine
the virtual modifier mask. For each bit set in
<em class="parameter"><code>which</code></em>,
<code class="function">XkbGetVirtualMods</code>
updates the corresponding virtual modifier definition in the
<em class="structfield"><code>server-&gt;vmods</code></em>
array of
<em class="parameter"><code>xkb</code></em>.
The
<em class="parameter"><code>xkb</code></em>
parameter must be a pointer to a valid Xkb keyboard description. If
successful,
<code class="function">XkbGetVirtualMods</code>
returns
<span class="symbol">Success</span>.
</p><p>
If the
<em class="structfield"><code>server</code></em>
map has not been allocated in the
<em class="parameter"><code>xkb</code></em>
parameter,
<code class="function">XkbGetVirtualMods</code>
allocates and initializes it before obtaining the virtual modifier bindings.
</p><p>
If the server does not have a compatible version of Xkb, or the Xkb extension
has not been properly initialized,
<code class="function">XkbGetVirtualMods</code>
returns
<span class="errorname">BadMatch</span>.
Any errors in allocation cause
<code class="function">XkbGetVirtualMods</code>
to return
<span class="errorname">BadAlloc</span>.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Obtaining_Per_Key_Virtual_Modifier_Mappings_from_the_Server"></a>Obtaining Per-Key Virtual Modifier Mappings from the Server</h3></div></div></div><p>
To obtain the virtual modifier map (the
<em class="structfield"><code>vmodmap</code></em>
array) for a subset of the keys in a keyboard description, use
<code class="function">XkbGetKeyVirtualModMap</code>:

</p><a id="idm14567" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyVirtualModMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetKeyVirtualModMap</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">first</var>, unsigned int <var class="pdparam">num</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first</code></em>
    </span></p></td><td><p>
        keycode of first key to fetch
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num</code></em>
    </span></p></td><td><p>
        # keys for which virtual mod maps are desired
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description where results will be placed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyVirtualModmap</code>
sends a request to the server to obtain the virtual modifier mappings for
<em class="parameter"><code>num</code></em>
keys on the keyboard starting with key
<em class="parameter"><code>first</code></em>.
It waits for a reply and returns the virtual modifier mappings in the
<em class="structfield"><code>server</code></em>-&gt;<em class="structfield"><code>vmodmap</code></em>
array of
<em class="parameter"><code>xkb</code></em>.
If successful,
<code class="function">XkbGetKeyVirtualModMap</code>
returns
<span class="symbol">Success</span>.
The
<em class="parameter"><code>xkb</code></em>
parameter must be a pointer to a valid Xkb keyboard description
</p><p>
If the
<em class="structfield"><code>server</code></em>
map in the
<em class="parameter"><code>xkb</code></em>
parameter has not been allocated,
<code class="function">XkbGetKeyVirtualModMap</code>
allocates and initializes it before obtaining the virtual modifier mappings.
</p><p>
If the server does not have a compatible version of Xkb, or the Xkb extension
has not been properly initialized,
<code class="function">XkbGetKeyVirtualModMap</code>
returns
<span class="errorname">BadMatch</span>.
If
<em class="parameter"><code>num</code></em>
is less than 1 or greater than
<span class="symbol">XkbMaxKeyCount</span>,
<code class="function">XkbGetKeyVirtualModMap</code>
returns
<span class="errorname">BadValue</span>.
If any allocation errors occur,
<code class="function">XkbGetKeyVirtualModMap</code>
returns
<span class="errorname">BadAlloc</span>.
</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="The_Xkb_Compatibility_Map"></a>Chapter 17. The Xkb Compatibility Map</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#The_XkbCompatMap_Structure">The XkbCompatMap Structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="#Xkb_State_to_Core_Protocol_State_Transformation">Xkb State to Core Protocol State Transformation</a></span></dt><dt><span class="sect2"><a href="#Core_Keyboard_Mapping_to_Xkb_Keyboard_Mapping_Transformation">Core Keyboard Mapping to Xkb Keyboard Mapping Transformation</a></span></dt><dt><span class="sect2"><a href="#Xkb_Keyboard_Mapping_to_Core_Keyboard_Mapping_Transformations">Xkb Keyboard Mapping to Core Keyboard Mapping Transformations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Getting_Compatibility_Map_Components_From_the_Server">Getting Compatibility Map Components From the Server</a></span></dt><dt><span class="sect1"><a href="#Using_the_Compatibility_Map">Using the Compatibility Map</a></span></dt><dt><span class="sect1"><a href="#Changing_the_Servers_Compatibility_Map">Changing the Server’s Compatibility Map</a></span></dt><dt><span class="sect1"><a href="#Tracking_Changes_to_the_Compatibility_Map">Tracking Changes to the Compatibility Map</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_the_Compatibility_Map">Allocating and Freeing the Compatibility Map</a></span></dt></dl></div><p>
As shown in <a class="link" href="#figure17.1" title="Figure 17.1. Server Interaction with Types of Clients">Figure 17.1</a>, the X server is normally dealing with more than one
client, each of which may be receiving events from the keyboard, and each of
which may issue requests to modify the keyboard in some manner. Each client may
be either Xkb-unaware, Xkb-capable, or Xkb-aware. The server itself may be
either Xkb-aware or Xkb-unaware. If the server is Xkb-unaware, Xkb state and
keyboard mappings are not involved in any manner, and Xkb-aware clients may not
issue Xkb requests to the server. If the server is Xkb-aware, the server must
be able to deliver events and accept requests in which the keyboard state and
mapping are compatible with the mode in which the client is operating.
Consequently, for some situations, conversions must be made between Xkb state /
keyboard mappings and core protocol state / keyboard mappings, and vice versa.
</p><div class="figure"><a id="figure17.1"></a><p class="title"><strong>Figure 17.1. Server Interaction with Types of Clients</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-18.svg"></object></div></div></div><br class="figure-break" /><p>
In addition to these situations involving a single server, there are cases
where a client that deals with multiple servers may need to configure keyboards
on different servers to be similar and the different servers may not all be
Xkb-aware. Finally, a client may be dealing with descriptions of keyboards
(files, and so on) that are based on core protocol and therefore may need to be
able to map these descriptions to Xkb descriptions.
</p><p>
An Xkb-aware server maintains keyboard state and mapping as an Xkb keyboard
state and an Xkb keyboard mapping plus a compatibility map used to convert from
Xkb components to core components and vice versa. In addition, the server also
maintains a core keyboard mapping that approximates the Xkb keyboard mapping.
The core keyboard mapping may be updated piecemeal, on a per-key basis. When
the server receives a core protocol
<code class="systemitem">ChangeKeyboardMapping</code>
or
<code class="systemitem">SetModifierMapping</code>
request, it updates its core keyboard mapping, then uses the compatibility map
to update its Xkb keyboard mapping. When the server receives an
<code class="function">XkbSetMap</code>
request, it updates those portions of its Xkb keyboard mapping specified by
the request, then uses its compatibility map to update the corresponding parts
of its core keyboard map. Consequently, the server’s Xkb keyboard map and
also its core keyboard map may contain components that were set directly and
others that were computed. <a class="link" href="#figure17.2" title="Figure 17.2. Server Derivation of State and Keyboard Mapping Components">Figure 17.2</a> illustrates these relationships.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The core keyboard map is contained only in the server, not in any
client-side data structures.</p></div><div class="figure"><a id="figure17.2"></a><p class="title"><strong>Figure 17.2. Server Derivation of State and Keyboard Mapping Components</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-19.svg"></object></div></div></div><br class="figure-break" /><p>
There are three kinds of compatibility transformations made by the server:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>Xkb State to Core State</strong></span></p><p>
Keyboard state information reported to a client in the state field of various
core events may be translated from the Xkb keyboard state maintained by the
server, which includes a group number, to core protocol state, which does
not.
    </p><p>
In addition, whenever the Xkb state is retrieved, the
<em class="structfield"><code>compat_state</code></em>,
<em class="structfield"><code>compat_grab_mods</code></em>,
and
<em class="structfield"><code>compat_lookup_mods</code></em>
fields of the
<span class="structname">XkbStateRec</span>
returned indicate the result of applying the compatibility map to the current
Xkb state in the server.
    </p></li><li class="listitem"><p><span class="bold"><strong>Core Keyboard Mapping to Xkb Keyboard Mapping</strong></span></p><p>
After core protocol requests received by the server to change the keyboard
mapping
(<code class="systemitem">ChangeKeyboardMapping</code>
and
<code class="systemitem">SetModifierMapping</code>)
have been applied to the server’s core keyboard map, the results must be
transformed to achieve an equivalent change of the Xkb keyboard mapping
maintained by the server.
    </p></li><li class="listitem"><p><span class="bold"><strong>Xkb Keyboard Mapping to Core Keyboard Mapping</strong></span></p><p>
After Xkb protocol requests received by the server to change the keyboard
mapping
(<code class="function">XkbSetMap</code>)
have been applied to the server’s Xkb keyboard map, the results are
transformed to achieve an approximately equivalent change to the core keyboard
mapping maintained by the server.
    </p></li></ol></div><p>
This chapter discusses how a client may modify the compatibility map so that
subsequent transformations have a particular result.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_XkbCompatMap_Structure"></a>The XkbCompatMap Structure</h2></div></div></div><a id="idm14673" class="indexterm"></a><p>
All configurable aspects of mapping Xkb state and configuration to and from
core protocol state and configuration are defined by a compatibility map,
contained in an
<span class="structname">XkbCompatMapRec</span>
structure; plus a set of explicit override controls used to prevent particular
components of type 2 (core-to-Xkb keyboard mapping) transformations from
automatically occurring. These explicit override controls are maintained in a
separate data structure discussed in <a class="link" href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server" title="Explicit Components—Avoiding Automatic Remapping by the Server">section 16.3</a>.
</p><p>
The
<em class="structfield"><code>compat</code></em>
member of an Xkb keyboard description
(<span class="structname">XkbDescRec</span>)
points to the
<span class="structname">XkbCompatMapRec</span>
structure:

</p><pre class="programlisting">
typedef struct _XkbCompatMapRec {
      XkbSymInterpretPtr sym_interpret;    /* symbol based key semantics */
      XkbModsRec         groups[XkbNumKbdGroups]; /* group ⇒ modifier map */
      unsigned short     num_si;           /* # structures used in
                                                <em class="structfield"><code>sym_interpret</code></em> */
      unsigned short     size_si;          /* # structures allocated in
                                                <em class="structfield"><code>sym_interpret</code></em> */
} <span class="structname">XkbCompatMapRec</span>, *XkbCompatMapPtr;
</pre><div class="figure"><a id="figure17.3"></a><p class="title"><strong>Figure 17.3. Xkb Compatibility Data Structures</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-20.svg"></object></div></div></div><br class="figure-break" /><p>
The subsections that follow discuss how the compatibility map and explicit
override controls are used in each of the three cases where compatibility
transformations are made.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Xkb_State_to_Core_Protocol_State_Transformation"></a>Xkb State to Core Protocol State Transformation</h3></div></div></div><p>
As shown in <a class="link" href="#figure17.3" title="Figure 17.3. Xkb Compatibility Data Structures">Figure 17.3</a>, there are four
<em class="firstterm">group compatibility maps</em>
<a id="idm14698" class="indexterm"></a>
<a id="idm14700" class="indexterm"></a>
(contained in
<em class="structfield"><code>groups</code></em>
[0..3]) in the
<span class="structname">XkbCompatMapRec</span>
structure, one per possible Xkb group. Each group compatibility map is a
modifier definition (see <a class="link" href="#Modifier_Definitions" title="Modifier Definitions">section 7.2</a> for a description of modifier
definitions). The
<em class="structfield"><code>mask</code></em>
component of the definition specifies which real modifiers should be set in
the core protocol state field when the corresponding group is active. Because
only one group is active at any one time, only one of the four possible
transformations is ever applied at any one point in time. If the device
described by the
<span class="structname">XkbDescRec</span>
does not support four groups, the extra groups fields are present, but
undefined.
</p><p>
Normally, the Xkb-aware server reports keyboard state in the
<em class="structfield"><code>state</code></em>
member of events such as a
<span class="symbol">KeyPress</span>
event and
<span class="symbol">ButtonPress</span>
event, encoded as follows:
</p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c1" /></colgroup><thead><tr><th align="left">bits</th><th align="left">meaning</th></tr></thead><tbody><tr><td align="left">15</td><td align="left">0</td></tr><tr><td align="left">13–14</td><td align="left">Group index</td></tr><tr><td align="left">8–12</td><td align="left">Pointer Buttons</td></tr><tr><td align="left">0–7</td><td align="left">Modifiers</td></tr></tbody></table></div><p>
For Xkb-unaware clients, only core protocol keyboard information may be
reported. Because core protocol does not define the group index, the group
index is mapped to modifier bits as specified by the
<em class="structfield"><code>groups</code></em>
[group index] field of the compatibility map (the bits set in the compatibility
map are ORed into bits 0–7 of the state), and bits 13–14 are reported in the
event as zero.
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Core_Keyboard_Mapping_to_Xkb_Keyboard_Mapping_Transformation"></a>Core Keyboard Mapping to Xkb Keyboard Mapping Transformation</h3></div></div></div><p>
When a core protocol keyboard mapping request is received by the server, the
server’s core keyboard map is updated, and then the Xkb map maintained by the
server is updated. Because a client may have explicitly configured some of the
Xkb keyboard mapping in the server, this automatic regeneration of the Xkb
keyboard mapping from the core protocol keyboard mapping should not modify any
components of the Xkb keyboard mapping that were explicitly set by a client.
The client must set explicit override controls to prevent this from happening
(see <a class="link" href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server" title="Explicit Components—Avoiding Automatic Remapping by the Server">section 16.3</a>). The core-to-Xkb mapping is done as follows:
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
Map the symbols from the keys in the core keyboard map to groups and symbols on
keys in the Xkb keyboard map. The core keyboard mapping is of fixed width, so
each key in the core mapping has the same number of symbols associated with it.
The Xkb mapping allows a different number of symbols to be associated with each
key; those symbols may be divided into a different number of groups (1-4) for
each key. For each key, this process therefore involves partitioning the fixed
number of symbols from the core mapping into a set of variable-length groups
with a variable number of symbols in each group. For example, if the core
protocol map is of width five, the partition for one key might result in one
group with two symbols and another with three symbols. A different key might
result in two groups with two symbols plus a third group with one symbol. The
core protocol map requires at least two symbols in each of the first two
groups.
    </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
For each changed key, determine the number of groups represented in the new
core keyboard map. This results in a tentative group count for each key in the
Xkb map.
        </p></li><li class="listitem"><p>
For each changed key, determine the number of symbols in each of the groups
found in step 1a. There is one explicit override control associated with each
of the four possible groups for each Xkb key,
<span class="emphasis"><em>ExplicitKeyType1</em></span>
through
<span class="emphasis"><em>ExplicitKeyType4</em></span>.
If no explicit override control is set for a group, the number of symbols
used for that group from the core map is two.  If the explicit override control
is set for a group on the key, the number of symbols used for that Xkb group
from the core map is the width of the Xkb group with one exception: because of
the core protocol requirement for at least two symbols in each of groups one
and two, the number of symbols used for groups one and two is the maximum of 2
or the width of the Xkb group.
        </p></li><li class="listitem"><p>
For each changed key, assign the symbols in the core map to the appropriate
group on the key. If the total number of symbols required by the Xkb map for a
particular key needs more symbols than the core protocol map contains, the
additional symbols are taken to be
<span class="symbol">NoSymbol</span>
keysyms appended to the end of the core set. If the core map contains more
symbols than are needed by the Xkb map, trailing symbols in the core map are
discarded. In the absence of an explicit override for group one or two, symbols
are assigned in order by group; the first symbols in the core map are assigned
to group one, in order, followed by group two, and so on. For example, if the
core map contained eight symbols per key, and a particular Xkb map contained 2
symbols for G1 and G2 and three for G3, the symbols would be assigned as (G is
group, L is shift level):
        </p><div class="literallayout"><p><br />
          G1L1 G1L2 G2L1 G2L2 G3L1 G3L2 G3L3<br />
</p></div><p>
If an explicit override control is set for group one or two, the symbols are
taken from the core set in a somewhat different order. The first four symbols
from the core set are assigned to G1L1, G1L2, G2L1, G2L2, respectively. If
group one requires more symbols, they are taken next, and then any additional
symbols needed by group two. Group three and four symbols are taken in complete
sequence after group two. For example, a key with four groups and three symbols
in each group would take symbols from the core set in the following order:
        </p><div class="literallayout"><p><br />
G1L1 G1L2 G2L1 G2L2 G1L3 G2L3 G3L1 G3L2 G3L3 G4L1 G4L2 G4L3<br />
</p></div><p>
As previously noted, the core protocol map requires at lease two symbols in
groups one and two. Because of this, if an explicit override control for an Xkb
key is set and group one and / or group two is of width one, it is not possible
to generate the symbols taken from the core protocol set and assigned to
position G1L2 and / or G2L2.
        </p></li><li class="listitem"><p>
For each group on each changed key, assign a key type appropriate for the
symbols in the group.
        </p></li><li class="listitem"><p>
For each changed key, remove any empty or redundant groups.
        </p></li></ol></div></li><li class="listitem"><p>
At this point, the groups and their associated symbols have been assigned to
the corresponding key definitions in the Xkb map.
    </p></li><li class="listitem"><p>
Apply symbol interpretations to modify key operation. This phase is completely
skipped if the
<span class="emphasis"><em>ExplicitInterpret</em></span>
override control bit is set in the explicit controls mask for the Xkb key (see
<a class="link" href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server" title="Explicit Components—Avoiding Automatic Remapping by the Server">section 16.3</a>).
    </p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p>
For each symbol on each changed key, attempt to match the symbol and modifiers
from the Xkb map to a symbol interpretation describing how to generate the
symbol.
        </p></li><li class="listitem"><p>
When a match is found in step 2a, apply the symbol interpretation to change the
semantics associated with the symbol in the Xkb key map. If no match is found,
apply a default interpretation.
        </p></li></ol></div></li></ol></div><p>
The symbol interpretations used in step 2 are configurable and may be specified
using
<span class="structname">XkbSymInterpretRec</span>
structures referenced by the
<em class="structfield"><code>sym_interpret</code></em>
field of an
<span class="structname">XkbCompatMapRec</span>
(see <a class="link" href="#figure17.3" title="Figure 17.3. Xkb Compatibility Data Structures">Figure 17.3</a>).
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="Symbol_Interpretations__the_XkbSymInterpretRec_Structure"></a>Symbol Interpretations — the XkbSymInterpretRec Structure</h4></div></div></div><a id="idm14778" class="indexterm"></a><p>
Symbol interpretations are used to guide the X server when it modifies the Xkb
keymap in step 2. An initial set of symbol interpretations is loaded by the
server when it starts. A client may add new ones using
<code class="function">XkbSetCompatMap</code>
(see <a class="link" href="#Changing_the_Servers_Compatibility_Map" title="Changing the Server’s Compatibility Map">section 17.4</a>).
</p><p>
Symbol interpretations result in key semantics being set. When a symbol
interpretation is applied, the following components of server key event
processing may be modified for the particular key involved:

  </p><table border="0" summary="Simple list" class="simplelist"><tr><td>Virtual modifier map</td></tr><tr><td>Auto repeat</td></tr><tr><td>Key behavior (may be set to <span class="symbol">XkbKB_Lock</span>)</td></tr><tr><td>Key action (see <a class="link" href="#Key_Actions" title="Key Actions">section 16.1</a>)</td></tr></table><p>
</p><p>
The <span class="structname">XkbSymInterpretRec</span>
structure specifies a symbol interpretation:

</p><pre class="programlisting">
typedef struct {
    KeySym          sym;          /* keysym of interest or <span class="symbol">NULL</span> */
    unsigned char   flags;        /* <span class="symbol">XkbSI_AutoRepeat</span>, <span class="symbol">XkbSI_LockingKey</span> */
    unsigned char   match;        /* specifies how mods is interpreted */
    unsigned char   mods;         /* modifier bits, correspond to
                                     eight real modifiers */
    unsigned char   virtual_mod;  /* 1 modifier to add to key virtual mod map */
    XkbAnyAction    act;          /* action to bind to symbol position on key */
} <span class="structname">XkbSymInterpretRec</span>,*XkbSymInterpretPtr;
</pre><p>
If
<em class="structfield"><code>sym</code></em>
is not
<span class="symbol">NULL</span>,
it limits the symbol interpretation to keys on which that particular keysym
is selected by the modifiers matching the criteria specified by
<em class="structfield"><code>mods</code></em>
and
<em class="structfield"><code>match</code></em>.
If
<em class="structfield"><code>sym</code></em>
is
<span class="symbol">NULL</span>,
the interpretation may be applied to any symbol selected on a key when the
modifiers match the criteria specified by
<em class="structfield"><code>mods</code></em>
and
<em class="structfield"><code>match</code></em>.
</p><p>
<em class="structfield"><code>match</code></em>
must be one of the values shown in
<a class="link" href="#table17.1" title="Table 17.1. Symbol Interpretation Match Criteria">Table 17.1</a> and specifies how the real
modifiers specified in <em class="structfield"><code>mods</code></em>
are to be interpreted.
</p><div class="table"><a id="table17.1"></a><p class="title"><strong>Table 17.1. Symbol Interpretation Match Criteria</strong></p><div class="table-contents"><table class="table" summary="Symbol Interpretation Match Criteria" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Match Criteria</th><th align="left">Value</th><th align="left">Effect</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSI_NoneOf</span></td><td align="left">(0)</td><td align="left">
None of the bits that are on in <em class="structfield"><code>mods</code></em>
can be set, but other bits can be.
    </td></tr><tr><td align="left"><span class="symbol">XkbSI_AnyOfOrNone</span></td><td align="left">(1)</td><td align="left">
Zero or more of the bits that are on in
<em class="structfield"><code>mods</code></em>
can be set, as well as others.
    </td></tr><tr><td align="left"><span class="symbol">XkbSI_AnyOf</span></td><td align="left">(2)</td><td align="left">
One or more of the bits that are on in
<em class="structfield"><code>mods</code></em>
can be set, as well as any others.
    </td></tr><tr><td align="left"><span class="symbol">XkbSI_AllOf</span></td><td align="left">(3)</td><td align="left">
All of the bits that are on in
<em class="structfield"><code>mods</code></em>
must be set, but others may be set as well.
    </td></tr><tr><td align="left"><span class="symbol">XkbSI_Exactly</span></td><td align="left">(4)</td><td align="left">
All of the bits that are on in
<em class="structfield"><code>mods</code></em>
must be set, and no other bits may be set.
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
In addition to the above bits,
<em class="structfield"><code>match</code></em>
may contain the
<span class="symbol">XkbSI_LevelOneOnly</span>
bit, in which case the modifier match criteria specified by
<em class="structfield"><code>mods</code></em>
and
<em class="structfield"><code>match</code></em>
applies only if
<em class="structfield"><code>sym</code></em>
is in level one of its group; otherwise,
<em class="structfield"><code>mods</code></em>
and
<em class="structfield"><code>match</code></em>
are ignored and the symbol matches a condition where no modifiers are set.
</p><pre class="programlisting">
#define XkbSI_LevelOneOnly  (0x80)
/* use mods + match only if sym is level 1 */
</pre><p>
If no matching symbol interpretation is found, the server uses a default
interpretation where:
</p><div class="informaltable"><table class="informaltable" border="0"><colgroup><col align="left" class="c1" /><col align="left" class="c1" /></colgroup><tbody><tr><td align="left"><em class="structfield"><code>sym</code></em> =</td><td align="left">0</td></tr><tr><td align="left"><em class="structfield"><code>flags</code></em> =</td><td align="left"><span class="symbol">XkbSI_AutoRepeat</span></td></tr><tr><td align="left"><em class="structfield"><code>match</code></em> =</td><td align="left"><span class="symbol">XkbSI_AnyOfOrNone</span></td></tr><tr><td align="left"><em class="structfield"><code>mods</code></em> =</td><td align="left">0</td></tr><tr><td align="left"><em class="structfield"><code>virtual_mod</code></em> =</td><td align="left"><span class="symbol">XkbNoModifier</span></td></tr><tr><td align="left"><em class="structfield"><code>act</code></em> =</td><td align="left"><span class="emphasis"><em>SA_NoAction</em></span></td></tr></tbody></table></div><p>
When a matching symbol interpretation is found in step 2a, the interpretation
is applied to modify the Xkb map as follows.
</p><p>
The
<em class="structfield"><code>act</code></em>
field specifies a single action to be bound to the symbol position; any key
event that selects the symbol causes the action to be taken. Valid actions are
defined in <a class="link" href="#Key_Actions" title="Key Actions">section 16.1</a>.
</p><p>
If the Xkb keyboard map for the key does not have its
<span class="emphasis"><em>ExplicitVModMap</em></span>
control set, the
<span class="symbol">XkbSI_LevelOneOnly</span>
bit and symbol position are examined. If the
<span class="symbol">XkbSI_LevelOneOnly</span>
bit is not set in
<em class="structfield"><code>match</code></em>
or the symbol is in position G1L1, the
<em class="structfield"><code>virtual_mod</code></em>
field is examined. If
<em class="structfield"><code>virtual_mod</code></em>
is not
<span class="symbol">XkbNoModifier</span>,
<em class="structfield"><code>virtual_mod</code></em>
specifies a single virtual modifier to be added to the virtual modifier map
for the key.
<em class="structfield"><code>virtual_mod</code></em>
is specified as an index in the range [0..15].
</p><p>
If the matching symbol is in position G1L1 of the key, two bits in the flags
field potentially specify additional behavior modifications:

</p><pre class="programlisting">
#define   XkbSI_AutoRepeat    (1&lt;&lt;0)     /* key repeats if sym
                                            is in position G1L1 */
#define   XkbSI_LockingKey    (1&lt;&lt;1)     /* set <span class="emphasis"><em>KB_Lock</em></span> behavior
                                            if sym is in psn G1L1 */
</pre><p>
If the Xkb keyboard map for the key does not have its
<span class="emphasis"><em>ExplicitAutoRepeat</em></span>
control set, its auto repeat behavior is set based on the value of the
<span class="symbol">XkbSI_AutoRepeat</span>
bit. If the
<span class="symbol">XkbSI_AutoRepeat</span>
bit is set, the auto-repeat behavior of the key is turned on; otherwise, it is
turned off.
</p><p>
If the Xkb keyboard map for the key does not have its
<span class="emphasis"><em>ExplicitBehavior</em></span>
control set, its locking behavior is set based on the value of the
<span class="symbol">XkbSI_LockingKey</span>
bit. If
<span class="symbol">XkbSI_LockingKey</span>
is set, the key behavior is set to
<span class="emphasis"><em>KB_Lock</em></span>;
otherwise, it is turned off (see <a class="link" href="#Explicit_ComponentsAvoiding_Automatic_Remapping_by_the_Server" title="Explicit Components—Avoiding Automatic Remapping by the Server">section 16.3</a>).
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="Xkb_Keyboard_Mapping_to_Core_Keyboard_Mapping_Transformations"></a>Xkb Keyboard Mapping to Core Keyboard Mapping Transformations</h3></div></div></div><p>
Whenever the server processes Xkb requests to change the keyboard mapping, it
discards the affected portion of its core keyboard mapping and regenerates it
based on the new Xkb mapping.
</p><p>
When the Xkb mapping for a key is transformed to a core protocol mapping, the
symbols for the core map are taken in the following order from the Xkb map:
</p><p>
G1L1 G1L2 G2L1 G2L2 G1L3-n G2L3-n G3L1-n G4L1-n
</p><p>
If group one is of width one in the Xkb map, G1L2 is taken to be NoSymbol;
similarly, if group two is of width one in the Xkb map, G2L2 is taken to be
NoSymbol.
</p><p>
If the Xkb key map for a particular key has fewer groups than the core
keyboard, the symbols for group one are repeated to fill in the missing core
components. For example, an Xkb key with a single width-three group would be
mapped to a core mapping counting three groups as:
</p><p>
G1L1 G1L2 G1L1 G1L2 G1L3 G1L3 G1L1 G1L2 G1L3
</p><p>
When a core keyboard map entry is generated from an Xkb keyboard map entry, a
modifier mapping is generated as well. The modifier mapping contains all of the
modifiers affected by any of the actions associated with the key combined with
all of the real modifiers associated with any of the virtual modifiers bound to
the key. In addition, if any of the actions associated with the key affect any
component of the keyboard group, all of the modifiers in the
<em class="structfield"><code>mask</code></em>
field of all of the group compatibility maps are added to the modifier mapping
as well. While an
<span class="symbol">XkbSA_ISOLock</span>
action can theoretically affect any modifier, if the Xkb mapping for a key
specifies an
<span class="symbol">XkbSA_ISOLock</span>
action, only the modifiers or group that are set by default are added to the
modifier mapping.
</p></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Getting_Compatibility_Map_Components_From_the_Server"></a>Getting Compatibility Map Components From the Server</h2></div></div></div><p>
Use
<code class="function">XkbGetCompatMap</code>
to fetch any combination of the current compatibility map components from the
server. When another client modifies the compatibility map, you are notified if
you have selected for
<span class="symbol">XkbCompatMapNotify</span>
events (see <a class="link" href="#Tracking_Changes_to_the_Compatibility_Map" title="Tracking Changes to the Compatibility Map">section 17.5</a>).
<code class="function">XkbGetCompatMap</code>
is particularly useful when you receive an event of this type, as it allows
you to update your program’s version of the compatibility map to match the
modified version now in the server. If your program is dealing with multiple
servers and needs to configure them all in a similar manner, the updated
compatibility map may be used to reconfigure other servers.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>To make a complete matching configuration you must also update the
explicit override components of the server state.</p></div><a id="idm14946" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetCompatMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetCompatMap</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">which</var>, XkbDescRec *<var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of compatibility map components to fetch
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description where results placed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetCompatMap</code>
fetches the components of the compatibility map specified in
<em class="parameter"><code>which</code></em>
from the server specified by
<em class="parameter"><code>display</code></em>
and places them in the
<em class="structfield"><code>compat</code></em>
structure of the keyboard description
<em class="parameter"><code>xkb</code></em>.
Valid values for
<em class="parameter"><code>which</code></em>
are an inclusive OR of the values shown in
<a class="link" href="#table17.2" title="Table 17.2. Compatibility Map Component Masks">Table 17.2</a>.
</p><div class="table"><a id="table17.2"></a><p class="title"><strong>Table 17.2. Compatibility Map Component Masks</strong></p><div class="table-contents"><table class="table" summary="Compatibility Map Component Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Value</th><th align="left">Affecting</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbSymInterpMask</span></td><td align="left">(1&lt;&lt;0)</td><td align="left">Symbol interpretations</td></tr><tr><td align="left"><span class="symbol">XkbGroupCompatMask</span></td><td align="left">(1&lt;&lt;1)</td><td align="left">Group maps</td></tr><tr><td align="left"><span class="symbol">XkbAllCompatMask</span></td><td align="left">(0x3)</td><td align="left">All compatibility map components</td></tr></tbody></table></div></div><br class="table-break" /><p>
If no compatibility map structure is allocated in
<em class="parameter"><code>xkb</code></em>
upon entry,
<code class="function">XkbGetCompatMap</code>
allocates one. If one already exists, its contents are overwritten with the
returned results.
</p><p>
<code class="function">XkbGetCompatMap</code>
fetches compatibility map information for the device specified by the
<em class="structfield"><code>device_spec</code></em>
field of
<em class="parameter"><code>xkb</code></em>.
Unless you have specifically modified this field, it is the default keyboard
device.
<code class="function">XkbGetCompatMap</code>
returns
<span class="symbol">Success</span>
if successful,
<span class="errorname">BadAlloc</span>
if it is unable to obtain necessary storage for either the return values or
work space,
<span class="errorname">BadMatch</span>
if the
<em class="structfield"><code>dpy</code></em>
field of the
<em class="parameter"><code>xkb</code></em>
argument is non-
<span class="symbol">NULL</span>
and does not match the
<em class="parameter"><code>display</code></em>
argument, and
<span class="errorname">BadLength</span>
under certain conditions caused by server or Xkb implementation errors.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Using_the_Compatibility_Map"></a>Using the Compatibility Map</h2></div></div></div><p>
Xkb provides several functions that make it easier to apply the compatibility
map to configure a client-side Xkb keyboard mapping, given a core protocol
representation of part or all of a keyboard mapping. Obtain a core protocol
representation of a keyboard mapping from an actual server (by using
<code class="function">XGetKeyboardMapping</code>,
for example), a data file, or some other source.
</p><p>
To update a local Xkb keyboard map to reflect the mapping expressed by a core
format mapping by calling the function
<code class="function">XkbUpdateMapFromCore</code>.
</p><a id="idm15032" class="indexterm"></a><div class="funcsynopsis"><a id="XkbUpdateMapFromCore"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbUpdateMapFromCore</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">first_key</var>, int <var class="pdparam">num_keys</var>, int <var class="pdparam">map_width</var>, KeySym *<var class="pdparam">core_keysyms</var>, XkbChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to update
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first_key</code></em>
    </span></p></td><td><p>
        keycode of first key description to update
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_keys</code></em>
    </span></p></td><td><p>
        number of key descriptions to update
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>map_width</code></em>
    </span></p></td><td><p>
        width of core protocol keymap
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>core_keysyms</code></em>
    </span></p></td><td><p>
        symbols in core protocol keymap
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        backfilled with changes made to Xkb
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbUpdateMapFromCore</code>
interprets input argument information representing a keyboard map in core
format to update the Xkb keyboard description passed in
<em class="parameter"><code>xkb</code></em>.
Only a portion of the Xkb map is updated — the portion corresponding to
keys with keycodes in the range
<em class="parameter"><code>first_key</code></em>
through
<em class="parameter"><code>first_key</code></em>
+
<em class="parameter"><code>num_keys</code></em>
- 1. If
<code class="function">XkbUpdateMapFromCore</code>
is being called in response to a
<span class="symbol">MappingNotify</span>
event,
<em class="parameter"><code>first_key</code></em>
and
<em class="parameter"><code>num_keys</code></em>
are reported in the
<span class="symbol">MappingNotify</span>
event.
<em class="parameter"><code>core_keysyms</code></em>
contains the keysyms corresponding to the keycode range being updated, in core
keyboard description order.
<em class="parameter"><code>map_width</code></em>
is the number of keysyms per key in
<em class="parameter"><code>core_keysyms</code></em>.
Thus, the first
<em class="parameter"><code>map_width</code></em>
entries in
<em class="parameter"><code>core_keysyms</code></em>
are for the key with keycode
<em class="parameter"><code>first_key</code></em>,
the next
<em class="parameter"><code>map_width</code></em>
entries are for key
<em class="parameter"><code>first_key</code></em>
+ 1, and so on.
</p><p>
In addition to modifying the Xkb keyboard mapping in
<em class="parameter"><code>xkb</code></em>,
<code class="function">XkbUpdateMapFromCore</code>
backfills the changes structure whose address is passed in
<em class="parameter"><code>changes</code></em>
to indicate the modifications that were made. You may then use
<em class="parameter"><code>changes</code></em>
in subsequent calls such as
<code class="function">XkbSetMap</code>,
to propagate the local modifications to a server.
</p><p>
When dealing with core keyboard mappings or descriptions, it is sometimes
necessary to determine the Xkb key types appropriate for the symbols bound to a
key in a core keyboard mapping. Use
<code class="function">XkbKeyTypesForCoreSymbols</code>
for this purpose:
</p><a id="idm15109" class="indexterm"></a><div class="funcsynopsis"><a id="XkbKeyTypesForCoreSymbols"></a><p><code class="funcdef">int <strong class="fsfunc">XkbKeyTypesForCoreSymbols</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, int <var class="pdparam">map_width</var>, KeySym *<var class="pdparam">core_syms</var>, unsigned int <var class="pdparam">protected</var>, int *<var class="pdparam">types_inout</var>, KeySym *<var class="pdparam">xkb_syms_rtrn</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description in which to place symbols
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>map_width</code></em>
    </span></p></td><td><p>
        width of core protocol keymap in <em class="parameter"><code>xkb_syms_rtrn</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>core_syms</code></em>
    </span></p></td><td><p>
        core protocol format array of KeySyms
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>protected</code></em>
    </span></p></td><td><p>
        explicit key types
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>types_inout</code></em>
    </span></p></td><td><p>
        backfilled with the canonical types bound to groups one and two
        for the key
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb_syms_rtrn</code></em>
    </span></p></td><td><p>
        backfilled with symbols bound to the key in the Xkb mapping
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbKeyTypesForCoreSymbols</code>
expands the symbols in
<em class="parameter"><code>core_syms</code></em>
and types in
<em class="parameter"><code>types_inout</code></em>
according to the rules specified in section 12 of the core protocol, then
chooses canonical key types (canonical key types are defined in <a class="link" href="#The_Canonical_Key_Types" title="The Canonical Key Types">section 15.2.1</a>)
for groups 1 and 2 using the rules specified by the Xkb protocol and places
them in
<em class="parameter"><code>xkb_syms_rtrn</code></em>,
which will be non-
<span class="symbol">NULL</span>.
</p><p>
A core keymap is a two-dimensional array of keysyms. It has
<em class="parameter"><code>map_width</code></em>
columns and
<em class="structfield"><code>max_key_code</code></em>
rows.
<code class="function">XkbKeyTypesForCoreSymbols</code>
takes a single row from a core keymap, determines the number of groups
associated with it, the type of each group, and the symbols bound to each
group. The return value is the number of groups,
<em class="parameter"><code>types_inout</code></em>
has the types for each group, and
<em class="parameter"><code>xkb_syms_rtrn</code></em>
has the symbols in Xkb order (that is, groups are contiguous, regardless of
size).
</p><p>
<em class="parameter"><code>protected</code></em>
contains the explicitly protected key types. There is one  explicit override
control associated with each of the four possible groups for each Xkb key,
<span class="emphasis"><em>ExplicitKeyType1</em></span>
through
<span class="emphasis"><em>ExplicitKeyType4</em></span>;
<em class="parameter"><code>protected</code></em>
is an inclusive OR of these controls.
<em class="parameter"><code>map_width</code></em>
is the width of the core keymap and is not dependent on any Xkb definitions.
<em class="parameter"><code>types_inout</code></em>
is an array of four type indices. On input,
<em class="parameter"><code>types_inout</code></em>
contains the indices of any types already assigned to the key, in case they
are explicitly protected from change.
</p><p>
Upon return,
<em class="parameter"><code>types_inout</code></em>
contains any automatically selected (that is, canonical) types plus any
protected types. Canonical types are assigned to all four groups if there are
enough symbols to do so. The four entries in
<em class="parameter"><code>types_inout</code></em>
correspond to the four groups for the key in question.
</p><p>
If the groups mapping does not change, but the symbols assigned to an Xkb
keyboard compatibility map do change, the semantics of the key may be modified.
To apply the new compatibility mapping to an individual key to get its
semantics updated, use
<code class="function">XkbApplyCompatMapToKey</code>.
</p><a id="idm15186" class="indexterm"></a><div class="funcsynopsis"><a id="XkbApplyCompatMapToKey"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbApplyCompatMapToKey</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, KeyCode <var class="pdparam">key</var>, XkbChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>key</code></em>
    </span></p></td><td><p>
        key to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        notes changes to the Xkb keyboard description
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbApplyCompatMapToKey</code>
essentially performs the operation described in <a class="link" href="#Core_Keyboard_Mapping_to_Xkb_Keyboard_Mapping_Transformation" title="Core Keyboard Mapping to Xkb Keyboard Mapping Transformation">section 17.1.2</a> to a specific
key. This updates the behavior, actions, repeat status, and virtual modifier
bindings of the key.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Changing_the_Servers_Compatibility_Map"></a>Changing the Server’s Compatibility Map</h2></div></div></div><p>
To modify the server’s compatibility map, first modify a local copy of the
Xkb compatibility map, then call
<code class="function">XkbSetCompatMap</code>.
You may allocate a new compatibility map for this purpose using
<code class="function">XkbAllocCompatMap</code>
(see <a class="link" href="#Allocating_and_Freeing_the_Compatibility_Map" title="Allocating and Freeing the Compatibility Map">section 17.6</a>). You may also use a compatibility map from another server,
although you need to adjust the
<em class="structfield"><code>device_spec</code></em>
field in the
<span class="structname">XkbDescRec</span>
accordingly. Note that symbol interpretations in a compatibility map
(
<em class="structfield"><code>sym_interpret</code></em>,
the vector of
<span class="structname">XkbSymInterpretRec</span>
structures) are also allocated using this same function.
</p><a id="idm15228" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetCompatMap"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetCompatMap</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var>, Bool <var class="pdparam">update_actions</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of compat map components to set
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        source for compat map components
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>update_actions</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ apply to server’s keyboard map
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetCompatMap</code>
copies compatibility map information from the keyboard description in
<em class="parameter"><code>xkb</code></em>
to the server specified in
<em class="parameter"><code>display</code></em>’s
compatibility map for the device specified by the
<em class="structfield"><code>device_spec</code></em>
field of
<em class="parameter"><code>xkb</code></em>.
Unless you have specifically modified this field, it is the default keyboard
device.
<em class="parameter"><code>which</code></em>
specifies the compatibility map components to be set, and is an inclusive OR
of the bits shown in <a class="link" href="#table17.2" title="Table 17.2. Compatibility Map Component Masks">Table 17.2</a>.
</p><p>
After updating its compatibility map for the specified device, if
<em class="parameter"><code>update_actions</code></em>
is
<span class="symbol">True</span>,
the server applies the new compatibility map to its entire keyboard for the
device to generate a new set of key semantics, compatibility state, and a new
core keyboard map. If
<em class="parameter"><code>update_actions</code></em>
is
<span class="symbol">False</span>,
the new compatibility map is not used to generate any modifications to the
current device semantics, state, or core keyboard map. One reason for not
applying the compatibility map immediately would be if one server was being
configured to match another on a piecemeal basis; the map should not be applied
until everything is updated. To force an update at a later time, use
<code class="function">XkbSetCompatMap</code>
specifying
<em class="parameter"><code>which</code></em>
as zero and
<em class="parameter"><code>update_actions</code></em>
as
<span class="symbol">True</span>.
</p><p>
<code class="function">XkbSetCompatMap</code>
returns
<span class="symbol">True</span>
if successful and
<span class="symbol">False</span>
if unsuccessful. The server may report problems it encounters when processing
the request subsequently via protocol errors.
</p><p>
To add a symbol interpretation to the list of symbol interpretations in an
<span class="structname">XkbCompatRec</span>,
use
<code class="function">XkbAddSymInterpret</code>.
</p><a id="idm15289" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddSymInterpret"></a><p><code class="funcdef">XkbSymInterpretPtr <strong class="fsfunc">XkbAddSymInterpret</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, XkbSymInterpretPtr <var class="pdparam">si</var>, Bool <var class="pdparam">updateMap</var>, XkbChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>si</code></em>
    </span></p></td><td><p>
        symbol interpretation to be added
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>updateMap</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span>⇒apply compatibility map to keys
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        changes are put here
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddSymInterpret</code>
adds
<em class="parameter"><code>si</code></em>
to the list of symbol interpretations in
<em class="parameter"><code>xkb</code></em>.
If
<em class="parameter"><code>updateMap</code></em>
is
<span class="symbol">True</span>,
it (re)applies the compatibility map to all of the keys on the keyboard. If
<em class="parameter"><code>changes</code></em>
is non-
<span class="symbol">NULL</span>,
it reports the parts of the keyboard that were affected (unless
<em class="parameter"><code>updateMap</code></em>
is
<span class="symbol">True</span>,
not much changes).
<code class="function">XkbAddSymInterpret</code>
returns a pointer to the actual new symbol interpretation in the list or
<span class="symbol">NULL</span>
if it failed.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Changes_to_the_Compatibility_Map"></a>Tracking Changes to the Compatibility Map</h2></div></div></div><a id="idm15340" class="indexterm"></a><a id="idm15344" class="indexterm"></a><p>
The server automatically generates
<span class="symbol">MappingNotify</span>
events when the keyboard mapping changes. If you wish to be notified of
changes to the compatibility map, you should select for
<span class="symbol">XkbCompatMapNotify</span>
events. If you select for
<span class="symbol">XkbMapNotify</span>
events, you no longer receive the automatically generated
<span class="symbol">MappingNotify</span>
events. If you subsequently deselect
<span class="structname">XkbMapNotifyEvent</span>
delivery, you again receive
<span class="symbol">MappingNotify</span>
events.
</p><p>
To receive
<span class="symbol">XkbCompatMapNotify</span>
events under all possible conditions, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) and pass
<span class="symbol">XkbCompatMapNotifyMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
To receive
<span class="symbol">XkbCompatMapNotify</span>
events only under certain conditions, use
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbCompatMapNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying the desired map changes in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
using mask bits from <a class="link" href="#table17.2" title="Table 17.2. Compatibility Map Component Masks">Table 17.2</a>.
</p><p>
Note that you are notified of changes you make yourself, as well as changes
made by other clients.
</p><p>
The structure for the
<span class="structname">XkbCompatMapNotifyEvent</span>
is:

</p><pre class="programlisting">
typedef struct {
    int            type;           /* Xkb extension base event code */
    unsigned long  serial;         /* X server serial number for event */
    Bool           send_event;     /* <span class="symbol">True</span> ⇒
                                      synthetically generated */
    Display *      display;        /* server connection where event generated */
    Time           time;           /* server time when event generated */
    int            xkb_type;       /* <span class="symbol">XkbCompatMapNotify</span> */
    int            device;         /* Xkb device ID, will not be
                                      <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int   changed_groups; /* number of group maps changed */
    int            first_si;       /* index to 1st changed symbol
                                      interpretation */
    int            num_si;         /* number of changed symbol
                                      interpretations */
    int            num_total_si;   /* total number of valid symbol
                                      interpretations */
} <span class="structname">XkbCompatMapNotifyEvent</span>;
</pre><p>
<em class="structfield"><code>changed_groups</code></em>
is the number of group compatibility maps that have changed. If you are
maintaining a corresponding copy of the compatibility map, or get a fresh copy
from the server using
<code class="function">XkbGetCompatMap</code>,
<em class="structfield"><code>changed_groups</code></em>
references
<em class="structfield"><code>groups</code></em>
[0..
<em class="structfield"><code>changed_groups</code></em>
-1] in the
<span class="structname">XkbCompatMapRec</span>
structure.
</p><p>
<em class="structfield"><code>first_si</code></em>
is the index of the first changed symbol interpretation,
<em class="structfield"><code>num_si</code></em>
is the number of changed symbol interpretations, and
<em class="structfield"><code>num_total_si</code></em>
is the total number of valid symbol interpretations. If you are maintaining a
corresponding copy of the compatibility map, or get a fresh copy from the
server using
<code class="function">XkbGetCompatMap</code>,
<em class="structfield"><code>first_si</code></em>,
<em class="structfield"><code>num_si</code></em>,
and
<em class="structfield"><code>num_total_si</code></em>
are appropriate for use with the
<em class="structfield"><code>compat.sym_interpret</code></em>
vector in this structure.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_the_Compatibility_Map"></a>Allocating and Freeing the Compatibility Map</h2></div></div></div><p>
If you are modifying the compatibility map, you need to allocate a new
compatibility map if you do not already have one available. To do so, use
<code class="function">XkbAllocCompatMap</code>.
</p><a id="idm15397" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocCompatMap"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocCompatMap</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">num_si</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description in which to allocate compat map
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of compatibility map components to allocate
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_si</code></em>
    </span></p></td><td><p>
        number of symbol interpretations to allocate
      </p></td></tr></tbody></table></div><p>
<em class="parameter"><code>xkb</code></em>
specifies the keyboard description for which compatibility maps are to be
allocated. The compatibility map is the
<em class="structfield"><code>compat</code></em>
field in this structure.
</p><p>
<em class="parameter"><code>which</code></em>
specifies the compatibility map components to be allocated (see
<a class="link" href="#XkbGetCompatMap"><code class="function">XkbGetCompatMap</code></a>,
in <a class="link" href="#Getting_Compatibility_Map_Components_From_the_Server" title="Getting Compatibility Map Components From the Server">section 17.2</a>).
<em class="parameter"><code>which</code></em>
is an inclusive OR of the bits shown in
<a class="link" href="#table17.2" title="Table 17.2. Compatibility Map Component Masks">Table 17.2</a>.
</p><p>
<em class="parameter"><code>num_si</code></em>
specifies the total number of entries to allocate in the symbol interpretation
vector
(<em class="structfield"><code>xkb.compat.sym_interpret</code></em>).

</p><p>
Note that symbol interpretations in a compatibility map (the
<em class="structfield"><code>sym_interpret</code></em>
vector of
<span class="structname">XkbSymInterpretRec</span>
structures) are also allocated using this same function. To ensure that there
is sufficient space in the symbol interpretation vector for entries to be
added, use
<code class="function">XkbAllocCompatMap</code>
specifying
<em class="parameter"><code>which</code></em>
as
<span class="emphasis"><em>XkbSymInterpretMask</em></span>
and the number of free symbol interpretations needed in
<em class="parameter"><code>num_si</code></em>.
</p><p>
<code class="function">XkbAllocCompatMap</code>
returns
<span class="symbol">Success</span>
if successful,
<span class="errorname">BadMatch</span>
if
<em class="parameter"><code>xkb</code></em>
is
<span class="symbol">NULL</span>,
or
<span class="errorname">BadAlloc</span>
if errors are encountered when attempting to allocate storage.
</p><p>
To free an entire compatibility map or selected portions of one, use
<code class="function">XkbFreeCompatMap</code>.
</p><a id="idm15455" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeCompatMap"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeCompatMap</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_map</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        Xkb description in which to free compatibility map
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of compatibility map components to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_map</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ free <span class="structname">XkbCompatMapRec</span>
         structure itself
      </p></td></tr></tbody></table></div><p>
<em class="parameter"><code>which</code></em>
specifies the compatibility map components to be freed (see
<a class="link" href="#XkbGetCompatMap"><code class="function">XkbGetCompatMap</code></a>,
in <a class="link" href="#Getting_Compatibility_Map_Components_From_the_Server" title="Getting Compatibility Map Components From the Server">section 17.2</a>).
<em class="parameter"><code>which</code></em>
is an inclusive OR of the bits shown in
<a class="link" href="#table17.2" title="Table 17.2. Compatibility Map Component Masks">Table 17.2</a>
</p><p>
<em class="parameter"><code>free_map</code></em>
indicates whether the
<span class="structname">XkbCompatMapRec</span>
structure itself should be freed. If
<em class="parameter"><code>free_map</code></em>
is
<span class="symbol">True</span>,
<em class="parameter"><code>which</code></em>
is ignored, all non-
<span class="symbol">NULL</span>
compatibility map components are freed, and the
<em class="structfield"><code>compat</code></em>
field in the
<span class="structname">XkbDescRec</span>
referenced by
<em class="parameter"><code>xkb</code></em>
is set to
<span class="symbol">NULL</span>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Symbolic_Names"></a>Chapter 18. Symbolic Names</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#The_XkbNamesRec_Structure">The XkbNamesRec Structure</a></span></dt><dt><span class="sect1"><a href="#Symbolic_Names_Masks">Symbolic Names Masks</a></span></dt><dt><span class="sect1"><a href="#Getting_Symbolic_Names_From_the_Server">Getting Symbolic Names From the Server</a></span></dt><dt><span class="sect1"><a href="#Changing_Symbolic_Names_on_the_Server">Changing Symbolic Names on the Server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#idm15837"></a></span></dt></dl></dd><dt><span class="sect1"><a href="#Tracking_Name_Changes">Tracking Name Changes</a></span></dt><dt><span class="sect1"><a href="#Allocating_and_Freeing_Symbolic_Names">Allocating and Freeing Symbolic Names</a></span></dt></dl></div><p>
The core protocol does not provide any information to clients other than that
actually used to interpret events. This makes it difficult to write an
application that presents the keyboard to a user in an easy-to-understand way.
Such applications have to examine the vendor string and keycodes to determine
the type of keyboard connected to the server and then examine keysyms and
modifier mappings to determine the effects of most modifiers (the
<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>
and
<span class="symbol">Control</span>
modifiers are defined by the core protocol but no semantics are implied for
any other modifiers).
</p><p>
To make it easier for applications to present a keyboard to the user, Xkb
supports symbolic names for most components of the keyboard extension. Most of
these symbolic names are grouped into the
<em class="structfield"><code>names</code></em>
component of the keyboard description.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="The_XkbNamesRec_Structure"></a>The XkbNamesRec Structure</h2></div></div></div><a id="idm15514" class="indexterm"></a><a id="idm15517" class="indexterm"></a><a id="idm15520" class="indexterm"></a><p>
The names component of the keyboard description is defined as follows:

</p><pre class="programlisting">
#define      XkbKeyNameLength      4
#define      XkbKeyNumVirtualMods  16
#define      XkbKeyNumIndicators   32
#define      XkbKeyNumKbdGroups    4
#define      XkbMaxRadioGroups     32

typedef struct {
    char      name[XkbKeyNameLength];      /* symbolic key names */
} <span class="structname">XkbKeyNameRec</span>, *XkbKeyNamePtr;

typedef struct {
    char      real[XkbKeyNameLength];
              /* this key name must be in the keys array */
    char      alias[XkbKeyNameLength];
              /* symbolic key name as alias for the key */
} <span class="structname">XkbKeyAliasRec</span>, *XkbKeyAliasPtr;

typedef struct _XkbNamesRec {
    Atom            keycodes;        /* identifies range and meaning
                                        of keycodes */
    Atom            geometry;        /* identifies physical location,
                                        size, and shape of keys */
    Atom            symbols;         /* identifies the symbols logically
                                        bound to the keys */
    Atom            types;           /* identifies the set of key types */
    Atom            compat;          /* identifies actions for keys using
                                        core protocol */
    Atom            vmods[XkbNumVirtualMods]; /* symbolic names for
                                                 virtual modifiers */
    Atom            indicators[XkbNumIndicators]; /* symbolic names
                                                     for indicators */
    Atom            groups[XkbNumKbdGroups];  /* symbolic names for
                                                 keyboard groups */
    XkbKeyNamePtr   keys;            /* symbolic key name array */
    XkbKeyAliasPtr  key_aliases;     /* real/alias symbolic name pairs array */
    Atom *          radio_groups;    /* radio group name array */
    Atom            phys_symbols;    /* identifies the symbols engraved
                                        on the keyboard */
    unsigned char   num_keys;        /* number of keys in the <em class="structfield"><code>keys</code></em> array */
    unsigned char   num_key_aliases; /* number of keys in the
                                        <em class="structfield"><code>key_aliases</code></em> array */
    unsigned short  num_rg;          /* number of radio groups */
} <span class="structname">XkbNamesRec</span>, *XkbNamesPtr;
</pre><p>
The
<em class="structfield"><code>keycodes</code></em>
name identifies the range and meaning of the keycodes returned by the keyboard
in question. The
<em class="structfield"><code>geometry</code></em>
name, on the other hand, identifies the physical location, size and shape of
the various keys on the keyboard. As an example to distinguish between these
two names, consider function keys on PC-compatible keyboards. Function keys are
sometimes above the main keyboard and sometimes to the left of the main
keyboard, but the same keycode is used for the key that is logically F1
regardless of physical position. Thus, all PC-compatible keyboards share a
similar keycodes name but may have different geometry names.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The keycodes name is intended to be a very general description of
the keycodes returned by a keyboard; a single keycodes name might cover
keyboards with differing numbers of keys provided all keys have the same
semantics when present. For example, 101 and 102 key PC keyboards might use the
same name. In these cases, applications can use the keyboard
<em class="structfield"><code>geometry</code></em>
name to determine which subset of the named keycodes is in use.</p></div><p>
The
<em class="structfield"><code>symbols</code></em>
name identifies the symbols logically bound to the keys. The symbols name is a
human or application-readable description of the intended locale or usage of
the keyboard with these symbols. The
<em class="structfield"><code>phys_symbols</code></em>
name, on the other hand, identifies the symbols actually engraved on the
keyboard. Given this, the
<em class="structfield"><code>symbols</code></em>
name and
<em class="structfield"><code>phys_symbols</code></em>
names might be different. For example, the description for a keyboard that has
English US engravings, but that is using Swiss German symbols might have a
<em class="structfield"><code>phys_symbols</code></em>
name of "en_US" and a
<em class="structfield"><code>symbols</code></em>
name of "de_CH."
</p><p>
The
<em class="structfield"><code>types</code></em>
name provides some information about the set of key types (see <a class="link" href="#Key_Types" title="Key Types">section 15.2</a>)
that can be associated with the keyboard. In addition, each key type can have a
name, and each shift level of a type can have a name. Although these names are
stored in the map description with each of the types, they are accessed using
the same methods as the other symbolic names.
</p><p>
The
<em class="structfield"><code>compat</code></em>
name provides some information about the rules used to bind actions to keys
that are changed using core protocol requests.
</p><p>
Xkb provides symbolic names for each of the 4 keyboard groups, 16 virtual
modifiers, 32 keyboard indicators, and 4 keyboard groups. These names are held
in the
<em class="structfield"><code>vmods</code></em>,
<em class="structfield"><code>indicators</code></em>,
and
<em class="structfield"><code>groups</code></em>
fixed-length arrays.
</p><p>
Each key has a four-byte symbolic name. All of the symbolic key names are held
in the
<em class="structfield"><code>keys</code></em>
array, and
<em class="structfield"><code>num_keys</code></em>
reports the number of entries that are in the keys array. For each key, the
key name links keys with similar functions or in similar positions on keyboards
that report different keycodes. For example, the
<span class="keycap"><strong>F1</strong></span>
key may emit keycode 23 on one keyboard and keycode 86 on another. By naming
this key "FK01" on both keyboards, the keyboard layout designer can reuse parts
of keyboard descriptions for different keyboards.
</p><p>
Key aliases allow the keyboard layout designer to assign multiple key names to
a single key. This allows the keyboard layout designer to refer to keys using
either their position or their <span class="quote">“<span class="quote">function</span>”</span>.
For example, a keyboard layout
designer may wish to refer to the left arrow key on a PC keyboard using the
ISO9995-5 positional specification of A31 or using the functional specification
of LEFT. The
<em class="structfield"><code>key_aliases</code></em>
field holds a variable-length array of real and alias key name pairs, and the
total number of entries in the
<em class="structfield"><code>key_aliases</code></em>
array is held in
<em class="structfield"><code>num_key_aliases</code></em>.
For each real and alias key name pair, the
<em class="structfield"><code>real</code></em>
field refers to the a name in the keys array, and the
<em class="structfield"><code>alias</code></em>
field refers to the alias for that key. Using the previous example, the
keyboard designer may use the name A31 in the keys array, but also define the
name LEFT as an alias for A31 in the
<em class="structfield"><code>key_aliases</code></em>
array.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Key aliases defined in the geometry component of a keyboard mapping
(see <a class="xref" href="#Keyboard_Geometry" title="Chapter 13. Keyboard Geometry">Chapter 13, <em>Keyboard Geometry</em></a>) override those defined in the keycodes component of the server
database, which are stored in the
<span class="structname">XkbNamesRec</span>

(<em class="structfield"><code>xkb-&gt;names</code></em>).
Therefore, consider the key aliases defined by the geometry before
considering key aliases supplied by the
<span class="structname">XkbNamesRec</span>.
</p></div><p>
A radio group is a set of keys whose behavior simulates a set of radio buttons.
Once a key in a radio group is pressed, it stays logically depressed until
another key in the group is pressed, at which point the previously depressed
key is logically released. Consequently, at most one key in a radio group can
be logically depressed at one time.
</p><p>
Each radio group in the keyboard description can have a name. These names are
held in the variable-length array
<em class="structfield"><code>radio_groups</code></em>,
and
<em class="structfield"><code>num_rg</code></em>
tells how many elements are in the
<em class="structfield"><code>radio_groups</code></em>
array.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Symbolic_Names_Masks"></a>Symbolic Names Masks</h2></div></div></div><p>
Xkb provides several functions that work with symbolic names. Each of these
functions uses a mask to specify individual fields of the structures described
above. These masks and their relationships to the fields in a keyboard
description are shown in <a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>.
</p><div class="table"><a id="table18.1"></a><p class="title"><strong>Table 18.1. Symbolic Names Masks</strong></p><div class="table-contents"><table class="table" summary="Symbolic Names Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Mask Bit</th><th align="left">Value</th><th align="left">Keyboard Component</th><th align="left">Field</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbKeycodesNameMask</span></td><td align="left">(1&lt;&lt;0)</td><td align="left">Xkb-&gt;names</td><td align="left">keycodes</td></tr><tr><td align="left"><span class="symbol">XkbGeometryNameMask</span></td><td align="left">(1&lt;&lt;1)</td><td align="left">Xkb-&gt;names</td><td align="left">geometry</td></tr><tr><td align="left"><span class="symbol">XkbSymbolsNameMask</span></td><td align="left">(1&lt;&lt;2)</td><td align="left">Xkb-&gt;names</td><td align="left">symbols</td></tr><tr><td align="left"><span class="symbol">XkbPhysSymbolsNameMask</span></td><td align="left">(1&lt;&lt;3)</td><td align="left">Xkb-&gt;names</td><td align="left">phys_symbols</td></tr><tr><td align="left"><span class="symbol">XkbTypesNameMask</span></td><td align="left">(1&lt;&lt;4)</td><td align="left">Xkb-&gt;names</td><td align="left">type</td></tr><tr><td align="left"><span class="symbol">XkbCompatNameMask</span></td><td align="left">(1&lt;&lt;5)</td><td align="left">Xkb-&gt;names</td><td align="left">compat</td></tr><tr><td align="left"><span class="symbol">XkbKeyTypeNamesMask</span></td><td align="left">(1&lt;&lt;6)</td><td align="left">Xkb-&gt;map</td><td align="left">type[*].name</td></tr><tr><td align="left"><span class="symbol">XkbKTLevelNamesMask</span></td><td align="left">(1&lt;&lt;7)</td><td align="left">Xkb-&gt;map</td><td align="left">type[*].lvl_names[*]</td></tr><tr><td align="left"><span class="symbol">XkbIndicatorNamesMask</span></td><td align="left">(1&lt;&lt;8)</td><td align="left">Xkb-&gt;names</td><td align="left">indicators[*]</td></tr><tr><td align="left"><span class="symbol">XkbKeyNamesMask</span></td><td align="left">(1&lt;&lt;9)</td><td align="left">Xkb-&gt;names</td><td align="left">keys[*], num_keys</td></tr><tr><td align="left"><span class="symbol">XkbKeyAliasesMask</span></td><td align="left">(1&lt;&lt;10)</td><td align="left">Xkb-&gt;names</td><td align="left">key_aliases[*], num_key_aliases</td></tr><tr><td align="left"><span class="symbol">XkbVirtualModNamesMask</span></td><td align="left">(1&lt;&lt;11)</td><td align="left">Xkb-&gt;names</td><td align="left">vmods[*]</td></tr><tr><td align="left"><span class="symbol">XkbGroupNamesMask</span></td><td align="left">(1&lt;&lt;12)</td><td align="left">Xkb-&gt;names</td><td align="left">groups[*]</td></tr><tr><td align="left"><span class="symbol">XkbRGNamesMask</span></td><td align="left">(1&lt;&lt;13)</td><td align="left">Xkb-&gt;names</td><td align="left">radio_groups[*], num_rg</td></tr><tr><td align="left"><span class="symbol">XkbComponentNamesMask</span></td><td align="left">(0x3f)</td><td align="left">Xkb-&gt;names</td><td align="left">
<p>keycodes,</p>
<p>geometry,</p>
<p>symbols,</p>
<p>physical symbols,</p>
<p>types, and</p>
<p>compatibility map</p>
    </td></tr><tr><td align="left"><span class="symbol">XkbAllNamesMask</span></td><td align="left">(0x3fff)</td><td align="left">Xkb-&gt;names</td><td align="left">all name components</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Getting_Symbolic_Names_From_the_Server"></a>Getting Symbolic Names From the Server</h2></div></div></div><p>
To obtain symbolic names from the server, use
<code class="function">XkbGetNames</code>.
</p><a id="idm15699" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetNames"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetNames</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of names or map components to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to be updated
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetNames</code>
retrieves symbolic names for the components of the keyboard extension from the
X server. The
<em class="parameter"><code>which</code></em>
parameter specifies the name components to be updated in the
<em class="parameter"><code>xkb</code></em>
parameter, and is the bitwise inclusive OR of the valid names mask bits
defined in <a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>.
</p><p>
If the
<em class="structfield"><code>names</code></em>
field of the keyboard description
<em class="parameter"><code>xkb</code></em>
is
<span class="symbol">NULL</span>,
<code class="function">XkbGetNames</code>
allocates and initializes the
<em class="structfield"><code>names</code></em>
component of the keyboard description before obtaining the values specified by
<em class="parameter"><code>which</code></em>.
If the
<em class="structfield"><code>names</code></em>
field of
<em class="parameter"><code>xkb</code></em>
is not
<span class="symbol">NULL</span>,
<code class="function">XkbGetNames</code>
obtains the values specified by
<em class="parameter"><code>which</code></em>
and copies them into the keyboard description
<em class="parameter"><code>xkb</code></em>.
</p><p>
If the
<em class="structfield"><code>map</code></em>
component of the
<em class="parameter"><code>xkb</code></em>
parameter is
<span class="symbol">NULL</span>,
<code class="function">XkbGetNames</code>
does not retrieve type or shift level names, even if
<span class="symbol">XkbKeyTypeNamesMask</span>
or
<span class="symbol">XkbKTLevelNamesMask</span>
are set in
<em class="parameter"><code>which</code></em>.
</p><p>
<code class="function">XkbGetNames</code>
can return
<span class="symbol">Success</span>,
or
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadLength</span>,
<span class="errorname">BadMatch</span>,
and
<span class="errorname">BadImplementation</span>
errors.
</p><p>
To free symbolic names, use
<code class="function">XkbFreeNames</code>
(see <a class="link" href="#Allocating_and_Freeing_Symbolic_Names" title="Allocating and Freeing Symbolic Names">section 18.6</a>)
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Changing_Symbolic_Names_on_the_Server"></a>Changing Symbolic Names on the Server</h2></div></div></div><p>
To change the symbolic names in the server, first modify a local copy of the
keyboard description and then use either
<code class="function">XkbSetNames</code>,
or, to save network traffic, use a
<span class="structname">XkbNameChangesRec</span>
structure and call
<code class="function">XkbChangeNames</code>
to download the changes to the server.
<code class="function">XkbSetNames</code>
and
<code class="function">XkbChangeNames</code>
can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadAtom</span>,
<span class="errorname">BadLength</span>,
<span class="errorname">BadMatch</span>,
and
<span class="errorname">BadImplementation</span>
errors.
</p><a id="idm15777" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetNames"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetNames</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">first_type</var>, unsigned int <var class="pdparam">num_types</var>, XkbDescPtr <var class="pdparam">xkb</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of names or map components to be changed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first_type</code></em>
    </span></p></td><td><p>
        first type whose name is to be changed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_types</code></em>
    </span></p></td><td><p>
        number of types for which names are to be changed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description from which names are to be taken
      </p></td></tr></tbody></table></div><p>
Use
<code class="function">XkbSetNames</code>
to change many names at the same time. For each bit set in
<em class="parameter"><code>which</code></em>,
<code class="function">XkbSetNames</code>
takes the corresponding value (or values in the case of arrays) from the
keyboard description
<em class="parameter"><code>xkb</code></em>
and sends it to the server.
</p><p>
The
<em class="parameter"><code>first_type</code></em>
and
<em class="parameter"><code>num_types</code></em>
arguments are used only if
<span class="symbol">XkbKeyTypeNamesMask</span>
or
<span class="symbol">XkbKTLevelNamesMask</span>
is set in
<em class="parameter"><code>which</code></em>
and specify a subset of the types for which the corresponding names are to be
changed. If either or both of these mask bits are set but the specified types
are illegal,
<code class="function">XkbSetNames</code>
returns
<span class="symbol">False</span>
and does not update any of the names specified in
<em class="parameter"><code>which</code></em>.
The specified types are illegal if
<em class="parameter"><code>xkb</code></em>
does not include a map component or if
<em class="parameter"><code>first_type</code></em>
and
<em class="parameter"><code>num_types</code></em>
specify types that are not defined in the keyboard description.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idm15837"></a></h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="The_XkbNameChangesRec_Structure"></a>The XkbNameChangesRec Structure</h4></div></div></div><a id="idm15841" class="indexterm"></a><p>
The
<span class="structname">XkbNameChangesRec</span>
allows applications to identify small modifications to the symbolic names and
effectively reduces the amount of traffic sent to the server:

</p><pre class="programlisting">
typedef struct _XkbNameChanges {
    unsigned int       changed;           /* name components that have
                                             changed */
    unsigned char      first_type;        /* first key type with a new name */
    unsigned char      num_types;         /* number of types with new names */
    unsigned char      first_lvl;         /* first key type with new level
                                             names */
    unsigned char      num_lvls;          /* number of key types with new
                                             level names */
    unsigned char      num_aliases;       /* if key aliases changed,
                                             total number of key aliases */
    unsigned char      num_rg;            /* if radio groups changed, total
                                             number of radio groups */
    unsigned char      first_key;         /* first key with a new name */
    unsigned char      num_keys;          /* number of keys with new names */
    unsigned short     changed_vmods;     /* mask of virtual modifiers
                                             for which names have changed */
    unsigned long      changed_indicators;  /* mask of indicators
                                               for which names were changed */
    unsigned char      changed_groups;    /* mask of groups for
                                             which names were changed */
} <span class="structname">XkbNameChangesRec</span>, *XkbNameChangesPtr;
</pre><p>
The
<em class="structfield"><code>changed</code></em>
field specifies the name components that have changed and is the bitwise
inclusive OR of the valid names mask bits defined in
<a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>. The rest of
the fields in the structure specify the ranges that have changed for the
various kinds of symbolic names, as shown in
<a class="link" href="#table18.2" title="Table 18.2. XkbNameChanges Fields">Table 18.2</a>.
</p><div class="table"><a id="table18.2"></a><p class="title"><strong>Table 18.2. XkbNameChanges Fields</strong></p><div class="table-contents"><table class="table" summary="XkbNameChanges Fields" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Mask</th><th align="left">Fields</th><th align="left">Component</th><th align="left">Field</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbKeyTypeNamesMask</span></td><td align="left">
<p>first_type,</p>
<p>num_types</p>
    </td><td align="left">Xkb-&gt;map</td><td align="left">type[*].name</td></tr><tr><td align="left"><span class="symbol">XkbKTLevelNamesMask</span></td><td align="left">
<p>first_lvl,</p>
<p>num_lvls</p>
    </td><td align="left">Xkb-&gt;map</td><td align="left">type[*].lvl_names[*]</td></tr><tr><td align="left"><span class="symbol">XkbKeyAliasesMask</span></td><td align="left">num_aliases</td><td align="left">Xkb-&gt;names</td><td align="left">key_aliases[*]</td></tr><tr><td align="left"><span class="symbol">XkbRGNamesMask</span></td><td align="left">num_rg</td><td align="left">Xkb-&gt;names</td><td align="left">radio_groups[*]</td></tr><tr><td align="left"><span class="symbol">XkbKeyNamesMask</span></td><td align="left">
<p>first_key,</p>
<p>num_keys</p>
    </td><td align="left">Xkb-&gt;names</td><td align="left">keys[*]</td></tr><tr><td align="left"><span class="symbol">XkbVirtualModNamesMask</span></td><td align="left">changed_vmods</td><td align="left">Xkb-&gt;names</td><td align="left">vmods[*]</td></tr><tr><td align="left"><span class="symbol">XkbIndicatorNamesMask</span></td><td align="left">changed_indicators</td><td align="left">Xkb-&gt;names</td><td align="left">indicators[*]</td></tr><tr><td align="left"><span class="symbol">XkbGroupNamesMask</span></td><td align="left">changed_groups</td><td align="left">Xkb-&gt;names</td><td align="left">groups[*]</td></tr></tbody></table></div></div><br class="table-break" /><p>
<code class="function">XkbChangeNames</code>
provides a more flexible method for changing symbolic names than
<code class="function">XkbSetNames</code>
and requires the use of an
<span class="structname">XkbNameChangesRec</span>
structure.
</p><a id="idm15924" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeNames"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbChangeNames</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbNameChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description from which names are to be taken
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        names map components to be updated on the server
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbChangeNames</code>
copies any names specified by
<em class="parameter"><code>changes</code></em>
from the keyboard description,
<em class="parameter"><code>xkb</code></em>,
to the X server specified by
<em class="parameter"><code>dpy</code></em>.
<code class="function">XkbChangeNames</code>
aborts and returns
<span class="symbol">False</span>
if any illegal type names or type shift level names are specified by
<em class="parameter"><code>changes</code></em>.
</p></div></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Name_Changes"></a>Tracking Name Changes</h2></div></div></div><a id="idm15963" class="indexterm"></a><a id="idm15967" class="indexterm"></a><p>
Whenever a symbolic name changes in the server’s keyboard description, the
server sends a
<span class="symbol">XkbNamesNotify</span>
event to all interested clients. To receive name notify events, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) with
<span class="symbol">XkbNamesNotifyMask</span>
in both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
parameters.
</p><p>
To receive events for only specific names, use
<code class="function">XkbSelectEventDetails</code>.
Set the
<em class="structfield"><code>event_type</code></em>
parameter to
<span class="symbol">XkbNamesNotify</span>,
and set both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
detail parameter to a mask composed of a bitwise OR of masks in
<a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>.
</p><p>
The structure for the
<span class="symbol">XkbNamesNotify</span>
event is defined as follows:

</p><pre class="programlisting">
typedef struct {
    int             type;           /* Xkb extension base event code */
    unsigned long   serial;         /* X server serial number for event */
    Bool            send_event;     /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *       display;        /* server connection where event generated */
    Time            time;           /* server time when event generated */
    int             xkb_type;       /* <span class="symbol">XkbNamesNotify</span> */
    int             device;         /* Xkb device ID, will not be
                                       <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int    changed;        /* mask of name components
                                       that have changed */
    int             first_type;     /* first key type with a new name */
    int             num_types;      /* number of types with new names */
    int             first_lvl;      /* first key type with new level names */
    int             num_lvls;       /* number of key types with new level names */
    int             num_aliases;    /* if key aliases changed, total number
                                       of key aliases */
    int             num_radio_groups;  /* if radio groups changed,
                                         total number of radio groups */
    unsigned int    changed_vmods;  /* mask of virtual modifiers for
                                       which names have changed */
    unsigned int    changed_groups; /* mask of groups for
                                       which names were changed */
    unsigned int    changed_indicators;  /* mask of indicators for which
                                              names were changed */
    int             first_key;      /* first key with a new name */
    int             num_keys;       /* number of keys with new names */
} <span class="structname">XkbNamesNotifyEvent</span>;
</pre><p>
The
<em class="structfield"><code>changed</code></em>
field specifies the name components that have changed and is the bitwise
inclusive OR of the valid names mask bits defined in
<a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>. The other
fields in this event are interpreted as the like-named fields in an
<span class="structname">XkbNameChangesRec</span> , as previously defined.
</p><p>
When your application receives a
<span class="symbol">XkbNamesNotify</span>
event, you can note the changed names in a changes structure using
<code class="function">XkbNoteNameChanges</code>.
</p><a id="idm15998" class="indexterm"></a><div class="funcsynopsis"><a id="XkbNoteNameChanges"></a><p><code class="funcdef">void <strong class="fsfunc">XkbNoteNameChanges</strong>(</code>XkbNameChangesPtr <var class="pdparam">old</var>, XkbNamesNotifyEvent *<var class="pdparam">new</var>, unsigned int <var class="pdparam">wanted</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>old</code></em>
    </span></p></td><td><p>
        <span class="structname">XkbNameChangesRec</span> structure to be updated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new</code></em>
    </span></p></td><td><p>
        event from which changes are to be copied
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>wanted</code></em>
    </span></p></td><td><p>
        types of names for which changes are to be noted
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>wanted</code></em>
parameter is the bitwise inclusive OR of the valid names mask bits shown in
<a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>.
<code class="function">XkbNoteNameChanges</code>
copies any changes that are reported in
<em class="parameter"><code>new</code></em>
and specified in
<em class="parameter"><code>wanted</code></em>
into the changes record specified by
<em class="parameter"><code>old</code></em>.
</p><p>
To update the local copy of the keyboard description with the actual values,
pass to
<code class="function">XkbGetNameChanges</code>
the results of one or more calls to
<code class="function">XkbNoteNameChanges</code>.
</p><a id="idm16038" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetNameChanges"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetNameChanges</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDescPtr <var class="pdparam">xkb</var>, XkbNameChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to the X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description to which names are copied
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        names components to be obtained from the server
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetNameChanges</code>
examines the
<em class="parameter"><code>changes</code></em>
parameter, retrieves the necessary information from the server, and places the
results into the
<em class="parameter"><code>xkb</code></em>
keyboard description.
</p><p>
<code class="function">XkbGetNameChanges</code>
can generate
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadImplementation</span>,
and
<span class="errorname">BadMatch</span>
errors.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_and_Freeing_Symbolic_Names"></a>Allocating and Freeing Symbolic Names</h2></div></div></div><p>
Most applications do not need to directly allocate symbolic names structures.
Do not allocate a names structure directly using
<code class="function">malloc</code>
or
<code class="function">Xmalloc</code>
if your application changes the number of key aliases or radio groups or
constructs a symbolic names structure without loading the necessary components
from the X server. Instead use
<code class="function">XkbAllocNames</code>.
</p><a id="idm16082" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocNames"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocNames</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, int <var class="pdparam">num_rg</var>, int <var class="pdparam">num_key_aliases</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description for which names are to be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of names to be allocated
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_rg</code></em>
    </span></p></td><td><p>
        total number of radio group names needed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_key_aliases</code></em>
    </span></p></td><td><p>
        total number of key aliases needed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocNames</code>
can return
<span class="errorname">BadAlloc</span>,
<span class="errorname">BadMatch</span>,
and
<span class="errorname">BadValue</span>
errors.
The
<em class="parameter"><code>which</code></em>
parameter is the bitwise inclusive OR of the valid names mask bits defined in
<a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>.
</p><p>
Do not free symbolic names structures directly using
<code class="function">free</code>
or
<code class="function">XFree</code>.
Use
<code class="function">XkbFreeNames</code>
instead.
</p><a id="idm16129" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeNames"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeNames</strong>(</code>XkbDescPtr <var class="pdparam">xkb</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_map</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>xkb</code></em>
    </span></p></td><td><p>
        keyboard description for which names are to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of names components to be freed
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_map</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span>
         ⇒ XkbNamesRec structure itself should be freed
      </p></td></tr></tbody></table></div><p>
The
<em class="parameter"><code>which</code></em>
parameter is the bitwise inclusive OR of the valid names mask bits defined in
<a class="link" href="#table18.1" title="Table 18.1. Symbolic Names Masks">Table 18.1</a>.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Replacing_a_Keyboard_On_the_Fly"></a>Chapter 19. Replacing a Keyboard <span class="quote">“<span class="quote">On the Fly</span>”</span></h1></div></div></div><p>
Some operating system and X server implementations allow
<span class="quote">“<span class="quote">hot plugging</span>”</span> of
input devices. When using these implementations, input devices can be unplugged
and new ones plugged in without restarting the software that is using those
devices. There is no provision in the standard X server for notification of
client programs if input devices are unplugged and/or new ones plugged in. In
the case of the X keyboard, this could result in the X server having a keymap
that does not match the new keyboard.
</p><p>
If the X server implementation supports the X input device extension, a client
program may also change the X keyboard programmatically. The
XChangeKeyboardDevice input extension request allows a client to designate an
input extension keyboard device as the X keyboard, in which case the old X
keyboard device becomes inaccessible except via the input device extension. In
this case, core protocol
<span class="symbol">MappingNotify</span>
and input extension
<span class="symbol">XChangeDeviceNotify</span>
events are generated to notify all clients that a new keyboard with a new
keymap has been designated.
</p><p>
When a client opens a connection to the X server, the server reports the
minimum and maximum keycodes. The server keeps track of the minimum and maximum
keycodes last reported to each client. When delivering events to a particular
client, the server filters out any events that fall outside of the valid range
for the client.
</p><p>
Xkb provides an
<span class="symbol">XkbNewKeyboardNotify</span>
event that reports a change in keyboard geometry and/or the range of supported
keycodes. The server can generate an
<span class="symbol">XkbNewKeyboardNotify</span>
event when it detects a new keyboard or in response to an
<code class="function">XkbGetKeyboardByName</code>
request that loads a new keyboard description. Selecting for
<span class="symbol">XkbNewKeyboardNotify</span>
events allows Xkb-aware clients to be notified whenever a keyboard change
occurs that may affect the keymap.
</p><p>
When a client requests
<span class="symbol">XkbNewKeyboardNotify</span>
events, the server compares the range of keycodes for the current keyboard to
the range of keycodes that are valid for the client. If they are not the same,
the server immediately sends the client an
<span class="symbol">XkbNewKeyboardNotify</span>
event. Even if the <span class="quote">“<span class="quote">new</span>”</span> keyboard is not new to the server,
it is new to this particular client.
</p><p>
When the server sends an
<span class="symbol">XkbNewKeyboardNotify</span>
event to a client to inform it of a new keycode range, it resets the stored
range of legal keycodes for the client to the keycode range reported in the
event; it does not reset this range for the client if it does not sent an
<span class="symbol">XkbNewKeyboardNotify</span>
event to a client. Because Xkb-unaware clients and Xkb-aware clients that do
not request
<span class="symbol">XkbNewKeyboardNotify</span>
events are never sent these events, the server’s notion of the legal keycode
range never changes, and these clients never receive events from keys that fall
outside of their notion of the legal keycode range.
</p><p>
Clients that have not selected to receive
<span class="symbol">XkbNewKeyboardNotify</span>
events do, however, receive the
<span class="symbol">XkbNewKeyboardNotify</span>
event when a keyboard change occurs. Clients that have not selected to receive
this event also receive numerous other events detailing the individual changes
that occur when a keyboard change occurs.
</p><p>
Clients wishing to track changes in
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
must watch for both
<span class="symbol">XkbNewKeyboardNotify</span>
and
<span class="symbol">XkbMapNotify</span>
events, because a simple mapping change causes an
<span class="symbol">XkbMapNotify</span>
event and may change the range of valid keycodes, but does not cause an
<span class="symbol">XkbNewKeyboardNotify</span>
event. If a client does not select for
<span class="symbol">XkbNewKeyboardNotify</span>
events, the server restricts the range of keycodes reported to the client.
</p><p>
In addition to filtering out-of-range key events, Xkb:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Adjusts core protocol
<span class="symbol">MappingNotify</span>
events to refer only to keys that match the stored legal range.
  </p></li><li class="listitem"><p>
Reports keyboard mappings for keys that match the stored legal range to clients
that issue a core protocol
<code class="systemitem">GetKeyboardMapping</code>
request.
  </p></li><li class="listitem"><p>
Reports modifier mappings only for keys that match the stored legal range to
clients that issue a core protocol
<code class="systemitem">GetModifierMapping</code>
request.
  </p></li><li class="listitem"><p>
Restricts the core protocol
<code class="systemitem">ChangeKeyboardMapping</code>
and
<code class="systemitem">SetModifierMapping</code>
requests to keys that fall inside the stored legal range.
  </p></li></ul></div><p>
In short, Xkb does everything possible to hide from Xkb-unaware clients the
fact that the range of legal keycodes has changed, because such clients cannot
be expected to deal with them. Xkb events and requests are not modified in this
manner; all Xkb events report the full range of legal keycodes. No requested
Xkb events are discarded, and no Xkb requests have their keycode range clamped.
</p><a id="idm16211" class="indexterm"></a><a id="idm16215" class="indexterm"></a><p>
The structure for the
<span class="symbol">XkbNewKeyboardNotify</span>
event is defined as follows:

</p><pre class="programlisting">
typedef struct _XkbNewKeyboardNotify {
    int            type;         /* Xkb extension base event code */
    unsigned long  serial;       /* X server serial number for event */
    Bool           send_event;   /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;      /* server connection where event generated */
    Time           time;         /* server time when event generated */
    int            xkb_type;     /* <span class="symbol">XkbNewKeyboardNotify</span> */
    int            device;       /* device ID of new keyboard */
    int            old_device;   /* device ID of old keyboard */
    int            min_key_code; /* min keycode of new keyboard */
    int            max_key_code; /* max keycode of new keyboard */
    int            old_min_key_code; /* min keycode of old keyboard */
    int            old_max_key_code; /* max keycode of old keyboard */
    unsigned int   changed;      /* changed aspects - see masks below */
    char           req_major;    /* major request that caused change */
    char           req_minor;    /* minor request that caused change */
} <span class="structname">XkbNewKeyboardNotifyEvent</span>;
</pre><p>
To receive name notify events, use
<code class="function">XkbSelectEvents</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>) with
<span class="symbol">XkbNewKeyboardNotifyMask</span>
in both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
parameters. To receive events for only specific names, use
<code class="function">XkbSelectEventDetails</code>.
Set the
<em class="structfield"><code>event_type</code></em>
parameter to
<span class="symbol">XkbNewKeyboardNotify</span>,
and set both the
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>
detail parameter to a mask composed of a bitwise OR of masks in
<a class="link" href="#table19.1" title="Table 19.1. XkbNewKeyboardNotifyEvent Details">Table 19.1</a>.
</p><div class="table"><a id="table19.1"></a><p class="title"><strong>Table 19.1. XkbNewKeyboardNotifyEvent Details</strong></p><div class="table-contents"><table class="table" summary="XkbNewKeyboardNotifyEvent Details" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">XkbNewKeyboardNotify Event Details</th><th align="left">Value</th><th align="left">Circumstances</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbNKN_KeycodesMask</span></td><td align="left">(1L&lt;&lt;0)</td><td align="left">Notification of keycode range changes wanted</td></tr><tr><td align="left"><span class="symbol">XkbNKN_GeometryMask</span></td><td align="left">(1L&lt;&lt;1)</td><td align="left">Notification of geometry changes wanted</td></tr><tr><td align="left"><span class="symbol">XkbNKN_DeviceIDMask</span></td><td align="left">(1L&lt;&lt;2)</td><td align="left">Notification of device ID changes wanted</td></tr><tr><td align="left"><span class="symbol">XkbAllNewKeyboardEventsMask</span></td><td align="left">(0x7)</td><td align="left">Includes all of the above masks</td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>req_major</code></em>
and
<em class="structfield"><code>req_minor</code></em>
fields indicate what type of keyboard change has occurred.
</p><p>
If
<em class="structfield"><code>req_major</code></em>
and
<em class="structfield"><code>req_minor</code></em>
are zero, the device change was not caused by a software request to the server
— a spontaneous change has occurred, such as hot-plugging a new device. In
this case,
<em class="structfield"><code>device</code></em>
is the device identifier for the new, current X keyboard device, but no
implementation-independent guarantee can be made about
<em class="structfield"><code>old_device</code></em>.
<em class="structfield"><code>old_device</code></em>
may be identical to
<em class="structfield"><code>device</code></em>
(an implementor is permitted to reuse the device specifier when the device
changes); or it may be different. Note that
<em class="structfield"><code>req_major</code></em>
and
<em class="structfield"><code>req_minor</code></em>
being zero do not necessarily mean that the physical keyboard device has
changed; rather, they only imply a spontaneous change outside of software
control (some systems have keyboards that can change personality at the press
of a key).
</p><p>
If the keyboard change is the result of an X Input Extension
<code class="systemitem">ChangeKeyboardDevice</code>
request,
<em class="structfield"><code>req_major</code></em>
contains the input extension major opcode, and
<em class="structfield"><code>req_minor</code></em>
contains the input extension request number for
<span class="symbol">X_ChangeKeyboardDevice</span>.
In this case,
<em class="structfield"><code>device</code></em>
and
<em class="structfield"><code>old_device</code></em>
are different, with
<em class="structfield"><code>device</code></em>
being the identifier for the new, current X keyboard device, and
<em class="structfield"><code>old_device</code></em>
being the identifier for the former device.
</p><p>
If the keyboard change is the result of an
<code class="function">XkbGetKeyboardByName</code>
function call, which generates an
<span class="symbol">X_kbGetKbdByName</span>
request,
<em class="structfield"><code>req_major</code></em>
contains the Xkb extension base event code (see <a class="link" href="#Initializing_the_Keyboard_Extension" title="Initializing the Keyboard Extension">section 2.4</a>), and
<em class="structfield"><code>req_minor</code></em>
contains the event code for the Xkb extension request
<span class="symbol">X_kbGetKbdByName</span>.
<em class="structfield"><code>device</code></em>
contains the device identifier for the new device, but nothing definitive can
be said for
<em class="structfield"><code>old_device</code></em>;
it may be identical to
<em class="structfield"><code>device</code></em>,
or it may be different, depending on the implementation.
</p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Server_Database_of_Keyboard_Components"></a>Chapter 20. Server Database of Keyboard Components</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#Component_Names">Component Names</a></span></dt><dt><span class="sect1"><a href="#Listing_the_Known_Keyboard_Components">Listing the Known Keyboard Components</a></span></dt><dt><span class="sect1"><a href="#Component_Hints">Component Hints</a></span></dt><dt><span class="sect1"><a href="#Building_a_Keyboard_Description_Using_the_Server_Database">Building a Keyboard Description Using the Server Database</a></span></dt></dl></div><p>
The X server maintains a database of keyboard components, identified by
component type. The database contains all the information necessary to build a
complete keyboard description for a particular device, as well as to assemble
partial descriptions. <a class="link" href="#table20.1" title="Table 20.1. Server Database Keyboard Components">Table 20.1</a>
identifies the component types and the type of information they contain.
</p><div class="table"><a id="table20.1"></a><p class="title"><strong>Table 20.1. Server Database Keyboard Components</strong></p><div class="table-contents"><table class="table" summary="Server Database Keyboard Components" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Component Type</th><th align="left">Component Primary Contents</th><th align="left">May also contain</th></tr></thead><tbody><tr><td align="left">Keymap</td><td align="left">
<p>Complete keyboard description</p>
<p>Normally assembled using a complete component from each of the other types</p>
    </td><td align="left"> </td></tr><tr><td align="left">Keycodes</td><td align="left">
<p>Symbolic name for each key</p>
<p>Minimum and maximum legal keycodes</p>
    </td><td align="left">
<p>Aliases for some keys</p>
<p>Symbolic names for indicators</p>
<p>Description of indicators physically present</p>
    </td></tr><tr><td align="left">Types</td><td align="left">Key types</td><td align="left">
Real modifier bindings and symbolic names for some virtual modifiers
    </td></tr><tr><td align="left">Compatibility</td><td align="left">Rules used to assign actions to keysyms</td><td align="left">
<p>Maps for some indicators</p>
<p>Real modifier bindings and symbolic names for some virtual modifiers</p>
    </td></tr><tr><td align="left">Symbols</td><td align="left">
<p>Symbol mapping for keyboard keys</p>
<p>Modifier mapping</p>
<p>Symbolic names for groups</p>
    </td><td align="left">
<p>Explicit actions and behaviors for some keys</p>
<p>Real modifier bindings and symbolic names for some virtual modifiers</p>
    </td></tr><tr><td align="left">Geometry</td><td align="left">Layout of the keyboard</td><td align="left">
<p>Aliases for some keys; overrides keycodes component aliases</p>
<p>Symbolic names for some indicators</p>
<p>Description of indicators physically present</p>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
While a keymap is a database entry for a complete keyboard description, and
therefore logically different from the individual component database entries,
the rules for processing keymap entries are identical to those for the
individual components. In the discussion that follows, the term component is
used to refer to either individual components or a keymap.
</p><p>
There may be multiple entries for each of the component types. An entry may be
either
<span class="emphasis"><em>complete</em></span>
or
<span class="emphasis"><em>partial</em></span>.
Partial entries describe only a piece of the corresponding keyboard component
and are designed to be combined with other entries of the same type to form a
complete entry.
</p><p>
For example, a partial symbols map might describe the differences between a
common ASCII keyboard and some national layout. Such a partial map is not
useful on its own because it does not include those symbols that are the same
on both the ASCII and national layouts (such as function keys). On the other
hand, this partial map can be used to configure
<span class="emphasis"><em>any</em></span>
ASCII keyboard to use a national layout.
</p><p>
When a keyboard description is built, the components are processed in the order
in which they appear in <a class="link" href="#table20.1" title="Table 20.1. Server Database Keyboard Components">Table 20.1</a>;
later definitions override earlier ones.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Component_Names"></a>Component Names</h2></div></div></div><p>
Component names have the form “<em class="replaceable"><code>class(member)</code></em>” where
<em class="replaceable"><code>class</code></em>
describes a subset of the available components for a particular type and the
optional
<em class="replaceable"><code>member</code></em>
identifies a specific component from that subset. For example, the name
"atlantis(acme)" for a symbols component might specify the symbols used for the
atlantis national keyboard layout by the vendor "acme." Each class has an
optional
<span class="emphasis"><em>default</em></span>
member — references that specify a class but not a member refer to the
default member of the class, if one exists. Xkb places no constraints on the
interpretation of the class and member names used in component names.
</p><p>
The
<em class="replaceable"><code>class</code></em>
and
<em class="replaceable"><code>member</code></em>
names are both specified using characters from the Latin-1 character set. Xkb
implementations must accept all alphanumeric characters, minus (‘-’) and
underscore (‘_’) in class or member names, and must not accept parentheses,
plus, vertical bar, percent sign, asterisk, question mark, or white space. The
use of other characters is implementation-dependent.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Listing_the_Known_Keyboard_Components"></a>Listing the Known Keyboard Components</h2></div></div></div><p>
You may ask the server for a list of components for one or more component
types. The request takes the form of a set of patterns, one pattern for each of
the component types, including a pattern for the complete keyboard description.
To obtain this list, use
<code class="function">XkbListComponents</code>.
</p><a id="idm16378" class="indexterm"></a><div class="funcsynopsis"><a id="XkbListComponents"></a><p><code class="funcdef">XkbComponentListPtr <strong class="fsfunc">XkbListComponents</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">device_spec</var>, XkbComponentNamesPtr <var class="pdparam">ptrns</var>, int *<var class="pdparam">max_inout</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ptrns</code></em>
    </span></p></td><td><p>
        namelist for components of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>max_inout</code></em>
    </span></p></td><td><p>
        max # returned names, # left over
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbListComponents</code>
queries the server for a list of component names matching the patterns
specified in
<em class="parameter"><code>ptrns</code></em>.
It waits for a reply and returns the matching component names in an
<span class="structname">XkbComponentListRec</span>
structure. When you are done using the structure, you should free it using
<code class="function">XkbFreeComponentList</code>.
<em class="parameter"><code>device_spec</code></em>
indicates a particular device in which the caller is interested. A server is
allowed (but not required) to restrict its reply to portions of the database
that are relevant for that particular device.
</p><p>
<em class="parameter"><code>ptrns</code></em>
is a pointer to an
<span class="structname">XkbComponentNamesRec</span>,
described below. Each of the fields in
<em class="parameter"><code>ptrns</code></em>
contains a pattern naming the components of interest. Each of the patterns is
composed of characters from the ISO
<span class="emphasis"><em>Latin1</em></span>
encoding, but can contain only parentheses, the wildcard characters
‘<code class="literal">?</code>’ and ‘<code class="literal">*</code>’,
and characters permitted in a component class or member name
(see <a class="link" href="#Component_Names" title="Component Names">section 20.1</a>). A pattern may be
<span class="symbol">NULL</span>,
in which case no components for that type is returned. Pattern matches with
component names are case sensitive. The
‘<code class="literal">?</code>’
wildcard matches any single character, except a left or right parenthesis;
the ‘<code class="literal">*</code>’
wildcard matches any number of characters, except a left or right
parenthesis. If an implementation allows additional characters in a component
class or member name other than those required by the Xkb extension (see
<a class="link" href="#Component_Names" title="Component Names">section 20.1</a>), the result of comparing one of the additional characters to
either of the wildcard characters is implementation-dependent.
</p><p>
If a pattern contains illegal characters, the illegal characters are ignored.
The matching process is carried out as if the illegal characters were omitted
from the pattern.
</p><p>
<em class="parameter"><code>max_inout</code></em>
is used to throttle the amount of data passed to and from the server. On
input, it specifies the maximum number of names to be returned (the total
number of names in all component categories). Upon return from
<code class="function">XkbListComponents</code>,
<em class="parameter"><code>max_inout</code></em>
contains the number of names that matched the request but were not returned
because of the limit.
</p><p><a id="XkbComponentNamesRec"></a>
<a id="idm16439" class="indexterm"></a>
The component name patterns used to describe the request are passed to
<code class="function">XkbListComponents</code>
using an
<span class="structname">XkbComponentNamesRec</span>
structure. This structure has no special allocation constraints or
interrelationships with other structures; allocate and free this structure
using standard
<code class="function">malloc</code>
and
<code class="function">free</code>
calls or their equivalent:

</p><pre class="programlisting">
typedef struct _XkbComponentNames {
    char *       keymap;    /* keymap names */
    char *       keycodes;  /* keycode names */
    char *       types;     /* type names */
    char *       compat;    /* compatibility map names */
    char *       symbols;   /* symbol names */
    char *       geometry;  /* geometry names */
} <span class="structname">XkbComponentNamesRec</span>, *XkbComponentNamesPtr;
</pre><p><a id="XkbComponentListRec"></a>
<a id="idm16449" class="indexterm"></a>
<a id="idm16452" class="indexterm"></a>
<code class="function">XkbListComponents</code>
returns a pointer to an
<span class="structname">XkbComponentListRec</span>:

</p><pre class="programlisting">
typedef struct _XkbComponentList {
    int                  num_keymaps;     /* number of entries in keymap */
    int                  num_keycodes;    /* number of entries in keycodes */
    int                  num_types;       /* number of entries in types */
    int                  num_compat;      /* number of entries in compat */
    int                  num_symbols;     /* number of entries in symbols */
    int                  num_geometry;    /* number of entries in geometry;
    XkbComponentNamePtr  keymap;          /* keymap names */
    XkbComponentNamePtr  keycodes;        /* keycode names */
    XkbComponentNamePtr  types;           /* type names */
    XkbComponentNamePtr  compat;          /* compatibility map names */
    XkbComponentNamePtr  symbols;         /* symbol names */
    XkbComponentNamePtr  geometry;        /* geometry names */
} <span class="structname">XkbComponentListRec</span>, *XkbComponentListPtr;

typedef struct _XkbComponentName {
    unsigned short       flags;           /* hints regarding component name */
    char *               name;            /* name of component */
} <span class="structname">XkbComponentNameRec</span>, *XkbComponentNamePtr;
</pre><p>
Note that the structure used to specify patterns on input is an
<span class="structname">XkbComponentNamesRec</span>,
and that used to hold the individual component names upon return is an
<span class="structname">XkbComponentNameRec</span>
(no trailing ‘s’ in Name).
</p><p>
When you are done using the structure returned by
<code class="function">XkbListComponents</code>,
free it using
<code class="function">XkbFreeComponentList</code>.
</p><a id="idm16466" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeComponentList"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeComponentList</strong>(</code>XkbComponentListPtr <var class="pdparam">list</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>list</code></em>
    </span></p></td><td><p>
        pointer to <span class="structname">XkbComponentListRec</span> to free
      </p></td></tr></tbody></table></div></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Component_Hints"></a>Component Hints</h2></div></div></div><p>
A set of flags is associated with each component; these flags provide
additional hints about the component’s use. These hints are designated by bit
masks in the flags field of the
<span class="structname">XkbComponentNameRec</span>
structures contained in the
<span class="structname">XkbComponentListRec</span>
returned from
<code class="function">XkbListComponents</code>.
The least significant byte of the flags field has the same meaning for all
types of keyboard components; the interpretation of the most significant byte
is dependent on the type of component. The flags bits are defined in
<a class="link" href="#table20.2" title="Table 20.2. XkbComponentNameRec Flags Bits">Table 20.2</a>.
The symbols hints in <a class="link" href="#table20.2" title="Table 20.2. XkbComponentNameRec Flags Bits">Table 20.2</a>
apply only to partial symbols components
(those with
<span class="symbol">XkbLC_Partial</span>
also set); full symbols components are assumed to specify all of the pieces.
</p><p>
The alphanumeric, modifier, keypad or function keys symbols hints should
describe the primary intent of the component designer and should not be simply
an exhaustive list of the kinds of keys that are affected. For example,
national keyboard layouts affect primarily alphanumeric keys, but many affect a
few modifier keys as well; such mappings should set only the
<span class="symbol">XkbLC_AlphanumericKeys</span>
hint. In general, symbols components should set only one of the four flags
(
<span class="symbol">XkbLC_AlternateGroup</span>
may be combined with any of the other flags).
</p><div class="table"><a id="table20.2"></a><p class="title"><strong>Table 20.2. XkbComponentNameRec Flags Bits</strong></p><div class="table-contents"><table class="table" summary="XkbComponentNameRec Flags Bits" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Component Type</th><th align="left">Component Hints (flags)</th><th align="left">Meaning</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left">All Components</td><td align="left"><p><span class="symbol">XkbLC_Hidden</span></p></td><td align="left">Do not present to user</td><td align="left">(1L&lt;&lt;0)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbLC_Default</span></td><td align="left">Default member of class</td><td align="left">(1L&lt;&lt;1)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbLC_Partial</span></td><td align="left">Partial component</td><td align="left">(1L&lt;&lt;2)</td></tr><tr><td align="left">Keymap</td><td align="left">none</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">Keycodes</td><td align="left">none</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">Types</td><td align="left">none</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">Compatibility</td><td align="left">none</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">Symbols</td><td align="left"><span class="symbol">XkbLC_AlphanumericKeys</span></td><td align="left">Bindings primarily for alphanumeric keyboard section</td><td align="left">(1L&lt;&lt;8)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbLC_ModifierKeys</span></td><td align="left">Bindings primarily for modifier keys</td><td align="left">(1L&lt;&lt;9)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbLC_KeypadKeys</span></td><td align="left">Bindings primarily for numeric keypad keys</td><td align="left">(1L&lt;&lt;10)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbLC_FunctionKeys</span></td><td align="left">Bindings primarily for function keys</td><td align="left">(1L&lt;&lt;11)</td></tr><tr><td align="left"> </td><td align="left"><span class="symbol">XkbLC_AlternateGroup</span></td><td align="left">Bindings for an alternate group</td><td align="left">(1L&lt;&lt;12)</td></tr><tr><td align="left">Geometry</td><td align="left">none</td><td align="left"> </td><td align="left"> </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Building_a_Keyboard_Description_Using_the_Server_Database"></a>Building a Keyboard Description Using the Server Database</h2></div></div></div><p>
A client may request that the server fetch one or more components from its
database and use those components to build a new server keyboard description.
The new keyboard description may be built from scratch, or it may be built
starting with the current keyboard description for a particular device. Once
the keyboard description is built, all or part of it may be returned to the
client. The parts returned to the client need not include all of the parts used
to build the description. At the time it requests the server to build a new
keyboard description, a client may also request that the server use the new
description internally to replace the current keyboard description for a
specific device, in which case the behavior of the device changes accordingly.
</p><p>
To build a new keyboard description from a set of named components, and to
optionally have the server use the resulting description to replace an active
one, use
<code class="function">XkbGetKeyboardByName</code>.
</p><a id="idm16587" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyboardByName"></a><p><code class="funcdef">XkbDescPtr <strong class="fsfunc">XkbGetKeyboardByName</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">device_spec</var>, XkbComponentNamesPtr <var class="pdparam">names</var>, unsigned int <var class="pdparam">want</var>, unsigned int <var class="pdparam">need</var>, Bool <var class="pdparam">load</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>names</code></em>
    </span></p></td><td><p>
        names of components to fetch
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>want</code></em>
    </span></p></td><td><p>
        desired structures in returned record
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>need</code></em>
    </span></p></td><td><p>
        mandatory structures in returned record
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>load</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ load into <em class="parameter"><code>device_spec</code></em>
      </p></td></tr></tbody></table></div><p>
<em class="parameter"><code>names</code></em>
contains a set of expressions describing the keyboard components the server
should use to build the new keyboard description.
<em class="parameter"><code>want</code></em>
and
<em class="parameter"><code>need</code></em>
are bit fields describing the parts of the resulting keyboard description that
should be present in the returned
<span class="structname">XkbDescRec</span>.
</p><p>
The individual fields in
<em class="parameter"><code>names</code></em>
are
<em class="firstterm">component expressions</em>
composed of keyboard component names (no wildcarding as may be used in
<code class="function">XkbListComponents</code>),
the special component name symbol ‘<code class="literal">%</code>’,
and the special operator characters
‘<code class="literal">+</code>’ and ‘<code class="literal">|</code>’.
A component expression is parsed left to right, as follows:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
The special component name “<code class="literal">computed</code>”
may be used in
<em class="structfield"><code>keycodes</code></em>
component expressions and refers to a component consisting of a set of
keycodes computed automatically by the server as needed.
  </p></li><li class="listitem"><p>
The special component name “<code class="literal">canonical</code>” may be used in
<em class="structfield"><code>types</code></em>
component expressions and refers to a partial component defining the four
standard key types:
<span class="emphasis"><em>ALPHABETIC</em></span>,
<span class="emphasis"><em>ONE_LEVEL</em></span>,
<span class="emphasis"><em>TWO_LEVEL</em></span>,
and
<span class="emphasis"><em>KEYPAD</em></span>.
</p></li><li class="listitem"><p>
The special component name ‘<code class="literal">%</code>’
refers to the keyboard description for the device specified in
<em class="parameter"><code>device_spec</code></em>
or the keymap names component. If a keymap names component is specified that
does not begin with
‘<code class="literal">+</code>’ or ‘<code class="literal">|</code>’ and does not contain
‘<code class="literal">%</code>’, then ‘<code class="literal">%</code>’
refers to the description generated by the keymap names component.
Otherwise, it refers to the keyboard description for
<em class="parameter"><code>device_spec</code></em>.
</p></li><li class="listitem"><p>
The ‘<code class="literal">+</code>’
operator specifies that the following component should
<span class="emphasis"><em>override</em></span>
the currently assembled description; any definitions that are present in both
components are taken from the second.
  </p></li><li class="listitem"><p>
The ‘<code class="literal">|</code>’
operator specifies that the next specified component should
<span class="emphasis"><em>augment</em></span>
the currently assembled description; any definitions that are present in both
components are taken from the first.
  </p></li><li class="listitem"><p>
If the component expression begins with an operator, a leading
‘<code class="literal">%</code>’ is implied.
  </p></li><li class="listitem"><p>
If any unknown or illegal characters appear anywhere in the expression, the
entire expression is invalid and is ignored.
  </p></li></ul></div><p>
For example, if
<em class="structfield"><code>names-&gt;symbols</code></em>
contained the expression "+de", it specifies that the default member of the
"de" class of symbols should be applied to the current keyboard mapping,
overriding any existing definitions (it could also be written "+de(default)").
</p><p>
Here is a slightly more involved example: the expression
"acme(ascii)+de(basic)|iso9995-3" constructs a German (de) mapping for the
ASCII keyboard supplied by the "acme" vendor. The new definition begins with
the symbols for the ASCII keyboard for Acme
(<code class="literal">acme(ascii)</code>),
overrides them with definitions for the basic German keyboard
(<code class="literal">de(basic)</code>),
and then applies the definitions from the default iso9995-3 keyboard
(
<code class="literal">iso9995-3</code>)
to any undefined keys or groups of keys (part three of the iso9995 standard
defines a common set of bindings for the secondary group, but allows national
layouts to override those definitions where necessary).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The interpretation of the above expression components (acme, ascii,
de, basic, iso9995-3) is not defined by Xkb; only the operations and their
ordering are.</p></div><p>
Note that the presence of a keymap
<em class="parameter"><code>names</code></em>
component that does not contain
‘<code class="literal">%</code>’
(either explicit or implied by virtue of an expression starting with an
operator) indicates a description that is independent of the keyboard
description for the device specified in
<em class="parameter"><code>device_spec</code></em>.
The same is true of requests in which the keymap names component is empty and
all five other names components contain expressions void of references to
‘<code class="literal">%</code>’.
Requests of this form allow you to deal with keyboard definitions
independent of any actual device.
</p><p>
The server parses all non-
<span class="symbol">NULL</span>
fields in
<em class="parameter"><code>names</code></em>
and uses them to build a keyboard description. However, before parsing the
expressions in
<em class="parameter"><code>names</code></em>,
the server ORs the bits in
<em class="parameter"><code>want</code></em>
and
<em class="parameter"><code>need</code></em>
together and examines the result in relationship to the expressions in
<em class="parameter"><code>names</code></em>.
<a class="link" href="#table20.3" title="Table 20.3. Want and Need Mask Bits and Required Names Components">Table 20.3</a>
identifies the components that are required for each of the
possible bits in
<em class="parameter"><code>want</code></em>
or
<em class="parameter"><code>need</code></em>.
If a required component has not been specified in the
<em class="parameter"><code>names</code></em>
structure (the corresponding field is
<span class="symbol">NULL</span>),
the server substitutes the expression
“<code class="literal">%</code>”,
resulting in the component values being taken from
<em class="parameter"><code>device_spec</code></em>.
In addition, if
<em class="parameter"><code>load</code></em>
is
<span class="symbol">True</span>,
the server modifies
<em class="parameter"><code>names</code></em>
if necessary (again using a
“<code class="literal">%</code>”
entry) to ensure all of the following fields are non-
<span class="symbol">NULL</span>:

<em class="structfield"><code>types</code></em>,
<em class="structfield"><code>keycodes</code></em>,
<em class="structfield"><code>symbols</code></em>,
and
<em class="structfield"><code>compat</code></em>.
</p><div class="table"><a id="table20.3"></a><p class="title"><strong>Table 20.3. Want and Need Mask Bits and Required Names Components</strong></p><div class="table-contents"><table class="table" summary="Want and Need Mask Bits and Required Names Components" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">want or need mask bit</th><th align="left">Required names Components</th><th align="left">value</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbGBN_TypesMask</span></td><td align="left">Types</td><td align="left">(1L&lt;&lt;0)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_CompatMapMask</span></td><td align="left">Compat</td><td align="left">(1L&lt;&lt;1)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_ClientSymbolsMask</span></td><td align="left">Types + Symbols + Keycodes</td><td align="left">(1L&lt;&lt;2)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_ServerSymbolsMask</span></td><td align="left">Types + Symbols + Keycodes</td><td align="left">(1L&lt;&lt;3)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_SymbolsMask</span></td><td align="left">Symbols</td><td align="left">(1L&lt;&lt;1)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_IndicatorMapMask</span></td><td align="left">Compat</td><td align="left">(1L&lt;&lt;4)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_KeyNamesMask</span></td><td align="left">Keycodes</td><td align="left">(1L&lt;&lt;5)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_GeometryMask</span></td><td align="left">Geometry</td><td align="left">(1L&lt;&lt;6)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_OtherNamesMask</span></td><td align="left">Types + Symbols + Keycodes + Compat + Geometry</td><td align="left">(1L&lt;&lt;7)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_AllComponentsMask</span></td><td align="left"> </td><td align="left">(0xff)</td></tr></tbody></table></div></div><br class="table-break" /><p>
<em class="parameter"><code>need</code></em>
specifies a set of keyboard components that the server must be able to resolve
in order for
<code class="function">XkbGetKeyboardByName</code>
to succeed; if any of the components specified in
<em class="parameter"><code>need</code></em>
cannot be successfully resolved,
<code class="function">XkbGetKeyboardByName</code>
fails.
</p><p>
<em class="parameter"><code>want</code></em>
specifies a set of keyboard components that the server should attempt to
resolve, but that are not mandatory. If the server is unable to resolve any of
these components,
<code class="function">XkbGetKeyboardByName</code>
still succeeds. Bits specified in
<em class="parameter"><code>want</code></em>
that are also specified in
<em class="parameter"><code>need</code></em>
have no effect in the context of
<em class="parameter"><code>want</code></em>.
</p><p>
If
<em class="parameter"><code>load</code></em>
is
<span class="symbol">True</span>,
the server updates its keyboard description for
<em class="parameter"><code>device_spec</code></em>
to match the result of the keyboard description just built. If load is
<span class="symbol">False</span>,
the server’s description for device
<em class="parameter"><code>device_spec</code></em>
is not updated. In all cases, the parts specified by
<em class="parameter"><code>want</code></em>
and
<em class="parameter"><code>need</code></em>
from the just-built keyboard description are returned.
</p><p>
The
<em class="parameter"><code>names</code></em>
structure in an
<span class="structname">XkbDescRec</span>
keyboard description record (see <a class="xref" href="#Symbolic_Names" title="Chapter 18. Symbolic Names">Chapter 18, <em>Symbolic Names</em></a>) contains one field for each of
the five component types used to build a keyboard description. When a keyboard
description is built from a set of database components, the corresponding
fields in this
<em class="parameter"><code>names</code></em>
structure are set to match the expressions used to build the component.
</p><p>
The entire process of building a new keyboard description from the server
database of components and returning all or part of it is diagrammed in Figure
20.1:
</p><div class="figure"><a id="figure20.1"></a><p class="title"><strong>Figure 20.1. Building a New Keyboard Description from the Server Database</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="XKBlib-21.svg"></object></div></div></div><br class="figure-break" /><p>
The information returned to the client in the
<span class="structname">XkbDescRec</span>
is essentially the result of a series of calls to extract information from a
fictitious device whose description matches the one just built. The calls
corresponding to each of the mask bits are summarized in
<a class="link" href="#table20.4" title="Table 20.4. XkbDescRec Components Returned for Values of Want &amp; Needs">Table 20.4</a>, together with the
<span class="structname">XkbDescRec</span>
components that are filled in.
</p><div class="table"><a id="table20.4"></a><p class="title"><strong>Table 20.4. XkbDescRec Components Returned for Values of Want &amp; Needs</strong></p><div class="table-contents"><table class="table" summary="XkbDescRec Components Returned for Values of Want &amp; Needs" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Request (want+need)</th><th align="left">Fills in Xkb components</th><th align="left">Equivalent Function Call</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbGBN_TypesMask</span></td><td align="left">map.types</td><td align="left">XkbGetUpdatedMap(dpy, XkbTypesMask, Xkb)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_ServerSymbolsMask</span></td><td align="left">server</td><td align="left">XkbGetUpdatedMap(dpy, XkbAllClientInfoMask, Xkb)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_ClientSymbolsMask</span></td><td align="left">map, including map.types</td><td align="left">XkbGetUpdatedMap(dpy, XkbAllServerInfoMask, Xkb)</td></tr><tr><td align="left">XkbGBN_IndicatorMaps</td><td align="left">indicators</td><td align="left">XkbGetIndicatorMap(dpy, XkbAllIndicators, Xkb)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_CompatMapMask</span></td><td align="left">compat</td><td align="left">XkbGetCompatMap(dpy, XkbAllCompatMask, Xkb)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_GeometryMask</span></td><td align="left">geom</td><td align="left">XkbGetGeometry(dpy, Xkb)</td></tr><tr><td align="left"><span class="symbol">XkbGBN_KeyNamesMask</span></td><td align="left">
<p>names.keys</p>
<p>names.key_aliases</p>
    </td><td align="left">
XkbGetNames(dpy, XkbKeyNamesMask | XkbKeyAliasesMask, Xkb)
    </td></tr><tr><td align="left"><span class="symbol">XkbGBN_OtherNamesMask</span></td><td align="left">
<p>names.keycodes</p>
<p>names.geometry</p>
<p>names.symbols</p>
<p>names.types</p>
<p>map.types[*].lvl_names[*]</p>
<p>names.compat</p>
<p>names.vmods</p>
<p>names.indicators</p>
<p>names.groups</p>
<p>names.radio_groups</p>
<p>names.phys_symbols</p>
    </td><td align="left">
<p>XkbGetNames(dpy, XkbAllNamesMask &amp;</p>
<p>~(XkbKeyNamesMask | XkbKeyAliasesMask),</p>
<p>Xkb)</p>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
There is no way to determine which components specified in
<em class="parameter"><code>want</code></em>
(but not in
<em class="parameter"><code>need</code></em>)
were actually fetched, other than breaking the call into successive calls to
<code class="function">XkbGetKeyboardByName</code>
and specifying individual components.
</p><p>
<code class="function">XkbGetKeyboardByName</code>
always sets
<em class="structfield"><code>min_key_code</code></em>
and
<em class="structfield"><code>max_key_code</code></em>
in the returned
<span class="structname">XkbDescRec</span>
structure.
</p><p>
<code class="function">XkbGetKeyboardByName</code>
is synchronous; it sends the request to the server to build a new keyboard
description and waits for the reply. If successful, the return value is
non-<span class="symbol">NULL</span>.
<code class="function">XkbGetKeyboardByName</code>
generates a <span class="errorname">BadMatch</span>
protocol error if errors are encountered when building the keyboard
description.
</p><p>
If you simply want to obtain information about the current keyboard device,
rather than generating a new keyboard description from elements in the server
database, use
<code class="function">XkbGetKeyboard</code>
(see <a class="link" href="#Obtaining_a_Keyboard_Description_from_the_Server" title="Obtaining a Keyboard Description from the Server">section 6.2</a>).
</p><a id="idm16903" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetKeyboard.20"></a><p><code class="funcdef">XkbDescPtr <strong class="fsfunc">XkbGetKeyboard</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">device_spec</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of components of <span class="structname">XkbDescRec</span> of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetKeyboard</code>
is used to read the current description for one or more components of a
keyboard device. It calls
<code class="function">XkbGetKeyboardByName</code>
as follows:
</p><p>
<code class="function">XkbGetKeyboardByName</code>
(
<em class="parameter"><code>dpy</code></em>,
<em class="parameter"><code>device_spec</code></em>,
<span class="symbol">NULL</span>,
<em class="parameter"><code>which</code></em>,
<em class="parameter"><code>which</code></em>,
<span class="symbol">False</span>).

</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Attaching_Xkb_Actions_to_X_Input_Extension_Devices"></a>Chapter 21. Attaching Xkb Actions to X Input Extension Devices</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="sect1"><a href="#XkbDeviceInfoRec">XkbDeviceInfoRec</a></span></dt><dt><span class="sect1"><a href="#Querying_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices">Querying Xkb Features for Non-KeyClass Input Extension Devices</a></span></dt><dt><span class="sect1"><a href="#Allocating_Initializing_and_Freeing_the_XkbDeviceInfoRecStructure">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></span></dt><dt><span class="sect1"><a href="#Setting_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices">Setting Xkb Features for Non-KeyClass Input Extension Devices</a></span></dt><dt><span class="sect1"><a href="#XkbExtensionDeviceNotify_Event">XkbExtensionDeviceNotify Event</a></span></dt><dt><span class="sect1"><a href="#Tracking_Changes_to_Extension_Devices">Tracking Changes to Extension Devices</a></span></dt></dl></div><p>
The X input extension allows an X server to support multiple keyboards, as well
as other input devices, in addition to the core X keyboard and pointer. The
input extension categorizes devices by grouping them into classes. Keyboards
and other input devices with keys are classified as KeyClass devices by the
input extension. Other types of devices supported by the input extension
include, but are not limited to: mice, tablets, touchscreens, barcode readers,
button boxes, trackballs, identifier devices, data gloves, and eye trackers.
Xkb provides additional control over all X input extension devices, whether
they are <span class="symbol">KeyClass</span>
devices or not, as well as the core keyboard and pointer.
</p><p>
If an X server implements support for both the input extension and Xkb, the
server implementor determines whether interaction between Xkb and the input
extension is allowed. Implementors are free to restrict the effects of Xkb to
only the core X keyboard device or allow interaction between Xkb and the input
extension.
</p><p>
Several types of interaction between Xkb and the input extension are defined by
Xkb. Some or all may be allowed by the X server implementation.
</p><p>
Regardless of whether the server allows interaction between Xkb and the input
extension, the following access is provided:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Xkb functionality for the core X keyboard device and its mapping is accessed
via the functions described in the other chapters of this specification.
  </p></li><li class="listitem"><p>
Xkb functionality for the core X pointer device is accessed via the
XkbGetDeviceInfo and XkbSetDeviceInfo functions described in this chapter.
  </p></li></ul></div><p>
If all types of interaction are allowed between Xkb and the input extension,
the following additional access is provided:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
If allowed, Xkb functionality for additional
<span class="symbol">KeyClass</span>
devices supported by the input extension is accessed via those same functions.
  </p></li><li class="listitem"><p>
If allowed, Xkb functionality for non-
<span class="symbol">KeyClass</span>
devices supported by the input extension is also accessed via the
XkbGetDeviceInfo and XkbSetDeviceInfo functions described in this chapter.
  </p></li></ul></div><p>
Each device has an X Input Extension device ID. Each device may have several
classes of feedback. For example, there are two types of feedbacks that can
generate bells: bell feedback and keyboard feedback
(<span class="symbol">BellFeedbackClass</span>
and
<span class="symbol">KbdFeedbackClass</span>).
A device can have more than one feedback of each type; the feedback ID
identifies the particular feedback within its class.
</p><p>
A keyboard feedback has:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Auto-repeat status (global and per key)
  </p></li><li class="listitem"><p>
32 LEDs
  </p></li><li class="listitem"><p>
A bell
  </p></li></ul></div><p>
An indicator feedback has:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Up to 32 LEDs
  </p></li></ul></div><p>
If the input extension is present and the server allows interaction between the
input extension and Xkb, then the core keyboard, the core keyboard indicators,
and the core keyboard bells may each be addressed using an appropriate device
spec, class, and ID. The constant
<span class="symbol">XkbDfltXIId</span>
may be used as the device ID to specify the core keyboard indicators for the
core indicator feedback. The particular device ID corresponding to the core
keyboard feedback and the core indicator feedback may be obtained by calling
<code class="function">XkbGetDeviceInfo</code>
and specifying
<span class="symbol">XkbUseCoreKbd</span>
as the
<em class="parameter"><code>device_spec</code></em>;
the values will be returned in
<em class="structfield"><code>dflt_kbd_fb</code></em>
and
<em class="structfield"><code>dflt_led_fb</code></em>.
</p><p>
If the server does not allow Xkb access to input extension
<span class="symbol">KeyClass</span>
devices, attempts to use Xkb requests with those devices fail with a
<span class="errorname">BadKeyboard</span>
error. Attempts to access non-
<span class="symbol">KeyClass</span>
input extension devices via XkbGetDeviceInfo and XkbSetDeviceInfo fail
silently if Xkb access to those devices is not supported by the X server.
</p><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="XkbDeviceInfoRec"></a>XkbDeviceInfoRec</h2></div></div></div><a id="idm16992" class="indexterm"></a><a id="idm16995" class="indexterm"></a><p>
Information about X Input Extension devices is transferred between a client
program and the Xkb extension in an
<span class="structname">XkbDeviceInfoRec</span>
structure:

</p><pre class="programlisting">
typedef struct {
    char *          name;          /* name for device */
    Atom            type;          /* name for class of devices */
    unsigned short  device_spec;   /* device of interest */
    Bool            has_own_state; /* <span class="symbol">True</span> ⇒ this device has
                                      its own state */
    unsigned short  supported;     /* bits indicating supported capabilities */
    unsigned short  unsupported;   /* bits indicating unsupported capabilities */
    unsigned short  num_btns;      /* number of entries in <em class="structfield"><code>btn_acts</code></em> */
    XkbAction *     btn_acts;      /* button actions */
    unsigned short  sz_leds;       /* total number of entries in LEDs vector */
    unsigned short  num_leds;      /* number of valid entries in LEDs vector */
    unsigned short  dflt_kbd_fb;   /* input extension ID of default
                                      (core kbd) indicator */
    unsigned short  dflt_led_fb;   /* input extension ID of default
                                      indicator feedback */
    XkbDeviceLedInfoPtr  leds;     /* LED descriptions */
} <span class="structname">XkbDeviceInfoRec</span>, *XkbDeviceInfoPtr;

typedef struct {
    unsigned short  led_class;     /* class for this LED device */
    unsigned short  led_id;        /* ID for this LED device */
    unsigned int    phys_indicators; /* bits for which LEDs physically present */
    unsigned int    maps_present;  /* bits for which LEDs have maps in <em class="structfield"><code>maps</code></em> */
    unsigned int    names_present; /* bits for which LEDs are in <em class="structfield"><code>names</code></em> */
    unsigned int    state;         /* 1 bit ⇒ corresponding LED is on */
    Atom            names[XkbNumIndicators]; /* names for LEDs */
    XkbIndicatorMapRec  maps;      /* indicator maps for each LED */
} <span class="structname">XkbDeviceLedInfoRec</span>, *XkbDeviceLedInfoPtr;
</pre><p>
The
<em class="structfield"><code>type</code></em>
field is a registered symbolic name for a class of devices (for example,
"TABLET"). If a device is a keyboard (that is, is a member of
<span class="symbol">KeyClass</span>),
it has its own state, and
<em class="structfield"><code>has_own_state</code></em>
is
<span class="symbol">True</span>.
If
<em class="structfield"><code>has_own_state</code></em>
is
<span class="symbol">False</span>,
the state of the core keyboard is used. The
<em class="structfield"><code>supported</code></em>
and
<em class="structfield"><code>unsupported</code></em>
fields are masks where each bit indicates a capability. The meaning of the
mask bits is listed in <a class="link" href="#table21.1" title="Table 21.1. XkbDeviceInfoRec Mask Bits">Table 21.1</a>,
together with the fields in the
<span class="structname">XkbDeviceInfoRec</span>
structure that are associated with the capability represented by each bit. The
same bits are used to indicate the specific information desired in many of the
functions described subsequently in this section.
</p><div class="table"><a id="table21.1"></a><p class="title"><strong>Table 21.1. XkbDeviceInfoRec Mask Bits</strong></p><div class="table-contents"><table class="table" summary="XkbDeviceInfoRec Mask Bits" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Name</th><th align="left">XkbDeviceInfoRec Fields Effected</th><th align="left">Value</th><th align="left">Capability If Set</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbXI_KeyboardsMask</span></td><td align="left"> </td><td align="left">(1L &lt;&lt; 0)</td><td align="left">
Clients can use all Xkb requests and events with
<span class="symbol">KeyClass</span>
devices supported by the input device extension.
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_ButtonActionsMask</span></td><td align="left">
<p>num_btns</p>
<p>btn_acts</p>
    </td><td align="left">(1L &lt;&lt;1)</td><td align="left">
Clients can assign key actions to buttons on non-
<span class="symbol">KeyClass</span>
input extension devices.
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_IndicatorNamesMask</span></td><td align="left">leds-&gt;names</td><td align="left">(1L &lt;&lt;2)</td><td align="left">
Clients can assign names to indicators on non-
<span class="symbol">KeyClass</span>
input extension devices.
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_IndicatorMapsMask</span></td><td align="left">leds-&gt;maps</td><td align="left">(1L &lt;&lt;3)</td><td align="left">
Clients can assign indicator maps to indicators on non-
<span class="symbol">KeyClass</span>
input extension devices.
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_IndicatorStateMask</span></td><td align="left">leds-&gt;state</td><td align="left">(1L &lt;&lt;4)</td><td align="left">
Clients can request the status of indicators on non-
<span class="symbol">KeyClass</span>
input extension devices.
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_IndicatorsMask</span></td><td align="left">
<p>sz_leds</p>
<p>num_leds</p>
<p>leds-&gt;*</p>
    </td><td align="left">(0x1c)</td><td align="left">
<p><span class="symbol">XkbXI_IndicatorNames­Mask</span> |</p>
<p><span class="symbol">XkbXI_IndicatorMaps­Mask</span> |</p>
<p><span class="symbol">XkbXI_IndicatorState­Mask</span></p>
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_UnsupportedFeaturesMask</span></td><td align="left">unsupported</td><td align="left">(1L &lt;&lt;15)</td><td align="left"> </td></tr><tr><td align="left"><span class="symbol">XkbXI_AllDeviceFeaturesMask</span></td><td align="left">Those selected by Value column masks</td><td align="left">(0x1e)</td><td align="left">
<p><span class="symbol">XkbXI_Indicators­Mask</span> | </p>
<p><span class="symbol">XkbXI_ButtonActions­Mask</span> </p>
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_AllFeaturesMask</span></td><td align="left">Those selected by Value column masks</td><td align="left">(0x1f)</td><td align="left">
<p><span class="symbol">XkbXI_AllDevice­FeaturesMask</span> | </p>
<p><span class="symbol">XkbXI_Keyboards­Mask</span> </p>
    </td></tr><tr><td align="left"><span class="symbol">XkbXI_AllDetailsMask</span></td><td align="left">Those selected by Value column masks</td><td align="left">(0x801f)</td><td align="left">
<p><span class="symbol">XkbXI_AllFeatures­Mask</span> | </p>
<p><span class="symbol">XkbXI_Unsupported­FeaturesMask</span></p>
    </td></tr></tbody></table></div></div><br class="table-break" /><p>
The
<em class="structfield"><code>name</code></em>,
<em class="structfield"><code>type</code></em>,
<em class="structfield"><code>has_own_state</code></em>,
<em class="structfield"><code>supported</code></em>,
and
<em class="structfield"><code>unsupported</code></em>
fields are always filled in when a valid reply is returned from the server
involving an
<span class="structname">XkbDeviceInfoRec</span>.
All of the other fields are modified only if the particular function asks for
them.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Querying_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices"></a>Querying Xkb Features for Non-KeyClass Input Extension Devices</h2></div></div></div><p>
To determine whether the X server allows Xkb access to particular capabilities
of input devices other than the core X keyboard, or to determine the status of
indicator maps, indicator names or button actions on a non-
<span class="symbol">KeyClass</span>
extension device, use XkbGetDeviceInfo.
</p><a id="idm17131" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetDeviceInfo"></a><p><code class="funcdef">XkbDeviceInfoPtr <strong class="fsfunc">XkbGetDeviceInfo</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">ind_class</var>, unsigned int <var class="pdparam">ind_id</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask indicating information to return
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID, or <span class="symbol">XkbUseCoreKbd</span>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ind_class</code></em>
    </span></p></td><td><p>
        feedback class for indicator requests
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ind_id</code></em>
    </span></p></td><td><p>
        feedback ID for indicator requests
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetDeviceInfo</code>
returns information about the input device specified by
<em class="parameter"><code>device_spec</code></em>.
Unlike the
<em class="parameter"><code>device_spec</code></em>
parameter of most Xkb functions,
<em class="parameter"><code>device_spec</code></em>
does not need to be a keyboard device. It must, however, indicate either the
core keyboard or a valid X Input Extension device.
</p><p>
The
<em class="parameter"><code>which</code></em>
parameter
is a mask specifying optional information to be returned. It is an inclusive OR
of one or more of the values from <a class="link" href="#table21.1" title="Table 21.1. XkbDeviceInfoRec Mask Bits">Table 21.1</a>
and causes the returned
<span class="structname">XkbDeviceInfoRec</span>
to contain values for the corresponding fields specified in the table.
</p><p>
The
<span class="structname">XkbDeviceInfoRec</span>
returned by
<code class="function">XkbGetDeviceInfo</code>
always has values for
<em class="structfield"><code>name</code></em>
(may be a null string, ""),
<em class="structfield"><code>type</code></em>,
<em class="structfield"><code>supported</code></em>,
<em class="structfield"><code>unsupported</code></em>,
<em class="structfield"><code>has_own_state</code></em>,
<em class="structfield"><code>dflt_kbd_fb</code></em>,
and
<em class="structfield"><code>dflt_led_fb</code></em>.
Other fields are filled in as specified by
<em class="parameter"><code>which</code></em>.
</p><p>
Upon return, the
<em class="structfield"><code>supported</code></em>
field will be set to the inclusive OR of zero or more bits from
<a class="link" href="#table21.1" title="Table 21.1. XkbDeviceInfoRec Mask Bits">Table 21.1</a>;
each bit set indicates an optional Xkb extension device feature supported by
the server implementation, and a client may modify the associated behavior.
</p><p>
If the
<span class="symbol">XkbXI_ButtonActionsMask</span>
bit is set in
<em class="parameter"><code>which</code></em>,
the
<span class="structname">XkbDeviceInfoRec</span>
returned will have the button actions
(<em class="structfield"><code>btn_acts</code></em>
field) filled in for all buttons.
</p><p>
If
<em class="parameter"><code>which</code></em>
includes one of the bits in <span class="symbol">XkbXI_IndicatorsMask</span>,
the feedback class of the
indicators must be specified in ind_class, and the feedback ID of the
indicators must be specified in ind_id. If the request does not include any of
the bits in <span class="symbol">XkbXI_IndicatorsMask</span>,
the ind_class and ind_id parameters are
ignored. The class and ID can be obtained via the input device extension
XListInputDevices request.
</p><p>
If any of the
<span class="symbol">XkbXI_IndicatorsMask</span>
bits are set in
<em class="parameter"><code>which</code></em>,
the
<span class="structname">XkbDeviceInfoRec</span>
returned will have filled in the portions of the
<em class="structfield"><code>leds</code></em>
structure corresponding to the indicator feedback identified by
<em class="parameter"><code>ind_class</code></em>
and
<em class="parameter"><code>ind_id</code></em>.
The
<em class="structfield"><code>leds</code></em>
vector of the
<span class="structname">XkbDeviceInfoRec</span>
is allocated if necessary and
<em class="structfield"><code>sz_leds</code></em>
and
<em class="structfield"><code>num_leds</code></em>
filled in. The
<em class="structfield"><code>led_class</code></em>,
<em class="structfield"><code>led_id</code></em>
and
<em class="structfield"><code>phys_indicators</code></em>
fields of the
<em class="structfield"><code>leds</code></em>
entry corresponding to
<em class="parameter"><code>ind_class</code></em>
and
<em class="parameter"><code>ind_id</code></em>
are always filled in. If
<em class="parameter"><code>which</code></em>
contains
<span class="symbol">XkbXI_IndicatorNamesMask</span>,
the
<em class="structfield"><code>names_present</code></em>
and
<em class="structfield"><code>names</code></em>
fields of the
<em class="structfield"><code>leds</code></em>
structure corresponding to
<em class="parameter"><code>ind_class</code></em>
and
<em class="parameter"><code>ind_id</code></em>
are returned.
If
<em class="parameter"><code>which</code></em>
contains
<span class="symbol">XkbXI_IndicatorStateMask</span>,
the corresponding
<em class="structfield"><code>state</code></em>
field is updated. If
<em class="parameter"><code>which</code></em>
contains
<span class="symbol">XkbXI_IndicatorMapsMask</span>,
the
<em class="structfield"><code>maps_present</code></em>
and
<em class="structfield"><code>maps</code></em>
fields are updated.
</p><p>
Xkb provides convenience functions to request subsets of the information
available via
<code class="function">XkbGetDeviceInfo</code>.
These convenience functions mirror some of the mask bits. The functions all
take an
<span class="type">XkbDeviceInfoPtr</span>
as an input argument and operate on the X Input Extension device specified by
the
<em class="parameter"><code>device_spec</code></em>
field of the structure. Only the parts of the structure indicated in the
function description are updated. The
<span class="structname">XkbDeviceInfoRec</span>
structure used in the function call can be obtained by calling
XkbGetDeviceInfo or can be allocated by calling XkbAllocDeviceInfo
(see <a class="link" href="#Allocating_Initializing_and_Freeing_the_XkbDeviceInfoRecStructure" title="Allocating, Initializing, and Freeing the XkbDeviceInfoRec Structure">section 21.3</a>).
</p><p>
These convenience functions are described as follows.
</p><p>
To query the button actions associated with an X Input Extension device, use
XkbGetDeviceButtonActions.
</p><a id="idm17246" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetDeviceButtonActions"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetDeviceButtonActions</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDeviceInfoPtr <var class="pdparam">device_info</var>, Bool <var class="pdparam">all_buttons</var>, unsigned int <var class="pdparam">first_button</var>, unsigned int <var class="pdparam">num_buttons</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure to update with results
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>all_buttons</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ get information for all buttons
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first_button</code></em>
    </span></p></td><td><p>
        number of first button for which info is desired
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_buttons</code></em>
    </span></p></td><td><p>
        number of buttons for which info is desired
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetDeviceButtonActions</code>
queries the server for the desired button information for the device indicated
by the
<em class="structfield"><code>device_spec</code></em>
field of
<em class="parameter"><code>device_info</code></em>
and waits for a reply. If successful,
<code class="function">XkbGetDeviceButtonActions</code>
backfills the button actions
(<em class="structfield"><code>btn_acts</code></em>
field of
<em class="parameter"><code>device_info</code></em>)
for only the requested buttons, updates the
<em class="structfield"><code>name</code></em>,
<em class="structfield"><code>type</code></em>,
<em class="structfield"><code>supported</code></em>,
and
<em class="structfield"><code>unsupported</code></em>
fields, and returns
<span class="symbol">Success</span>.
</p><p>
<em class="parameter"><code>all_buttons</code></em>,
<em class="parameter"><code>first_button</code></em>
and
<em class="parameter"><code>num_buttons</code></em>
specify the device buttons for which actions should be returned. Setting
<em class="parameter"><code>all_buttons</code></em>
to
<span class="symbol">True</span>
requests actions for all device buttons; if
<em class="parameter"><code>all_buttons</code></em>
is
<span class="symbol">False</span>,
<em class="parameter"><code>first_button</code></em>
and
<em class="parameter"><code>num_buttons</code></em>
specify a range of buttons for which actions are requested.
</p><p>
If a compatible version of Xkb is not available in the server or the Xkb
extension has not been properly initialized, XkbGetDeviceButtonActions returns
<span class="errorname">BadAccess</span>.
If allocation errors occur, a
<span class="errorname">BadAlloc</span>
status is returned. If the specified device
(<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>device_spec</code></em>)
is invalid, a
<span class="errorname">BadKeyboard</span>
status is returned. If the device has no buttons, a
<span class="errorname">BadMatch</span>
status is returned. If
<em class="parameter"><code>first_button</code></em>
and
<em class="parameter"><code>num_buttons</code></em>
specify illegal buttons, a
<span class="errorname">BadValue</span>
status is returned.
</p><p>
To query the indicator names, maps, and state associated with an LED feedback
of an input extension device, use XkbGetDeviceLedInfo.
</p><a id="idm17323" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetDeviceLedInfo"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetDeviceLedInfo</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDeviceInfoPtr <var class="pdparam">device_info</var>, unsigned int <var class="pdparam">led_class</var>, unsigned int <var class="pdparam">led_id</var>, unsigned int <var class="pdparam">which</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure to update with results
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>led_class</code></em>
    </span></p></td><td><p>
        LED feedback class assigned by input extension
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>led_id</code></em>
    </span></p></td><td><p>
        LED feedback ID assigned by input extension
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask indicating desired information
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbGetDeviceLedInfo</code>
queries the server for the desired LED information for the feedback specified
by
<em class="parameter"><code>led_class</code></em>
and
<em class="parameter"><code>led_id</code></em>
for the X input extension device indicated by
<em class="structfield"><code>device_spec</code></em>-&gt;<em class="parameter"><code>device_info</code></em>
and waits for a reply. If successful,
<code class="function">XkbGetDeviceLedInfo</code>
backfills the relevant fields of
<em class="parameter"><code>device_info</code></em>
as determined by
<em class="parameter"><code>which</code></em>
with the results and returns
<span class="symbol">Success</span>.
Valid values for
<em class="parameter"><code>which</code></em>
are the inclusive OR of any of
<span class="symbol">XkbXI_IndicatorNamesMask</span>,
<span class="symbol">XkbXI_IndicatorMapsMask</span>,
and
<span class="symbol">XkbXI_IndicatorStateMask</span>.
</p><p>
The fields of
<em class="parameter"><code>device_info</code></em>
that are filled in when this request succeeds are
<em class="structfield"><code>name</code></em>,
<em class="structfield"><code>type</code></em>,
<em class="structfield"><code>supported</code></em>,
and
<em class="structfield"><code>unsupported</code></em>,
and portions of the
<em class="structfield"><code>leds</code></em>
structure corresponding to
<em class="parameter"><code>led_class</code></em>
and
<em class="parameter"><code>led_id</code></em>
as indicated by the bits set in
<em class="parameter"><code>which</code></em>.
The
<em class="structfield"><code>device_info-&gt;leds</code></em>
vector is allocated if necessary and
<em class="structfield"><code>sz_leds</code></em>
and
<em class="structfield"><code>num_leds</code></em>
filled in. The
<em class="parameter"><code>led_class</code></em>,
<em class="parameter"><code>led_id</code></em>
and
<em class="structfield"><code>phys_indicators</code></em>
fields of the
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>
entry corresponding to
<em class="parameter"><code>led_class</code></em>
and
<em class="parameter"><code>led_id</code></em>
are always filled in.
</p><p>
If
<em class="parameter"><code>which</code></em>
contains
<span class="symbol">XkbXI_IndicatorNamesMask</span>,
the
<em class="structfield"><code>names_present</code></em>
and
<em class="structfield"><code>names</code></em>
fields of the
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>
structure corresponding to
<em class="parameter"><code>led_class</code></em>
and
<em class="parameter"><code>led_id</code></em>
are updated, if
<em class="parameter"><code>which</code></em>
contains
<span class="symbol">XkbXI_IndicatorStateMask</span>,
the corresponding
<em class="structfield"><code>state</code></em>
field is updated, and if
<em class="parameter"><code>which</code></em>
contains
<span class="symbol">XkbXI_IndicatorMapsMask</span>,
the
<em class="structfield"><code>maps_present</code></em>
and
<em class="structfield"><code>maps</code></em>
fields are updated.
</p><p>
If a compatible version of Xkb is not available in the server or the Xkb
extension has not been properly initialized,
<code class="function">XkbGetDeviceLedInfo</code>
returns
<span class="errorname">BadAccess</span>.
If allocation errors occur, a
<span class="errorname">BadAlloc</span>
status is returned. If the device has no indicators, a
<span class="errorname">BadMatch</span>
error is returned. If
<em class="structfield"><code>ledClass</code></em>
or
<em class="structfield"><code>ledID</code></em>
have illegal values, a
<span class="errorname">BadValue</span>
error is returned. If they have legal values but do not specify a feedback
that contains LEDs and is associated with the specified device, a
<span class="errorname">BadMatch</span>
error is returned.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Allocating_Initializing_and_Freeing_the_XkbDeviceInfoRecStructure"></a>Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</h2></div></div></div><p>
To obtain an
<span class="structname">XkbDeviceInfoRec</span>
structure, use XkbGetDeviceInfo or XkbAllocDeviceInfo.
</p><a id="idm17429" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocDeviceInfo"></a><p><code class="funcdef">XkbDeviceInfoPtr <strong class="fsfunc">XkbAllocDeviceInfo</strong>(</code>unsigned int <var class="pdparam">device_spec</var>, unsigned int <var class="pdparam">n_buttons</var>, unsigned int <var class="pdparam">sz_leds</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>device_spec</code></em>
    </span></p></td><td><p>
        device ID with which structure will be used
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>n_buttons</code></em>
    </span></p></td><td><p>
        number of button actions to allocate space for
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>sz_leds</code></em>
    </span></p></td><td><p>
        number of LED feedbacks to allocate space for
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocDeviceInfo</code>
allocates space for an
<span class="structname">XkbDeviceInfoRec</span>
structure and initializes that structure’s
<em class="parameter"><code>device_spec</code></em>
field with the device ID specified by device_spec. If
<em class="parameter"><code>n_buttons</code></em>
is nonzero,
<em class="parameter"><code>n_buttons</code></em>
<span class="structname">XkbAction</span>s
are linked into the
<span class="structname">XkbDeviceInfoRec</span>
structure and initialized to zero. If sz_leds is nonzero,
<em class="parameter"><code>sz_leds</code></em>
<span class="structname">XkbDeviceLedInfoRec</span>
structures are also allocated and linked into the
<span class="structname">XkbDeviceInfoRec</span>
structure. If you request
<span class="structname">XkbDeviceLedInfoRec</span>
structures be allocated using this request, you must initialize them
explicitly.
</p><p>
To obtain an
<span class="structname">XkbDeviceLedInfoRec</span>
structure, use XkbAllocDeviceLedInfo.
</p><a id="idm17472" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAllocDeviceLedInfo"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbAllocDeviceLedInfo</strong>(</code>XkbDeviceInfoPtr <var class="pdparam">device_info</var>, int <var class="pdparam">num_needed</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure in which to allocate LED space
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_needed</code></em>
    </span></p></td><td><p>
        number of indicators to allocate space for
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAllocDeviceLedInfo</code>
allocates space for an
<span class="structname">XkbDeviceLedInfoRec</span>
and places it in
<em class="parameter"><code>device_info</code></em>.
If num_needed is nonzero,
<em class="parameter"><code>num_needed</code></em>
<span class="structname">XkbIndicatorMapRec</span>
structures are also allocated and linked into the
<span class="structname">XkbDeviceLedInfoRec</span>
structure. If you request
<span class="structname">XkbIndicatorMapRec</span>
structures be allocated using this request, you must initialize them
explicitly. All other fields are initialized to zero.
</p><p>
To initialize an
<span class="structname">XkbDeviceLedInfoRec</span>
structure, use XkbAddDeviceLedInfo.
</p><a id="idm17504" class="indexterm"></a><div class="funcsynopsis"><a id="XkbAddDeviceLedInfo"></a><p><code class="funcdef">XkbDeviceLedInfoPtr <strong class="fsfunc">XkbAddDeviceLedInfo</strong>(</code>XkbDeviceInfoPtr <var class="pdparam">device_info</var>, unsigned int <var class="pdparam">led_class</var>, unsigned int <var class="pdparam">led_id</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure in which to add LED info
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>led_class</code></em>
    </span></p></td><td><p>
        input extension class for LED device of interest
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>led_id</code></em>
    </span></p></td><td><p>
        input extension ID for LED device of interest
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbAddDeviceLedInfo</code>
first checks to see whether an entry matching
<em class="parameter"><code>led_class</code></em>
and
<em class="parameter"><code>led_id</code></em>
already exists in the
<em class="structfield"><code>device_info-&gt;leds</code></em>
array. If it finds a matching entry, it returns a pointer to that entry.
Otherwise, it checks to be sure there is at least one empty entry in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>
and extends it if there is not enough room. It then increments
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>num_leds</code></em>
and fills in the next available entry in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>
with
<em class="parameter"><code>led_class</code></em>
and
<em class="parameter"><code>led_id</code></em>.
</p><p>
If successful,
<code class="function">XkbAddDeviceLedInfo</code>
returns a pointer to the
<span class="structname">XkbDeviceLedInfoRec</span>
structure that was initialized. If unable to allocate sufficient storage, or
if
<em class="parameter"><code>device_info</code></em>
points to an invalid
<span class="structname">XkbDeviceInfoRec</span>
structure, or if
<em class="parameter"><code>led_class</code></em>
or
<em class="parameter"><code>led_id</code></em>
are inappropriate,
<code class="function">XkbAddDeviceLedInfo</code>
returns
<span class="symbol">NULL</span>.
</p><p>
To allocate additional space for button actions in an
<span class="structname">XkbDeviceInfoRec</span>
structure, use XkbResizeDeviceButtonActions.
</p><a id="idm17557" class="indexterm"></a><div class="funcsynopsis"><a id="XkbResizeDeviceButtonActions"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbResizeDeviceButtonActions</strong>(</code>XkbDeviceInfoPtr <var class="pdparam">device_info</var>, unsigned int <var class="pdparam">new_total</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure in which to allocate button actions
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new_total</code></em>
    </span></p></td><td><p>
        new total number of button actions needed
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbResizeDeviceButtonActions</code>
reallocates space, if necessary, to make sure there is room for a total of
<em class="parameter"><code>new_total</code></em>
button actions in the
<em class="parameter"><code>device_info</code></em>
structure. Any new entries allocated are zeroed. If successful,
<code class="function">XkbResizeDeviceButtonActions</code>
returns Success. If new_total is zero, all button actions are deleted,
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>num_btns</code></em>
is set to zero, and
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>btn_acts</code></em>
is set to
<span class="symbol">NULL</span>.
If device_info is invalid or new_total is greater than 255,
<span class="errorname">BadValue</span>
is returned. If a memory allocation failure occurs, a
<span class="errorname">BadAlloc</span>
is returned.
</p><p>
To free an
<span class="structname">XkbDeviceInfoRec</span>
structure, use XkbFreeDeviceInfo.
</p><a id="idm17593" class="indexterm"></a><div class="funcsynopsis"><a id="XkbFreeDeviceInfo"></a><p><code class="funcdef">void <strong class="fsfunc">XkbFreeDeviceInfo</strong>(</code>XkbDeviceInfoPtr <var class="pdparam">device_info</var>, unsigned int <var class="pdparam">which</var>, Bool <var class="pdparam">free_all</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        pointer to <span class="structname">XkbDeviceInfoRec</span> in which to free items
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask of components of <em class="parameter"><code>device_info</code></em> to free
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>free_all</code></em>
    </span></p></td><td><p>
        <span class="symbol">True</span> ⇒ free everything, including device_info
      </p></td></tr></tbody></table></div><p>
If free_all is
<span class="symbol">True</span>,
the
<code class="function">XkbFreeDeviceInfo</code>
frees all components of
<em class="parameter"><code>device_info</code></em>
and the
<span class="structname">XkbDeviceInfoRec</span>
structure pointed to by
<em class="parameter"><code>device_info</code></em>
itself. If free_all is
<span class="symbol">False</span>,
the value of which determines which subcomponents are freed.
<em class="parameter"><code>which</code></em>
is an inclusive OR of one or more of the values from
<a class="link" href="#table21.1" title="Table 21.1. XkbDeviceInfoRec Mask Bits">Table 21.1</a>. If which
contains <span class="symbol">XkbXI_ButtonActionsMask</span>,
all button actions associated with
<em class="parameter"><code>device_info</code></em>
are freed,
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>btn_acts</code></em>
is set to
<span class="symbol">NULL</span>,
and
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>num_btns</code></em>
is set to zero. If which contains all bits in
<span class="symbol">XkbXI_IndicatorsMask</span>, all
<span class="structname">XkbDeviceLedInfoRec</span>
structures associated with
<em class="parameter"><code>device_info</code></em>
are freed,
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>
is set to
<span class="symbol">NULL</span>,
and
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>sz_leds</code></em>
and
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>num_leds</code></em>
are set to zero. If which contains <span class="symbol">XkbXI_IndicatorMapsMask</span>,
all indicator maps associated with
<em class="parameter"><code>device_info</code></em>
are cleared, but the number of LEDs and the leds structures themselves are
preserved. If which contains <span class="symbol">XkbXI_IndicatorNamesMask</span>,
all indicator names
associated with device_info are cleared, but the number of LEDs and the leds
structures themselves are preserved. If which contains
<span class="symbol">XkbXI_IndicatorStateMask</span>,
the indicator state associated with the
<em class="parameter"><code>device_info</code></em>
leds are set to zeros but the number of LEDs and the leds structures
themselves are preserved.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Setting_Xkb_Features_for_Non_KeyClass_Input_Extension_Devices"></a>Setting Xkb Features for Non-KeyClass Input Extension Devices</h2></div></div></div><p>
The Xkb extension allows clients to assign any key action to either core
pointer or input extension device buttons. This makes it possible to control
the keyboard or generate keyboard key events from extension devices or from the
core pointer.
</p><p>
Key actions assigned to core X pointer buttons or input extension device
buttons cause key events to be generated as if they had originated from the
core X keyboard.
</p><p>
Xkb implementations are required to support key actions for the buttons of the
core pointer device, but support for actions on extension devices is optional.
Implementations that do not support button actions for extension devices must
not set the
<span class="symbol">XkbXI_ButtonActionsMask</span>
bit in the
<em class="structfield"><code>supported</code></em>
field of an
<span class="structname">XkbDeviceInfoRec</span>
structure.
</p><p>
If a client attempts to modify valid characteristics of a device using an
implementation that does not support modification of those characteristics, no
protocol error is generated. Instead, the server reports a failure for the
request; it also sends an
<span class="symbol">XkbExtensionDeviceNotify</span>
event to the client that issued the request if the client has selected to
receive these events.
</p><p>
To change characteristics of an X Input Extension device in the server, first
modify a local copy of the device structure and then use either
<code class="function">XkbSetDeviceInfo</code>,
or, to save network traffic, use an
<span class="structname">XkbDeviceChangesRec</span>
structure (see <a class="link" href="#Tracking_Changes_to_Extension_Devices" title="Tracking Changes to Extension Devices">section 21.6</a>) and call
<code class="function">XkbChangeDeviceInfo</code>
to download the changes to the server.
</p><p>
To modify some or all of the characteristics of an X Input Extension device,
use XkbSetDeviceInfo.
</p><a id="idm17672" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetDeviceInfo"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetDeviceInfo</strong>(</code>Display *<var class="pdparam">dpy</var>, unsigned int <var class="pdparam">which</var>, XkbDeviceInfoPtr <var class="pdparam">device_info</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>which</code></em>
    </span></p></td><td><p>
        mask indicating characteristics to modify
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure defining the device and modifications
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetDeviceInfo</code>
sends a request to the server to modify the characteristics of the device
specified in the
<em class="parameter"><code>device_info</code></em>
structure. The particular characteristics modified are identified by the bits
set in
<em class="parameter"><code>which</code></em>
and take their values from the relevant fields in
<em class="parameter"><code>device_info</code></em>
(see <a class="link" href="#table21.1" title="Table 21.1. XkbDeviceInfoRec Mask Bits">Table 21.1</a>).
<code class="function">XkbSetDeviceInfo</code>
returns
<span class="symbol">True</span>
if the request was successfully sent to the server. If the X server
implementation does not allow interaction between the X input extension and the
Xkb Extension, the function does nothing and returns
<span class="symbol">False</span>.
</p><p>
The
<em class="parameter"><code>which</code></em>
parameter specifies which aspects of the device should be changed and is a
bitmask composed of an inclusive OR or one or more of the following bits:
<span class="symbol">XkbXI_ButtonActionsMask</span>,
<span class="symbol">XkbXI_IndicatorNamesMask</span>,
<span class="symbol">XkbXI_IndicatorMapsMask</span>.
If the features requested to be manipulated in
<em class="parameter"><code>which</code></em>
are valid for the device, but the server does not support assignment of one or
more of them, that particular portion of the request is ignored.
</p><p>
If the device specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>device_spec</code></em>
does not contain buttons and a request affecting buttons is made, or the
device does not contain indicators and a request affecting indicators is made,
a
<span class="errorname">BadMatch</span>
protocol error results.
</p><p>
If the
<span class="symbol">XkbXI_ButtonActionsMask</span>
bit is set in the supported mask returned by XkbGetDeviceInfo, the Xkb
extension allows applications to assign key actions to buttons on input
extension devices other than the core keyboard device. If the
<span class="symbol">XkbXI_ButtonActionsMask</span>
is set in
<em class="parameter"><code>which</code></em>,
the actions for all buttons specified in device_info are set to the
<span class="structname">XkbAction</span>s
specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>btn_acts</code></em>.
If the number of buttons requested to be updated is not valid for the device,
<code class="function">XkbSetDeviceInfo</code>
returns
<span class="symbol">False</span>
and a
<span class="errorname">BadValue</span>
protocol error results.
</p><p>
If the
<span class="symbol">XkbXI_IndicatorMapsMask</span>
and / or
<span class="symbol">XkbXI_IndicatorNamesMask</span>
bit is set in the supported mask returned by XkbGetDeviceInfo, the Xkb
extension allows applications to assign maps and / or names to the indicators
of nonkeyboard extension devices. If supported, maps and / or names can be
assigned to all extension device indicators, whether they are part of a
keyboard feedback or part of an indicator feedback.
</p><p>
If the
<span class="symbol">XkbXI_IndicatorMapsMask</span>
and / or
<span class="symbol">XkbXI_IndicatorNamesMask</span>
flag is set in
<em class="parameter"><code>which</code></em>,
the indicator maps and / or names for all
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>num_leds</code></em>
indicator devices specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>
are set to the maps and / or names specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>.
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds</code></em>-&gt;<em class="structfield"><code>led_class</code></em>
and
<em class="structfield"><code>led_id</code></em>
specify the input extension class and device ID for each indicator device to
modify; if they have invalid values, a
<span class="errorname">BadValue</span>
protocol error results and
<code class="function">XkbSetDeviceInfo</code>
returns
<span class="symbol">False</span>.
If they have legal values but do not specify a keyboard or indicator class
feedback for the device in question, a
<span class="errorname">BadMatch</span>
error results. If any of the values in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>leds-&gt;names</code></em>
are not a valid Atom or
<span class="symbol">None</span>,
a
<span class="errorname">BadAtom</span>
protocol error results.
</p><p>
Xkb provides convenience functions to modify subsets of the information
accessible via
<code class="function">XkbSetDeviceInfo</code>.
Only the parts of the structure indicated in the function description are
modified. These convenience functions are described as follows.
</p><p>
To change only the button actions for an input extension device, use
XkbSetDeviceButtonActions.
</p><a id="idm17758" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetDeviceButtonActions"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetDeviceButtonActions</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDeviceInfoPtr <var class="pdparam">device_info</var>, unsigned int <var class="pdparam">first_button</var>, unsigned int <var class="pdparam">num_buttons</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure defining the device and modifications
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>first_button</code></em>
    </span></p></td><td><p>
        number of first button to update, 0 relative
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>num_buttons</code></em>
    </span></p></td><td><p>
        number of buttons to update
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetDeviceButtonActions</code>
assigns actions to the buttons of the device specified in
device_info-&gt;<em class="structfield"><code>device_spec</code></em>.
Actions are assigned to
<em class="parameter"><code>num_buttons</code></em>
buttons beginning with
<em class="parameter"><code>first_button</code></em>
and are taken from the actions specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>btn_acts</code></em>.
</p><p>
If the server does not support assignment of Xkb actions to extension device
buttons,
<code class="function">XkbSetDeviceButtonActions</code>
has no effect and returns
<span class="symbol">False</span>.
If the device has no buttons or if
<em class="parameter"><code>first_button</code></em>
or
<em class="parameter"><code>num_buttons</code></em>
specify buttons outside of the valid range as determined by
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>num_btns</code></em>,
the function has no effect and returns
<span class="symbol">False</span>.
Otherwise,
<code class="function">XkbSetDeviceButtonActions</code>
sends a request to the server to change the actions for the specified buttons
and returns
<span class="symbol">True</span>.
</p><p>
If the actual request sent to the server involved illegal button numbers, a
<span class="errorname">BadValue</span>
protocol error is generated. If an invalid device identifier is specified in
device_info-&gt;<em class="structfield"><code>device_spec</code></em>,
a <span class="errorname">BadKeyboard</span>
protocol error results. If the actual device specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>device_spec</code></em>
does not contain buttons and a request affecting buttons is made, a
<span class="errorname">BadMatch</span>
protocol error is generated.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="XkbExtensionDeviceNotify_Event"></a>XkbExtensionDeviceNotify Event</h2></div></div></div><a id="idm17820" class="indexterm"></a><a id="idm17824" class="indexterm"></a><p>
The Xkb extension generates
<span class="symbol">XkbExtensionDeviceNotify</span>
events when the status of an input extension device changes or when an attempt
is made to use an Xkb feature that is not supported by a particular device.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Events indicating an attempt to use an unsupported feature are
delivered only to the client requesting the event.</p></div><p>
To track changes to the status of input extension devices or attempts to use
unsupported features of a device, select to receive
<span class="symbol">XkbExtensionDeviceNotify</span>
events by calling either
<code class="function">XkbSelectEvents</code>
or
<code class="function">XkbSelectEventDetails</code>
(see <a class="link" href="#Selecting_Xkb_Events" title="Selecting Xkb Events">section 4.3</a>).
</p><p>
To receive
<span class="symbol">XkbExtensionDeviceNotify</span>
events under all possible conditions, call
<code class="function">XkbSelectEvents</code>
and pass
<span class="symbol">XkbExtensionDeviceNotifyMask</span>
in both
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
</p><p>
The
<span class="symbol">XkbExtensionDeviceNotify</span>
event has no event details. However, you can call
<code class="function">XkbSelectEventDetails</code>
using
<span class="symbol">XkbExtensionDeviceNotify</span>
as the
<em class="structfield"><code>event_type</code></em>
and specifying
<span class="symbol">XkbAllExtensionDeviceEventsMask</span>
in
<em class="parameter"><code>bits_to_change</code></em>
and
<em class="parameter"><code>values_for_bits</code></em>.
This has the same effect as a call to
<code class="function">XkbSelectEvents</code>.
</p><p>
The structure for
<span class="symbol">XkbExtensionDeviceNotify</span>
events is:

</p><pre class="programlisting">
typedef struct {
    int            type;           /* Xkb extension base event code */
    unsigned long  serial;         /* X server serial number for event */
    Bool           send_event;     /* <span class="symbol">True</span> ⇒ synthetically generated */
    Display *      display;        /* server connection where event generated */
    Time           time;           /* server time when event generated */
    int            xkb_type;       /* <span class="structname">XkbExtensionDeviceNotifyEvent</span> */
    int            device;         /* Xkb device ID, will not be <span class="symbol">XkbUseCoreKbd</span> */
    unsigned int   reason;         /* reason for the event */
    unsigned int   supported;      /* mask of supported features */
    unsigned int   unsupported;    /* unsupported features this client
                                      attempted to use */
    int            first_btn;      /* first button that changed */
    int            num_btns;       /* number of buttons that changed */
    unsigned int   leds_defined;   /* indicators with names or maps */
    unsigned int   led_state;      /* current state of the indicators */
    int            led_class;      /* feedback class for LED changes */
    int            led_id;         /* feedback ID for LED changes */
} <span class="structname">XkbExtensionDeviceNotifyEvent</span>;
</pre><p>
The
<span class="symbol">XkbExtensionDeviceNotify</span>
event has fields enabling it to report changes in the state (on/off) of all of
the buttons for a device, but only for one LED feedback associated with a
device. You will get multiple events when more than one LED feedback changes
state or configuration.
</p></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Tracking_Changes_to_Extension_Devices"></a>Tracking Changes to Extension Devices</h2></div></div></div><a id="idm17862" class="indexterm"></a><a id="idm17865" class="indexterm"></a><p>
Changes to an Xkb extension device may be tracked by listening to
<span class="symbol">XkbExtensionDeviceNotify</span>
events and accumulating the changes in an
<span class="structname">XkbDeviceChangesRec</span>
structure. The changes noted in the structure may then be used in subsequent
operations to update either a server configuration or a local copy of an Xkb
extension device configuration. The changes structure is defined as follows:

</p><pre class="programlisting">
typedef struct _XkbDeviceChanges {
    unsigned int    changed;      /* bits indicating what has changed */
    unsigned short  first_btn;    /* number of first button which changed,
                                     if any */
    unsigned short  num_btns;     /* number of buttons that have changed */
    XkbDeviceLedChangesRec leds;
} <span class="structname">XkbDeviceChangesRec</span>, *XkbDeviceChangesPtr;

typedef struct _XkbDeviceLedChanges {
    unsigned short  led_class;    /* class of this indicator feedback bundle */
    unsigned short  led_id;       /* ID of this indicator feedback bundle */
    unsigned int    names;        /* bits indicating which names have changed */
    unsigned int    maps;         /* bits indicating which maps have changed */
    struct _XkbDeviceLedChanges *next; /* link to indicator change record
                                          for next set */
} <span class="structname">XkbDeviceLedChangesRec</span>, *XkbDeviceLedChangesPtr;
</pre><p>
A local description of the configuration and state of a device may be kept in
an
<span class="structname">XkbDeviceInfoRec</span>
structure. The actual state or configuration of the device may change because
of XkbSetDeviceInfo and XkbSetButtonActions requests made by clients or by user
interaction with the device. The X server sends an XkbExtensionDeviceNotify
event to all interested clients when the state of any buttons or indicators or
the configuration of the buttons or indicators on the core keyboard or any
input extension device changes. The event reports the state of indicators for a
single indicator feedback, and the state of up to 128 buttons. If more than 128
buttons or more than one indicator feedback are changed, the additional buttons
and indicator feedbacks are reported in subsequent events. Xkb provides
functions with which you can track changes to input extension devices by noting
the changes that were made and then requesting the changed information from the
server.
</p><p>
To note device changes reported in an
<span class="symbol">XkbExtensionDeviceNotify</span>
event, use XkbNoteDeviceChanges.
</p><a id="idm17878" class="indexterm"></a><div class="funcsynopsis"><a id="XkbNoteDeviceChanges"></a><p><code class="funcdef">void <strong class="fsfunc">XkbNoteDeviceChanges</strong>(</code>XkbDeviceChangesPtr <var class="pdparam">old</var>, XkbExtensionDeviceNotifyEvent             *<var class="pdparam">new</var>, unsigned int <var class="pdparam">wanted</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>old</code></em>
    </span></p></td><td><p>
        structure tracking state changes
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>new</code></em>
    </span></p></td><td><p>
        event indicating state changes
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>wanted</code></em>
    </span></p></td><td><p>
        mask indicating changes to note
      </p></td></tr></tbody></table></div><p>
The wanted field specifies the changes that should be noted in
<em class="parameter"><code>old</code></em>,
and is composed of the bitwise inclusive OR of one or more of the masks from
<a class="link" href="#table21.1" title="Table 21.1. XkbDeviceInfoRec Mask Bits">Table 21.1</a>.
The
<em class="structfield"><code>reason</code></em>
field of the event in
<em class="parameter"><code>new</code></em>
indicates the types of changes the event is reporting.
<code class="function">XkbNoteDeviceChanges</code>
updates the
<span class="structname">XkbDeviceChangesRec</span>
specified by
<em class="parameter"><code>old</code></em>
with the changes that are both specified in
<em class="parameter"><code>wanted</code></em>
and contained in
<em class="parameter"><code>new</code></em>-&gt;<em class="structfield"><code>reason</code></em>.
</p><p>
To update a local copy of the state and configuration of an X input extension
device with the changes previously noted in an
<span class="structname">XkbDeviceChangesRec</span>
structure, use XkbGetDeviceInfoChanges.
</p><p>
To query the changes that have occurred in the button actions or indicator
names and indicator maps associated with an input extension device, use
XkbGetDeviceInfoChanges.
</p><a id="idm17921" class="indexterm"></a><div class="funcsynopsis"><a id="XkbGetDeviceInfoChanges"></a><p><code class="funcdef">Status <strong class="fsfunc">XkbGetDeviceInfoChanges</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDeviceInfoPtr <var class="pdparam">device_info</var>, XkbDeviceChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        structure to update with results
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        contains notes of changes that have occurred
      </p></td></tr></tbody></table></div><p>
The changes-&gt;changed field indicates which attributes of the device
specified in
<em class="parameter"><code>changes</code></em>-&gt;<em class="structfield"><code>device</code></em>
have changed. The parameters describing the changes are contained in the other
fields of
<em class="parameter"><code>changes</code></em>.
<code class="function">XkbGetDeviceInfoChanges</code>
uses that information to call XkbGetDeviceInfo to obtain the current status of
those attributes that have changed. It then updates the local description of
the device in
<em class="parameter"><code>device_info</code></em>
with the new information.
</p><p>
To update the server’s description of a device with the changes noted in an
XkbDeviceChangesRec, use XkbChangeDeviceInfo.
</p><a id="idm17957" class="indexterm"></a><div class="funcsynopsis"><a id="XkbChangeDeviceInfo"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbChangeDeviceInfo</strong>(</code>Display *<var class="pdparam">dpy</var>, XkbDeviceInfoPtr <var class="pdparam">device_info</var>, XkbDeviceChangesPtr <var class="pdparam">changes</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>dpy</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>device_info</code></em>
    </span></p></td><td><p>
        local copy of device state and configuration
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>changes</code></em>
    </span></p></td><td><p>
        note specifying changes in <em class="parameter"><code>device_info</code></em>
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbChangeDeviceInfo</code>
updates the server’s description of the device specified in
<em class="parameter"><code>device_info</code></em>-&gt;<em class="structfield"><code>device_spec</code></em>
with the changes specified in
<em class="parameter"><code>changes</code></em>
and contained in
<em class="parameter"><code>device_info</code></em>.
The update is made by an XkbSetDeviceInfo request.
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="Debugging_Aids"></a>Chapter 22. Debugging Aids</h1></div></div></div><p>
The debugging aids are intended for use primarily by Xkb implementors and are
optional in any implementation.
</p><p>
There are two bitmasks that may be used to control debugging. One bitmask
controls the output of debugging information, and the other controls behavior.
Both bitmasks are initially all zeros.
</p><p>
To change the values of any of the debug controls, use
<code class="function">XkbSetDebuggingFlags</code>.
</p><a id="idm17999" class="indexterm"></a><div class="funcsynopsis"><a id="XkbSetDebuggingFlags"></a><p><code class="funcdef">Bool <strong class="fsfunc">XkbSetDebuggingFlags</strong>(</code>Display *<var class="pdparam">display</var>, unsigned int <var class="pdparam">mask</var>, unsigned int <var class="pdparam">flags</var>, char *<var class="pdparam">msg</var>, unsigned int <var class="pdparam">ctrls_mask</var>, unsigned int <var class="pdparam">ctrls</var>, unsigned int *<var class="pdparam">ret_flags</var>, unsigned int *<var class="pdparam">ret_ctrls</var><code>)</code>;</p></div><div class="variablelist"><table border="0" class="variablelist"><colgroup><col align="left" valign="top" /><col /></colgroup><tbody><tr><td><p><span class="term">
      <em class="parameter"><code>display</code></em>
    </span></p></td><td><p>
        connection to X server
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>mask</code></em>
    </span></p></td><td><p>
        mask selecting debug output flags to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>flags</code></em>
    </span></p></td><td><p>
        values for debug output flags selected by <em class="parameter"><code>mask</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>msg</code></em>
    </span></p></td><td><p>
        message to print right now
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls_mask</code></em>
    </span></p></td><td><p>
        mask selecting debug controls to change
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ctrls</code></em>
    </span></p></td><td><p>
        values for debug controls selected by <em class="parameter"><code>ctrls_mask</code></em>
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ret_flags</code></em>
    </span></p></td><td><p>
        resulting state of all debug output flags
      </p></td></tr><tr><td><p><span class="term">
      <em class="parameter"><code>ret_ctrls</code></em>
    </span></p></td><td><p>
        resulting state of all debug controls
      </p></td></tr></tbody></table></div><p>
<code class="function">XkbSetDebuggingFlags</code>
modifies the debug output flags as specified by
<em class="parameter"><code>mask</code></em>
and
<em class="parameter"><code>flags</code></em>,
modifies the debug controls flags as specified by
<em class="parameter"><code>ctrls_mask</code></em>
and
<em class="parameter"><code>ctrls</code></em>,
prints the message
<em class="parameter"><code>msg</code></em>,
and backfills
<em class="parameter"><code>ret_flags</code></em>
and
<em class="parameter"><code>ret_ctrls</code></em>
with the resulting debug output and debug controls flags.
</p><p>
When bits are set in the debug output masks,
<em class="parameter"><code>mask</code></em>
and
<em class="parameter"><code>flags</code></em>,
Xkb prints debug information corresponding to each bit at appropriate points
during its processing. The device to which the output is written is
implementation-dependent, but is normally the same device to which X server
error messages are directed; thus the bits that can be set in
<em class="parameter"><code>mask</code></em>
and
<em class="parameter"><code>flags</code></em>
is implementation-specific. To turn on a debug output selection, set the bit
for the output in the
<em class="parameter"><code>mask</code></em>
parameter and set the corresponding bit in the
<em class="parameter"><code>flags</code></em>
parameter. To turn off event selection for an event, set the bit for the
output in the
<em class="parameter"><code>mask</code></em>
parameter and do not set the corresponding bit in the
<em class="parameter"><code>flags</code></em>
parameter.
</p><p>
When bits are set in the debug controls masks,
<em class="parameter"><code>ctrls_mask</code></em>
and
<em class="parameter"><code>ctrls</code></em>,
Xkb modifies its behavior according to each controls bit.
<em class="parameter"><code>ctrls_mask</code></em>
and
<em class="parameter"><code>ctrls</code></em>
are related in the same way that
<em class="parameter"><code>mask</code></em>
and
<em class="parameter"><code>flags</code></em>
are. The valid controls bits are defined in
<a class="link" href="#table22.1" title="Table 22.1. Debug Control Masks">Table 22.1</a>.
</p><div class="table"><a id="table22.1"></a><p class="title"><strong>Table 22.1. Debug Control Masks</strong></p><div class="table-contents"><table class="table" summary="Debug Control Masks" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /></colgroup><thead><tr><th align="left">Debug Control Mask</th><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><span class="symbol">XkbDF_DisableLocks</span></td><td align="left">(1 &lt;&lt; 0)</td><td align="left">Disable actions that lock modifiers</td></tr></tbody></table></div></div><br class="table-break" /><p>
<code class="function">XkbSetDebuggingFlags</code>
returns
<span class="symbol">True</span>
if successful and
<span class="symbol">False</span>
otherwise. The only protocol error it may generate is
<span class="errorname">BadAlloc</span>,
if for some reason it is unable to allocate storage.
</p><p>
<code class="function">XkbSetDebuggingFlags</code>
is intended for developer use and may be disabled in production X servers. If
it is disabled,
<code class="function">XkbSetDebuggingFlags</code>
has no effect and does not generate any protocol errors.
</p><p>
The message in
<em class="parameter"><code>msg</code></em>
is written immediately. The device to which it is written is implementation
dependent but is normally the same device where X server error messages are
directed.
</p></div><div class="glossary"><div class="titlepage"><div><div><h1 class="title"><a id="glossary"></a>Glossary</h1></div></div></div><dl><dt><span class="glossterm">Allocator</span></dt><dd class="glossdef"><p>
Xkb provides functions, known as allocators, to create and initialize Xkb data
structures.
    </p></dd><dt><span class="glossterm">Audible Bell</span></dt><dd class="glossdef"><p>
An audible bell is the sound generated by whatever bell is associated with the
keyboard or input extension device, as opposed to any other audible sound
generated elsewhere in the system.
    </p></dd><dt><span class="glossterm">Autoreset Controls</span></dt><dd class="glossdef"><p>
The autoreset controls configure the boolean controls to automatically be
enabled or disabled at the time a program exits.
    </p></dd><dt><span class="glossterm">Base Group</span></dt><dd class="glossdef"><p>
The group in effect as a result of all actions other than a previous lock or
latch request; the base group is transient. For example, the user pressing and
holding a group shift key that shifts to Group2 would result in the base group
being group 2 at that point in time. Initially, base group is always Group1.
    </p></dd><dt><span class="glossterm">Base Modifiers</span></dt><dd class="glossdef"><p>
Modifiers that are turned on as a result of some actions other than previous
lock or latch requests; base modifiers are transient. For example, the user
pressing and holding a key bound to the Shift modifier would result in Shift
being a base modifier at that point in time.
    </p></dd><dt><span class="glossterm">Base Event Code</span></dt><dd class="glossdef"><p>
A number assigned by the X server at run time that is assigned to the extension
to identify events from that extension.
    </p></dd><dt><span class="glossterm">Base State</span></dt><dd class="glossdef"><p>
The base group and base modifiers represent keys that are physically or
logically down; these constitute the base state.
    </p></dd><dt><span class="glossterm">Boolean Controls</span></dt><dd class="glossdef"><p>
Global keyboard controls that may be selectively enabled and disabled under
program control and that may be automatically set to an on or off condition
upon client program exit.
    </p></dd><dt><span class="glossterm">Canonical Key Types</span></dt><dd class="glossdef"><p>
The canonical key types are predefined key types that describe the types of
keys available on most keyboards. The definitions for the canonical key types
are held in the first
<span class="symbol">XkbNumRequiredTypes</span>
entries of the
<em class="structfield"><code>types</code></em>
field of the client map and are indexed using the following constants:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="symbol">XkbOneLevelIndex</span>
        </p></li><li class="listitem"><p>
<span class="symbol">XkbTwoLevelIndex</span>
        </p></li><li class="listitem"><p>
<span class="symbol">XkbAlphabeticIndex</span>
        </p></li><li class="listitem"><p>
<span class="symbol">XkbKeypadIndex</span>
        </p></li></ul></div></dd><dt><span class="glossterm">Client Map</span></dt><dd class="glossdef"><p>
The key mapping information needed to convert arbitrary keycodes to symbols.
    </p></dd><dt><span class="glossterm">Compat Name</span></dt><dd class="glossdef"><p>
The
<span class="emphasis"><em>compat</em></span>
name is a string that provides some information about the rules used to bind
actions to keys that are changed using core protocol requests.
    </p></dd><dt><span class="glossterm">Compatibility State</span></dt><dd class="glossdef"><p>
When an Xkb-extended X server connects to an Xkb-unaware client, the
compatibility state remaps the keyboard group into a core modifier whenever
possible.
    </p></dd><dt><span class="glossterm">Compatibility Grab State</span></dt><dd class="glossdef"><p>
The grab state that results from applying the compatibility map to the Xkb grab
state.
    </p></dd><dt><span class="glossterm">Compatibility Map</span></dt><dd class="glossdef"><p>
The definition of how to map core protocol keyboard state to Xkb keyboard state.
    </p></dd><dt><span class="glossterm">Component Expression</span></dt><dd class="glossdef"><p>
An expression used to describe server keyboard database components to be
loaded. It describes the order in which the components should be loaded and the
rules by which duplicate attributes should be resolved.
    </p></dd><dt><span class="glossterm">Compose Processing</span></dt><dd class="glossdef"><p>
The process of mapping a series of keysyms to a string is known as compose
processing.
    </p></dd><dt><span class="glossterm">Consumed Modifier</span></dt><dd class="glossdef"><p>
Xkb normally consumes modifiers in determining the appropriate symbol for an
event, that is, the modifiers are not considered during any of the later stages
of event processing. For those rare occasions when a modifier
<span class="emphasis"><em>should</em></span>
be considered despite having been used to look up a symbol, key types include
an optional
<em class="structfield"><code>preserve</code></em>
field.
    </p></dd><dt><span class="glossterm">Core Event</span></dt><dd class="glossdef"><p>
An event created from the core X server.
    </p></dd><dt><span class="glossterm">Detectable Auto-Repeat</span></dt><dd class="glossdef"><p>
Detectable auto-repeat allows a client to detect an auto-repeating key. If a
client requests and the server supports detectable auto-repeat, Xkb generates
<span class="symbol">KeyRelease</span>
events only when the key is physically released. Thus the client receives a
number of
<span class="symbol">KeyPress</span>
events for that key without intervening
<span class="symbol">KeyRelease</span>
events until the key is finally released, when a
<span class="symbol">KeyRelease</span>
event is received.
    </p></dd><dt><span class="glossterm">Effective Group</span></dt><dd class="glossdef"><p>
The effective group is the arithmetic sum of the locked, latched, and base
groups. The effective keyboard group is always brought back into range
depending on the value of the
<span class="emphasis"><em>GroupsWrap</em></span>
control for the keyboard. If an event occurs with an effective group that is
legal for the keyboard as a whole, but not for the key in question, the group
<span class="emphasis"><em>for that event only</em></span>
is normalized using the algorithm specified by the
<em class="structfield"><code>group_info</code></em>
member of the key symbol map
(<span class="structname">XkbSymMapRec</span>).

    </p></dd><dt><span class="glossterm">Effective Mask</span></dt><dd class="glossdef"><p>
An Xkb modifier definition consists of a set of bit masks corresponding to the
eight real modifiers; a similar set of bitmasks corresponding to the 16 named
virtual modifiers; and an effective mask. The effective mask represents the set
of all real modifiers that can logically be set either by setting any of the
real modifiers or by setting any of the virtual modifiers in the definition.
    </p></dd><dt><span class="glossterm">Effective Modifier</span></dt><dd class="glossdef"><p>
The effective modifiers are the bitwise union of the base, latched and locked
modifiers.
    </p></dd><dt><span class="glossterm">Extension Device</span></dt><dd class="glossdef"><p>
Any keyboard or other input device recognized by the X input extension.
    </p></dd><dt><span class="glossterm">Global Keyboard Controls</span></dt><dd class="glossdef"><p>
Controls that affect the way Xkb generates key events. The controls affect all
keys, as opposed to per-key controls that are for a single key. Global controls
include
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>RepeatKeys Control</p></li><li class="listitem"><p>DetectableAuto-repeat</p></li><li class="listitem"><p>SlowKeys</p></li><li class="listitem"><p>BounceKeys</p></li><li class="listitem"><p>StickyKeys</p></li><li class="listitem"><p>MouseKeys</p></li><li class="listitem"><p>MouseKeysAccel</p></li><li class="listitem"><p>AccessXKeys</p></li><li class="listitem"><p>AccessXTimeout</p></li><li class="listitem"><p>AccessXFeedback</p></li><li class="listitem"><p>Overlay1</p></li><li class="listitem"><p>Overlay2</p></li><li class="listitem"><p>EnabledControls</p></li></ul></div></dd><dt><span class="glossterm">Grab State</span></dt><dd class="glossdef"><p>
The grab state is the state used when matching events to passive grabs. It
consists of the grab group and the grab modifiers.
    </p></dd><dt><span class="glossterm">Group</span></dt><dd class="glossdef"><p>See Keysym Group</p></dd><dt><span class="glossterm">Group Index</span></dt><dd class="glossdef"><p>
A number used as the internal representation for a group number. Group1 through
Group 4 have indices of 0 through 3.
    </p></dd><dt><span class="glossterm">Groups Wrap Control</span></dt><dd class="glossdef"><p>
If a group index exceeds the maximum number of groups permitted for the
specified keyboard, it is wrapped or truncated back into range as specified by
the global <span class="emphasis"><em>GroupsWrap</em></span> control.
<span class="emphasis"><em>GroupsWrap</em></span> can have the following values:
      </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="emphasis"><em>WrapIntoRange</em></span></td></tr><tr><td><span class="emphasis"><em>ClampIntoRange</em></span></td></tr><tr><td><span class="emphasis"><em>RedirectIntoRange</em></span></td></tr></table><p>
    </p></dd><dt><span class="glossterm">Key Type</span></dt><dd class="glossdef"><p>
An attribute of a key that identifies which modifiers affect the shift level of
a key and the number of groups on the key.
    </p></dd><dt><span class="glossterm">Key Width</span></dt><dd class="glossdef"><p>
The maximum number of shift levels in any group for the key type associated
with a key.
    </p></dd><dt><span class="glossterm">Keysym Group</span></dt><dd class="glossdef"><p>
A keysym group is a logical state of the keyboard providing access to a
collection of characters. A group usually contains a set of characters that
logically belong together and that may be arranged on several shift levels
within that group. For example, Group1 could be the English alphabet, and
Group2 could be Greek. Xkb supports up to four different groups for an input
device or keyboard. Groups are in the range 1–4 (Group1–Group4),
and are often referred to as G1–G4 and indexed as 0–3.
    </p></dd><dt><span class="glossterm">Indicator</span></dt><dd class="glossdef"><p>
An indicator is a feedback mechanism such as an LED on an input device. Using
Xkb, a client application can determine the names of the various indicators,
determine and control the way that the individual indicators should be updated
to reflect keyboard changes, and determine which of the 32 keyboard indicators
reported by the protocol are actually present on the keyboard.
    </p></dd><dt><span class="glossterm">Indicator Feedback</span></dt><dd class="glossdef"><p>
An indicator feedback describes the state of a bank of up to 32 lights. It has
a mask where each bit corresponds to a light and an associated value mask that
specifies which lights are on or off.
    </p></dd><dt><span class="glossterm">Indicator Map</span></dt><dd class="glossdef"><p>
An indicator has its own set of attributes that specify whether clients can
explicitly set its state and whether it tracks the keyboard state. The
indicator map is the collection of these attributes for each indicator and is
held in the
<em class="structfield"><code>maps</code></em>
array, which is an array of
<span class="structname">XkbIndicatorRec</span>
structures.
    </p></dd><dt><span class="glossterm">Input Extension</span></dt><dd class="glossdef"><p>
An extension to the core X protocol that allows an X server to support multiple
keyboards, as well as other input devices, in addition to the core X keyboard
and pointer. Other types of devices supported by the input extension include,
but are not limited to: mice, tablets, touchscreens, barcode readers, button
boxes, trackballs, identifier devices, data gloves, and eye trackers.
    </p></dd><dt><span class="glossterm">Key Action</span></dt><dd class="glossdef"><p>
A key action consists of an operator and some optional data. Once the server
has applied the global controls and per-key behavior and has decided to process
a key event, it applies key actions to determine the effects of the key on the
internal state of the server. Xkb supports actions that do the following:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
Change base, latched, or locked modifiers or group
      </p></li><li class="listitem"><p>
Move the core pointer or simulate core pointer button events
      </p></li><li class="listitem"><p>
Change most aspects of keyboard behavior
      </p></li><li class="listitem"><p>
Terminate or suspend the server
      </p></li><li class="listitem"><p>
Send a message to interested clients
      </p></li><li class="listitem"><p>
Simulate events on other keys
      </p></li></ul></div></dd><dt><span class="glossterm">Key Alias</span></dt><dd class="glossdef"><p>
A key alias is a symbolic name for a specific physical key. Key aliases allow
the keyboard layout designer to assign multiple key names to a single key. This
allows the keyboard layout designer to refer to keys using either their
position or their <span class="quote">“<span class="quote">function</span>”</span>.
Key aliases can be specified both in the symbolic
names component and in the keyboard geometry. Both sets of aliases are always
valid, but key alias definitions in the keyboard geometry have priority; if
both symbolic names and geometry include aliases, you should consider the
definitions from the geometry before considering the definitions from the
symbolic names section.
    </p></dd><dt><span class="glossterm">Key Behavior</span></dt><dd class="glossdef"><p>
The
<em class="structfield"><code>behaviors</code></em>
field of the server map is an array of
<span class="structname">XkbBehavior</span>,
indexed by keycode, and contains the behavior for each key. The X server uses
key behavior to determine whether to process or filter out any given key event;
key behavior is independent of keyboard modifier or group state. Each key has
exactly one behavior.
    </p><p>Key behaviors include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>XkbKB_Default</p></li><li class="listitem"><p>XkbKB_Lock</p></li><li class="listitem"><p>XkbKB_RadioGroup</p></li><li class="listitem"><p>XkbKB_Overlay1</p></li><li class="listitem"><p>XkbKB_Overlay2</p></li></ul></div></dd><dt><span class="glossterm">Key Symbol Map</span></dt><dd class="glossdef"><p>
A key symbol map describes the symbols bound to a key and the rules to be used
to interpret those symbols. It is an array of
<span class="structname">XkbSymMapRec</span>
structures indexed by keycode.
    </p></dd><dt><span class="glossterm">Key Type</span></dt><dd class="glossdef"><p>
Key types are used to determine the shift level of a key given the current
state of the keyboard. There is one key type for each group for a key. Key
types are defined using the
<span class="structname">XkbKeyTypeRec</span>
and
<span class="structname">XkbKTMapEntryRec</span>
structures. Xkb allows up to
<span class="symbol">XkbMaxKeyTypes</span>
(255) key types to be defined, but requires at least
<span class="symbol">XkbNumRequiredTypes</span>
(4) predefined types to be in a key map.
    </p></dd><dt><span class="glossterm">Keyboard Bells</span></dt><dd class="glossdef"><p>
The sound the default bell makes when rung is the system bell or the default
keyboard bell. Some input devices may have more than one bell, identified by
<em class="structfield"><code>bell_class</code></em> and <em class="structfield"><code>bell_id</code></em>.
    </p></dd><dt><span class="glossterm">Keyboard Components</span></dt><dd class="glossdef"><p>
There are five types of components stored in the X server database of keyboard
components. They correspond to the
<em class="structfield"><code>&gt;symbols</code></em>,
<em class="structfield"><code>geometry</code></em>,
<em class="structfield"><code>keycodes</code></em>,
<em class="structfield"><code>compat</code></em>,
and
<em class="structfield"><code>types</code></em>
symbolic names associated with a keyboard.
    </p></dd><dt><span class="glossterm">Keyboard Feedback</span></dt><dd class="glossdef"><p>
A keyboard feedback includes the following:
      </p><table border="0" summary="Simple list" class="simplelist"><tr><td>Keyclick volume</td></tr><tr><td>Bell volume</td></tr><tr><td>Bell pitch</td></tr><tr><td>Bell duration</td></tr><tr><td>Global auto-repeat</td></tr><tr><td>Per key auto-repeat</td></tr><tr><td>32 LEDs</td></tr></table><p>
    </p></dd><dt><span class="glossterm">Key Width, Key Type Width</span></dt><dd class="glossdef"><p>
The maximum number of shift levels for a type is referred to as the width of a
key type.
    </p></dd><dt><span class="glossterm">Keyboard Geometry</span></dt><dd class="glossdef"><p>
Keyboard geometry describes the physical appearance of the keyboard, including
the shape, location, and color of all keyboard keys or other visible keyboard
components such as indicators and is stored in a
<span class="structname">XkbGeometryRec</span>
structure. The information contained in a keyboard geometry is sufficient to
allow a client program to draw an accurate two-dimensional image of the
keyboard.
    </p></dd><dt><span class="glossterm">Keyboard Geometry Name</span></dt><dd class="glossdef"><p>
The keyboard geometry name describes the physical location, size, and shape of
the various keys on the keyboard and is part of the
<span class="structname">XkbNamesRec</span>
structure.
    </p></dd><dt><span class="glossterm">Keyboard State</span></dt><dd class="glossdef"><p>
Keyboard state encompasses all of the transitory information necessary to map a
physical key press or release to an appropriate event.
    </p></dd><dt><span class="glossterm">Keycode</span></dt><dd class="glossdef"><p>
A numeric value returned to the X server when a key on a keyboard is pressed or
released, indicating which key is being modulated. Keycode numbers are in the
range 1 &lt;= keycode &lt;= max, where max is the number of physical keys on
the device.
    </p></dd><dt><span class="glossterm">Keycode Name</span></dt><dd class="glossdef"><p>
The keycode name describes the range and meaning of the keycodes returned by
the keyboard and is part of the
<span class="structname">XkbNamesRec</span>
structure.
    </p></dd><dt><span class="glossterm">Latched Group</span></dt><dd class="glossdef"><p>
A latched group is a group index that is combined with the base and locked
group to form the effective group. It applies only to the next key event that
does not change the keyboard state. The latched group can be changed by
keyboard activity or via Xkb extension library functions.
    </p></dd><dt><span class="glossterm">Latched Modifier</span></dt><dd class="glossdef"><p>
Latched modifiers are the set of modifiers that are combined with the base
modifiers and the locked modifiers to form the effective modifiers. It applies
only to the next key event that does not change the keyboard state.
    </p></dd><dt><span class="glossterm">LED</span></dt><dd class="glossdef"><p>
A light emitting diode. However, for the purposes of the X keyboard extension
specification, a LED is any form of visual two-state indicator that is either
on or off.
    </p></dd><dt><span class="glossterm">Locked Group</span></dt><dd class="glossdef"><p>
A locked group is a group index that is combined with the base and latched
group to form the effective group. When a group is locked, it supersedes any
previous locked group and remains the locked group for all future key events,
until a new group is locked. The locked group can be changed by keyboard
activity or via Xkb extension library functions.
    </p></dd><dt><span class="glossterm">Locked Modifiers</span></dt><dd class="glossdef"><p>
Locked modifiers are the set of modifiers that are combined with the base
modifiers and the latched modifiers to form the effective modifiers. A locked
modifier applies to all future key events until it is explicitly unlocked.
    </p></dd><dt><span class="glossterm">Lookup State      </span></dt><dd class="glossdef"><p>
The lookup state is composed of the lookup group and the lookup modifiers, and
it is the state an Xkb-capable or Xkb-aware client should use to map a keycode
to a keysym.
    </p></dd><dt><span class="glossterm">Modifier</span></dt><dd class="glossdef"><p>
A modifier is a logical condition that is either set or unset. The modifiers
control the Shift Level selected when a key event occurs. Xkb supports the core
protocol eight modifiers
(<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>,
<span class="symbol">Control</span>,
and
<span class="symbol">Mod1</span>
through
<span class="symbol">Mod5</span>),
called the
<span class="emphasis"><em>real</em></span>
modifiers. In addition, Xkb extends modifier flexibility by providing a set of
sixteen named virtual modifiers, each of which can be bound to any set of the
eight real modifiers.
    </p></dd><dt><span class="glossterm">Modifier Key</span></dt><dd class="glossdef"><p>
A modifier key is a key whose operation has no immediate effect, but that, for
as long as it is held down, modifies the effect of other keys. A modifier key
may be, for example, a shift key or a control key.
    </p></dd><dt><span class="glossterm">Modifier Definition</span></dt><dd class="glossdef"><p>
An Xkb modifier definition, held in an
<span class="structname">XkbModsRec</span>,
consists of a set of real modifiers, a set of virtual modifiers, and an
effective mask. The mask is the union of the real modifiers and the set of real
modifiers to which the virtual modifiers map; the mask cannot be explicitly
changed.
    </p></dd><dt><span class="glossterm">Nonkeyboard Extension Device      </span></dt><dd class="glossdef"><p>
An input extension device that is not a keyboard. Other types of devices
supported by the input extension include, but are not limited to: mice,
tablets, touchscreens, barcode readers, button boxes, trackballs, identifier
devices, data gloves, and eye trackers.
    </p></dd><dt><span class="glossterm">Outlines</span></dt><dd class="glossdef"><p>
An outline is a list of one or more points that describes a single closed
polygon, used in the geometry specification for a keyboard.
    </p></dd><dt><span class="glossterm">Physical Indicator Mask</span></dt><dd class="glossdef"><p>
The physical indicator mask is a field in the
<span class="structname">XkbIndicatorRec</span>
that indicates which indicators are bound to physical LEDs on the keyboard; if
a bit is set in
<em class="structfield"><code>phys_indicators</code></em>,
then the associated indicator has a physical LED associated with it. This
field is necessary because some indicators may not have corresponding physical
LEDs on the keyboard.
    </p></dd><dt><span class="glossterm">Physical Symbol Keyboard Name</span></dt><dd class="glossdef"><p>
The
<em class="structfield"><code>symbols</code></em>
keyboard name identifies the symbols logically bound to the keys. The symbols
name is a human or application-readable description of the intended locale or
usage of the keyboard with these symbols. The
<em class="structfield"><code>phys_symbols</code></em>
keyboard name, on the other hand, identifies the symbols actually engraved on
the keyboard.
    </p></dd><dt><span class="glossterm">Preserved Modifier</span></dt><dd class="glossdef"><p>
Xkb normally consumes modifiers in determining the appropriate symbol for an
event, that is, the modifiers are not considered during any of the later stages
of event processing. For those rare occasions when a modifier
<span class="emphasis"><em>should</em></span>
be considered despite having been used to look up a symbol, key types include
an optional
<em class="structfield"><code>preserve</code></em>
field. If a modifier is present in the
<em class="structfield"><code>preserve</code></em>
list, it is a preserved modifier.
    </p></dd><dt><span class="glossterm">Radio Group</span></dt><dd class="glossdef"><p>
A radio group is a set of keys whose behavior simulates a set of radio buttons.
Once a key in a radio group is pressed, it stays logically depressed until
another key in the group is pressed, at which point the previously depressed
key is logically released. Consequently, at most one key in a radio group can
be logically depressed at one time.
    </p></dd><dt><span class="glossterm">Real Modifier</span></dt><dd class="glossdef"><p>
Xkb supports the eight core protocol modifiers
(<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>,
<span class="symbol">Control</span>,
and
<span class="symbol">Mod1</span>
through
<span class="symbol">Mod5</span>);
these are called the
<span class="emphasis"><em>real</em></span>
modifiers, as opposed to the set of sixteen named virtual modifiers that can
be bound to any set of the eight real modifiers.
    </p></dd><dt><span class="glossterm">Server Internal Modifiers</span></dt><dd class="glossdef"><p>
Modifiers that the server uses to determine the appropriate symbol for an
event; internal modifiers are normally consumed by the server.
    </p></dd><dt><span class="glossterm">Shift Level</span></dt><dd class="glossdef"><p>
One of several states (normally 2 or 3) governing which graphic character is
produced when a key is actuated.
    </p></dd><dt><span class="glossterm">Symbol Keyboard Name</span></dt><dd class="glossdef"><p>
The
<em class="structfield"><code>symbols</code></em>
keyboard name identifies the symbols logically bound to the keys. The symbols
name is a human or application-readable description of the intended locale or
usage of the keyboard with these symbols. The
<em class="structfield"><code>phys_symbols</code></em>
keyboard name, on the other hand, identifies the symbols actually engraved on
the keyboard.
    </p></dd><dt><span class="glossterm">Symbolic Name</span></dt><dd class="glossdef"><p>
Xkb supports symbolic names for most components of the keyboard extension. Most
of these symbolic names are grouped into the
<em class="structfield"><code>names</code></em>
component of the keyboard description.
    </p></dd><dt><span class="glossterm">State Field</span></dt><dd class="glossdef"><p>
The portion of a client-side core protocol event that holds the modifier,
group, and button state information pertaining to the event.
    </p></dd><dt><span class="glossterm">Types Name</span></dt><dd class="glossdef"><p>
The
<span class="emphasis"><em>types</em></span>
name provides some information about the set of key types that can be
associated with the keyboard. In addition, each key type can have a name, and
each shift level of a type can have a name.
    </p></dd><dt><span class="glossterm">Valuator</span></dt><dd class="glossdef"><p>
A valuator reports a range of values for some entity, like a mouse axis, a
slider, or a dial.
    </p></dd><dt><span class="glossterm">Virtual Modifier</span></dt><dd class="glossdef"><p>
Xkb provides a set of sixteen named virtual modifiers that can be bound to any
set of the eight real modifiers. Each virtual modifier can be bound to any set
of the real modifiers
(<span class="symbol">Shift</span>,
<span class="symbol">Lock</span>,
<span class="symbol">Control</span>,
and
<span class="symbol">Mod1</span>
–
<span class="symbol">Mod5</span>).

    </p></dd><dt><span class="glossterm">Virtual Modifier Mapping</span></dt><dd class="glossdef"><p>
Xkb maintains a virtual modifier mapping, which lists the virtual modifiers
associated with each key.
    </p></dd><dt><span class="glossterm">Xkb-aware Client</span></dt><dd class="glossdef"><p>
A client application that initializes Xkb extension and is consequently bound
to an Xlib that includes the Xkb extension.
    </p></dd><dt><span class="glossterm">Xkb-capable Client</span></dt><dd class="glossdef"><p>
A client application that makes no Xkb extension Xlib calls but is bound to an
Xlib that includes the Xkb extension.
    </p></dd><dt><span class="glossterm">Xkb-unaware Client</span></dt><dd class="glossdef"><p>
A client application that makes no Xkb extension Xlib calls and is bound to an
Xlib that does not include the Xkb extension.
    </p></dd></dl></div><div class="index"><div class="titlepage"><div><div><h1 class="title"><a id="index"></a>Index</h1></div></div></div><div xmlns:xlink="http://www.w3.org/1999/xlink" class="index"><div class="indexdiv"><h3>A</h3><dl><dt id="ientry-idm12423">action modifiers, <a class="indexterm" href="#Actions_for_Changing_Modifiers_State">Actions for Changing Modifiers’ State</a></dt><dt id="ientry-idm3221">audible bell, <a class="indexterm" href="#Bells">Bells</a></dt><dt id="ientry-idm4177">auto-repeat</dt><dd><dl><dt>controls, <a class="indexterm" href="#Controls_for_Repeat_Key_Behavior">Controls for Repeat Key Behavior</a></dt><dt>detectable, <a class="indexterm" href="#The_DetectableAutorepeat_Control">The DetectableAutorepeat Control</a></dt></dl></dd><dt id="ientry-idm4048">auto-reset mask, <a class="indexterm" href="#The_AutoReset_Control">The AutoReset Control</a></dt></dl></div><div class="indexdiv"><h3>B</h3><dl><dt id="ientry-idm313">BadAccess, <a class="indexterm" href="#Initializing_the_Keyboard_Extension">Initializing the Keyboard Extension</a></dt><dt id="ientry-idm573">BadKeyboard, <a class="indexterm" href="#BadKeyboard">Protocol Errors</a></dt><dt id="ientry-idm1185">base group, <a class="indexterm" href="#base_group">Keyboard State Description</a></dt><dt id="ientry-idm1191">base modifiers, <a class="indexterm" href="#base_group">Keyboard State Description</a></dt><dt id="ientry-idm3217">bell, <a class="indexterm" href="#Bells">Bells</a></dt><dd><dl><dt>audible, <a class="indexterm" href="#Bells">Bells</a></dt></dl></dd><dt id="ientry-idm3846">boolean controls, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt></dl></div><div class="indexdiv"><h3>C</h3><dl><dt id="ientry-idm701">changes data structures, <a class="indexterm" href="#Making_Changes_to_the_Servers_Keyboard_Description">Making Changes to the Server’s Keyboard Description</a></dt><dt id="ientry-idm9709">client map, <a class="indexterm" href="#Xkb_Keyboard_Mapping">Xkb Keyboard Mapping</a>, <a class="indexterm" href="#Xkb_Client_Keyboard_Mapping">Xkb Client Keyboard Mapping</a></dt><dt id="ientry-idm6924">compose processing, <a class="indexterm" href="#Controls_Affecting_Compose_Processing">Controls Affecting Compose Processing</a></dt><dt id="ientry-idm3835">controls, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt><dd><dl><dt>boolean, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt><dt>library, <a class="indexterm" href="#X_Library_Controls">X Library Controls</a></dt><dt>non-boolean, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt><dt>server, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>D</h3><dl><dt id="ientry-idm4318">detectable auto-repeat, <a class="indexterm" href="#The_DetectableAutorepeat_Control">The DetectableAutorepeat Control</a></dt></dl></div><div class="indexdiv"><h3>E</h3><dl><dt id="ientry-idm1207">effective group, <a class="indexterm" href="#effective_group">Keyboard State Description</a></dt><dt id="ientry-idm1200">effective modifiers, <a class="indexterm" href="#effective_modifiers">Keyboard State Description</a></dt><dt id="ientry-idm186">errors, <a class="indexterm" href="#Error_Indications">Error Indications</a>, <a class="indexterm" href="#Protocol_Errors">Protocol Errors</a></dt><dd><dl><dt>BadAccess, <a class="indexterm" href="#Initializing_the_Keyboard_Extension">Initializing the Keyboard Extension</a></dt><dt>BadKeyboard, <a class="indexterm" href="#BadKeyboard">Protocol Errors</a></dt></dl></dd><dt id="ientry-idm728">events, <a class="indexterm" href="#Xkb_Events">Xkb Events</a></dt><dd><dl><dt>MappingNotify, <a class="indexterm" href="#IgnoreNewKeyboards">IgnoreNewKeyboards</a>, <a class="indexterm" href="#Effects_of_Xkb_on_MappingNotify_Events">Effects of Xkb on MappingNotify Events</a></dt><dt>mask, <a class="indexterm" href="#Selecting_Xkb_Events">Selecting Xkb Events</a></dt><dt>NewKeyboardNotify, <a class="indexterm" href="#IgnoreNewKeyboards">IgnoreNewKeyboards</a></dt><dt>XkbAccessXNotify, <a class="indexterm" href="#AccessXNotify_Events">AccessXNotify Events</a></dt><dt>XkbActionMessage, <a class="indexterm" href="#Detecting_Key_Action_Messages">Detecting Key Action Messages</a></dt><dt>XkbAnyEvent, <a class="indexterm" href="#Xkb_Event_Data_Structures">Xkb Event Data Structures</a></dt><dt>XkbCompatMapNotify, <a class="indexterm" href="#Tracking_Changes_to_the_Compatibility_Map">Tracking Changes to the Compatibility Map</a></dt><dt>XkbControlsNotify, <a class="indexterm" href="#Tracking_Changes_to_Keyboard_Controls">Tracking Changes to Keyboard Controls</a></dt><dt>XkbEvent, <a class="indexterm" href="#Unified_Xkb_Event_Type">Unified Xkb Event Type</a></dt><dt>XkbExtensionDeviceNotify, <a class="indexterm" href="#XkbExtensionDeviceNotify_Event">XkbExtensionDeviceNotify Event</a></dt><dt>XkbIndicatorMapNotify, <a class="indexterm" href="#Tracking_Changes_to_Indicator_State_or_Map">Tracking Changes to Indicator State or Map</a></dt><dt>XkbIndicatorStateNotify, <a class="indexterm" href="#Tracking_Changes_to_Indicator_State_or_Map">Tracking Changes to Indicator State or Map</a></dt><dt>XkbMapNotify, <a class="indexterm" href="#Tracking_Changes_to_Map_Components">Tracking Changes to Map Components</a></dt><dt>XkbNamesNotify, <a class="indexterm" href="#Tracking_Name_Changes">Tracking Name Changes</a></dt><dt>XkbNewKeyboardNotify, <a class="indexterm" href="#Replacing_a_Keyboard_On_the_Fly">Replacing a Keyboard “On the Fly”</a></dt><dt>XkbStateNotify, <a class="indexterm" href="#Tracking_Keyboard_State">Tracking Keyboard State</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>G</h3><dl><dt id="ientry-idm1284">grab group, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt id="ientry-idm1278">grab modifiers, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt id="ientry-idm1272">grab state, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt id="ientry-idm150">group</dt><dd><dl><dt>base, <a class="indexterm" href="#base_group">Keyboard State Description</a></dt><dt>effective, <a class="indexterm" href="#effective_group">Keyboard State Description</a></dt><dt>grab, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt>ISO9995, <a class="indexterm" href="#keysym_groups">Keyboard State Description</a></dt><dt>keysym, <a class="indexterm" href="#keysym_groups">Keyboard State Description</a>, <a class="indexterm" href="#Changing_Groups">Changing Groups</a></dt><dt>lookup, <a class="indexterm" href="#lookup_state">Keyboard State Description</a></dt><dt>radio, <a class="indexterm" href="#Radio_Groups">Radio Groups</a></dt></dl></dd><dt id="ientry-idm14698">group compatibility map, <a class="indexterm" href="#Xkb_State_to_Core_Protocol_State_Transformation">Xkb State to Core Protocol State Transformation</a></dt></dl></div><div class="indexdiv"><h3>I</h3><dl><dt id="ientry-idm2168">indicators, <a class="indexterm" href="#Indicators">Indicators</a></dt></dl></div><div class="indexdiv"><h3>K</h3><dl><dt id="ientry-idm98">keyboard description, <a class="indexterm" href="#keyboard_description">Xkb Extension Components</a></dt><dt id="ientry-idm1164">keysym groups, <a class="indexterm" href="#keysym_groups">Keyboard State Description</a>, <a class="indexterm" href="#Changing_Groups">Changing Groups</a></dt></dl></div><div class="indexdiv"><h3>L</h3><dl><dt id="ientry-idm9725">level, <a class="indexterm" href="#Notation_and_Terminology">Notation and Terminology</a></dt><dt id="ientry-idm6846">library controls, <a class="indexterm" href="#X_Library_Controls">X Library Controls</a></dt><dt id="ientry-idm1249">lookup group, <a class="indexterm" href="#lookup_state">Keyboard State Description</a></dt><dt id="ientry-idm1243">lookup modifiers, <a class="indexterm" href="#lookup_state">Keyboard State Description</a></dt><dt id="ientry-idm1265">lookup state, <a class="indexterm" href="#lookup_state">Keyboard State Description</a></dt></dl></div><div class="indexdiv"><h3>M</h3><dl><dt id="ientry-idm9711">map</dt><dd><dl><dt>client, <a class="indexterm" href="#Xkb_Keyboard_Mapping">Xkb Keyboard Mapping</a>, <a class="indexterm" href="#Xkb_Client_Keyboard_Mapping">Xkb Client Keyboard Mapping</a></dt><dt>group compatibility, <a class="indexterm" href="#Xkb_State_to_Core_Protocol_State_Transformation">Xkb State to Core Protocol State Transformation</a></dt><dt>server, <a class="indexterm" href="#Xkb_Keyboard_Mapping">Xkb Keyboard Mapping</a>, <a class="indexterm" href="#Xkb_Server_Keyboard_Mapping">Xkb Server Keyboard Mapping</a></dt></dl></dd><dt id="ientry-idm871">mask</dt><dd><dl><dt>auto-reset, <a class="indexterm" href="#The_AutoReset_Control">The AutoReset Control</a></dt><dt>event, <a class="indexterm" href="#Selecting_Xkb_Events">Selecting Xkb Events</a></dt><dt>real modifiers, <a class="indexterm" href="#Changing_Modifiers">Changing Modifiers</a></dt></dl></dd><dt id="ientry-idm2016">modifier definition, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt id="ientry-idm1155">modifiers, <a class="indexterm" href="#modifiers">Keyboard State Description</a></dt><dd><dl><dt>action, <a class="indexterm" href="#Actions_for_Changing_Modifiers_State">Actions for Changing Modifiers’ State</a></dt><dt>base, <a class="indexterm" href="#base_group">Keyboard State Description</a></dt><dt>effective, <a class="indexterm" href="#effective_modifiers">Keyboard State Description</a></dt><dt>grab, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt>lookup, <a class="indexterm" href="#lookup_state">Keyboard State Description</a></dt><dt>names, <a class="indexterm" href="#Conventions">Conventions</a></dt><dt>real, <a class="indexterm" href="#Changing_Modifiers">Changing Modifiers</a>, <a class="indexterm" href="#Virtual_Modifiers">Virtual Modifiers</a></dt><dt>virtual, <a class="indexterm" href="#Virtual_Modifiers">Virtual Modifiers</a></dt><dt>virtual mapping, <a class="indexterm" href="#Virtual_Modifier_Key_Mapping">Virtual Modifier Key Mapping</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>N</h3><dl><dt id="ientry-idm3852">non-boolean controls, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt></dl></div><div class="indexdiv"><h3>R</h3><dl><dt id="ientry-idm148">radio group, <a class="indexterm" href="#Radio_Groups">Radio Groups</a></dt><dt id="ientry-idm1307">real modifiers, <a class="indexterm" href="#Changing_Modifiers">Changing Modifiers</a>, <a class="indexterm" href="#Virtual_Modifiers">Virtual Modifiers</a></dt></dl></div><div class="indexdiv"><h3>S</h3><dl><dt id="ientry-idm3837">server controls, <a class="indexterm" href="#Keyboard_Controls">Keyboard Controls</a></dt><dt id="ientry-idm9715">server map, <a class="indexterm" href="#Xkb_Keyboard_Mapping">Xkb Keyboard Mapping</a>, <a class="indexterm" href="#Xkb_Server_Keyboard_Mapping">Xkb Server Keyboard Mapping</a></dt><dt id="ientry-idm9727">shift level, <a class="indexterm" href="#Notation_and_Terminology">Notation and Terminology</a></dt><dt id="ientry-idm1267">state</dt><dd><dl><dt>grab, <a class="indexterm" href="#grab_state">Keyboard State Description</a></dt><dt>lookup, <a class="indexterm" href="#lookup_state">Keyboard State Description</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>V</h3><dl><dt id="ientry-idm13975">valuator, <a class="indexterm" href="#Actions_for_Simulating_Events_from_Device_Valuators">Actions for Simulating Events from Device Valuators</a></dt><dt id="ientry-idm2042">virtual modifier mapping, <a class="indexterm" href="#Virtual_Modifier_Key_Mapping">Virtual Modifier Key Mapping</a></dt><dt id="ientry-idm1979">virtual modifiers, <a class="indexterm" href="#Virtual_Modifiers">Virtual Modifiers</a></dt></dl></div><div class="indexdiv"><h3>X</h3><dl><dt id="ientry-idm1234">Xkb-aware client, <a class="indexterm" href="#Xkb-aware">Keyboard State Description</a></dt><dt id="ientry-idm1231">Xkb-capable client, <a class="indexterm" href="#Xkb-aware">Keyboard State Description</a></dt><dt id="ientry-idm4904">XkbAccessXNotifyEvent, <a class="indexterm" href="#AccessXNotify_Events">AccessXNotify Events</a></dt><dt id="ientry-idm12245">XkbAction, <a class="indexterm" href="#The_XkbAction_Structure">The XkbAction Structure</a></dt><dt id="ientry-idm13573">XkbActionCtrls, <a class="indexterm" href="#XkbActionCtrls">Actions for Changing Boolean Controls State</a></dt><dt id="ientry-idm13676">XkbActionMessageEvent, <a class="indexterm" href="#Detecting_Key_Action_Messages">Detecting Key Action Messages</a></dt><dt id="ientry-idm17504">XkbAddDeviceLedInfo, <a class="indexterm" href="#XkbAddDeviceLedInfo">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></dt><dt id="ientry-idm8347">XkbAddGeomColor, <a class="indexterm" href="#XkbAddGeomColor">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8567">XkbAddGeomDoodad, <a class="indexterm" href="#XkbAddGeomDoodad">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8459">XkbAddGeomKey, <a class="indexterm" href="#XkbAddGeomKey">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8312">XkbAddGeomKeyAlias, <a class="indexterm" href="#XkbAddGeomKeyAlias">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8390">XkbAddGeomOutline, <a class="indexterm" href="#XkbAddGeomOutline">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8612">XkbAddGeomOverlay, <a class="indexterm" href="#XkbAddGeomOverlay">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8690">XkbAddGeomOverlayKey, <a class="indexterm" href="#XkbAddGeomOverlayKey">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8649">XkbAddGeomOverlayRow, <a class="indexterm" href="#XkbAddGeomOverlayRow">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8275">XkbAddGeomProperty, <a class="indexterm" href="#XkbAddGeomProperty">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8537">XkbAddGeomRow, <a class="indexterm" href="#XkbAddGeomRow">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8482">XkbAddGeomSection, <a class="indexterm" href="#XkbAddGeomSection">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm8420">XkbAddGeomShape, <a class="indexterm" href="#XkbAddGeomShape">Adding Elements to a Keyboard Geometry</a></dt><dt id="ientry-idm15289">XkbAddSymInterpret, <a class="indexterm" href="#XkbAddSymInterpret">Changing the Server’s Compatibility Map</a></dt><dt id="ientry-idm10348">XkbAllocClientMap, <a class="indexterm" href="#XkbAllocClientMap">Allocating an Empty Client Map</a></dt><dt id="ientry-idm15397">XkbAllocCompatMap, <a class="indexterm" href="#XkbAllocCompatMap">Allocating and Freeing the Compatibility Map</a></dt><dt id="ientry-idm6664">XkbAllocControls, <a class="indexterm" href="#XkbAllocControls">Allocating and Freeing an XkbControlsRec</a></dt><dt id="ientry-idm17429">XkbAllocDeviceInfo, <a class="indexterm" href="#XkbAllocDeviceInfo">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></dt><dt id="ientry-idm17472">XkbAllocDeviceLedInfo, <a class="indexterm" href="#XkbAllocDeviceLedInfo">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></dt><dt id="ientry-idm9014">XkbAllocGeomColors, <a class="indexterm" href="#XkbAllocGeomColors">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9555">XkbAllocGeomDoodads, <a class="indexterm" href="#XkbAllocGeomDoodads">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9644">XkbAllocGeometry, <a class="indexterm" href="#XkbAllocGeometry">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8944">XkbAllocGeomKeyAliases, <a class="indexterm" href="#XkbAllocGeomKeyAliases">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8809">XkbAllocGeomKeys, <a class="indexterm" href="#XkbAllocGeomKeys">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8741">XkbAllocGeomOutlines, <a class="indexterm" href="#XkbAllocGeomOutlines">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9488">XkbAllocGeomOverlayKeys, <a class="indexterm" href="#XkbAllocGeomOverlayKeys">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9421">XkbAllocGeomOverlayRows, <a class="indexterm" href="#XkbAllocGeomOverlayRows">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9354">XkbAllocGeomOverlays, <a class="indexterm" href="#XkbAllocGeomOverlays">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9082">XkbAllocGeomPoints, <a class="indexterm" href="#XkbAllocGeomPoints">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8876">XkbAllocGeomProps, <a class="indexterm" href="#XkbAllocGeomProps">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9287">XkbAllocGeomRows, <a class="indexterm" href="#XkbAllocGeomRows">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9582">XkbAllocGeomSectionDoodads, <a class="indexterm" href="#XkbAllocGeomSectionDoodads">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9220">XkbAllocGeomSections, <a class="indexterm" href="#XkbAllocGeomSections">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9151">XkbAllocGeomShapes, <a class="indexterm" href="#XkbAllocGeomShapes">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm3165">XkbAllocIndicatorMaps, <a class="indexterm" href="#XkbAllocIndicatorMaps">Allocating and Freeing Indicator Maps</a></dt><dt id="ientry-idm1905">XkbAllocKeyboard, <a class="indexterm" href="#XkbAllocKeyboard">Allocating and Freeing a Keyboard Description</a></dt><dt id="ientry-idm16082">XkbAllocNames, <a class="indexterm" href="#XkbAllocNames">Allocating and Freeing Symbolic Names</a></dt><dt id="ientry-idm10508">XkbAllocServerMap, <a class="indexterm" href="#XkbAllocServerMap">Allocating an Empty Server Map</a></dt><dt id="ientry-idm12256">XkbAnyAction, <a class="indexterm" href="#The_XkbAnyAction_Structure">The XkbAnyAction Structure</a></dt><dt id="ientry-idm843">XkbAnyEvent, <a class="indexterm" href="#Xkb_Event_Data_Structures">Xkb Event Data Structures</a></dt><dt id="ientry-idm15186">XkbApplyCompatMapToKey, <a class="indexterm" href="#XkbApplyCompatMapToKey">Using the Compatibility Map</a></dt><dt id="ientry-idm14199">XkbBehavior, <a class="indexterm" href="#The_XkbBehavior_Structure">The XkbBehavior Structure</a></dt><dt id="ientry-idm3487">XkbBell, <a class="indexterm" href="#XkbBell">Generating Named Bells</a></dt><dt id="ientry-idm3628">XkbBellEvent, <a class="indexterm" href="#XkbBellEvent">Generating Named Bell Events</a></dt><dt id="ientry-idm6455">XkbChangeControls, <a class="indexterm" href="#XkbChangeControls">The XkbControlsChangesRec Structure</a></dt><dt id="ientry-idm17957">XkbChangeDeviceInfo, <a class="indexterm" href="#XkbChangeDeviceInfo">Tracking Changes to Extension Devices</a></dt><dt id="ientry-idm3990">XkbChangeEnabledControls, <a class="indexterm" href="#XkbChangeEnabledControls">The EnabledControls Control</a></dt><dt id="ientry-idm2948">XkbChangeIndicators, <a class="indexterm" href="#XkbChangeIndicators">The XkbIndicatorChangesRec Structure</a></dt><dt id="ientry-idm10229">XkbChangeMap, <a class="indexterm" href="#XkbChangeMap">The XkbMapChangesRec Structure</a></dt><dt id="ientry-idm15924">XkbChangeNames, <a class="indexterm" href="#XkbChangeNames">The XkbNameChangesRec Structure</a></dt><dt id="ientry-idm11756">XkbChangeTypesOfKey, <a class="indexterm" href="#XkbChangeTypesOfKey">Changing the Number of Groups and Types Bound to a Key</a></dt><dt id="ientry-idm10678">XkbClientMapRec, <a class="indexterm" href="#The_XkbClientMapRec_Structure">The XkbClientMapRec Structure</a></dt><dt id="ientry-idm15344">XkbCompatMapNotifyEvent, <a class="indexterm" href="#Tracking_Changes_to_the_Compatibility_Map">Tracking Changes to the Compatibility Map</a></dt><dt id="ientry-idm14673">XkbCompatMapRec, <a class="indexterm" href="#The_XkbCompatMap_Structure">The XkbCompatMap Structure</a></dt><dt id="ientry-idm16449">XkbComponentListRec, <a class="indexterm" href="#XkbComponentListRec">Listing the Known Keyboard Components</a></dt><dt id="ientry-idm16452">XkbComponentNameRec, <a class="indexterm" href="#XkbComponentListRec">Listing the Known Keyboard Components</a></dt><dt id="ientry-idm16439">XkbComponentNamesRec, <a class="indexterm" href="#XkbComponentNamesRec">Listing the Known Keyboard Components</a></dt><dt id="ientry-idm8160">XkbComputeRowBounds, <a class="indexterm" href="#XkbComputeRowBounds">Using Keyboard Geometry</a></dt><dt id="ientry-idm8199">XkbComputeSectionBounds, <a class="indexterm" href="#XkbComputeSectionBounds">Using Keyboard Geometry</a></dt><dt id="ientry-idm8133">XkbComputeShapeBounds, <a class="indexterm" href="#XkbComputeShapeBounds">Using Keyboard Geometry</a></dt><dt id="ientry-idm8093">XkbComputeShapeTop, <a class="indexterm" href="#XkbComputeShapeTop">Using Keyboard Geometry</a></dt><dt id="ientry-idm6427">XkbControlsChangesRec, <a class="indexterm" href="#The_XkbControlsChangesRec_Structure">The XkbControlsChangesRec Structure</a></dt><dt id="ientry-idm6498">XkbControlsNotifyEvent, <a class="indexterm" href="#Tracking_Changes_to_Keyboard_Controls">Tracking Changes to Keyboard Controls</a></dt><dt id="ientry-idm5659">XkbControlsRec, <a class="indexterm" href="#The_XkbControlsRec_Structure">The XkbControlsRec Structure</a></dt><dt id="ientry-idm11155">XkbCopyKeyType, <a class="indexterm" href="#XkbCopyKeyType">Copying Key Types</a></dt><dt id="ientry-idm11197">XkbCopyKeyTypes, <a class="indexterm" href="#XkbCopyKeyTypes">Copying Key Types</a></dt><dt id="ientry-idm13473">XkbCtrlsAction, <a class="indexterm" href="#Actions_for_Changing_Boolean_Controls_State">Actions for Changing Boolean Controls State</a></dt><dt id="ientry-idm1731">XkbDescRec, <a class="indexterm" href="#The_XkbDescRec_Structure">The XkbDescRec Structure</a></dt><dt id="ientry-idm3407">XkbDeviceBell, <a class="indexterm" href="#XkbDeviceBell">Generating Named Bells</a></dt><dt id="ientry-idm3554">XkbDeviceBellEvent, <a class="indexterm" href="#XkbDeviceBellEvent">Generating Named Bell Events</a></dt><dt id="ientry-idm13873">XkbDeviceBtnAction, <a class="indexterm" href="#Actions_for_Generating_DeviceButtonPress_and_DeviceButtonRelease">Actions for Generating DeviceButtonPress and DeviceButtonRelease</a></dt><dt id="ientry-idm17862">XkbDeviceChangesRec, <a class="indexterm" href="#Tracking_Changes_to_Extension_Devices">Tracking Changes to Extension Devices</a></dt><dt id="ientry-idm16992">XkbDeviceInfoRec, <a class="indexterm" href="#XkbDeviceInfoRec">XkbDeviceInfoRec</a></dt><dt id="ientry-idm17865">XkbDeviceLedChangesRec, <a class="indexterm" href="#Tracking_Changes_to_Extension_Devices">Tracking Changes to Extension Devices</a></dt><dt id="ientry-idm16995">XkbDeviceLedInfoRec, <a class="indexterm" href="#XkbDeviceInfoRec">XkbDeviceInfoRec</a></dt><dt id="ientry-idm13970">XkbDeviceValuatorAction, <a class="indexterm" href="#Actions_for_Simulating_Events_from_Device_Valuators">Actions for Simulating Events from Device Valuators</a></dt><dt id="ientry-idm1112">XkbEvent, <a class="indexterm" href="#Unified_Xkb_Event_Type">Unified Xkb Event Type</a></dt><dt id="ientry-idm17824">XkbExtensionDeviceNotifyEvent, <a class="indexterm" href="#XkbExtensionDeviceNotify_Event">XkbExtensionDeviceNotify Event</a></dt><dt id="ientry-idm8231">XkbFindOverlayForKey, <a class="indexterm" href="#XkbFindOverlayForKey">Using Keyboard Geometry</a></dt><dt id="ientry-idm3755">XkbForceBell, <a class="indexterm" href="#XkbForceBell">Forcing a Server-Generated Bell</a></dt><dt id="ientry-idm3690">XkbForceDeviceBell, <a class="indexterm" href="#XkbForceDeviceBell">Forcing a Server-Generated Bell</a></dt><dt id="ientry-idm10455">XkbFreeClientMap, <a class="indexterm" href="#XkbFreeClientMap">Freeing a Client Map</a></dt><dt id="ientry-idm15455">XkbFreeCompatMap, <a class="indexterm" href="#XkbFreeCompatMap">Allocating and Freeing the Compatibility Map</a></dt><dt id="ientry-idm16466">XkbFreeComponentList, <a class="indexterm" href="#XkbFreeComponentList">Listing the Known Keyboard Components</a></dt><dt id="ientry-idm6710">XkbFreeControls, <a class="indexterm" href="#XkbFreeControls">Allocating and Freeing an XkbControlsRec</a></dt><dt id="ientry-idm17593">XkbFreeDeviceInfo, <a class="indexterm" href="#XkbFreeDeviceInfo">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></dt><dt id="ientry-idm9041">XkbFreeGeomColors, <a class="indexterm" href="#XkbFreeGeomColors">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9609">XkbFreeGeomDoodads, <a class="indexterm" href="#XkbFreeGeomDoodads">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9670">XkbFreeGeometry, <a class="indexterm" href="#XkbFreeGeometry">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8971">XkbFreeGeomKeyAliases, <a class="indexterm" href="#XkbFreeGeomKeyAliases">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8835">XkbFreeGeomKeys, <a class="indexterm" href="#XkbFreeGeomKeys">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8769">XkbFreeGeomOutlines, <a class="indexterm" href="#XkbFreeGeomOutlines">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9514">XkbFreeGeomOverlayKeys, <a class="indexterm" href="#XkbFreeGeomOverlayKeys">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9447">XkbFreeGeomOverlayRows, <a class="indexterm" href="#XkbFreeGeomOverlayRows">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9380">XkbFreeGeomOverlays, <a class="indexterm" href="#XkbFreeGeomOverlays">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9110">XkbFreeGeomPoints, <a class="indexterm" href="#XkbFreeGeomPoints">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm8903">XkbFreeGeomProperties, <a class="indexterm" href="#XkbFreeGeomProperties">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9313">XkbFreeGeomRows, <a class="indexterm" href="#XkbFreeGeomRows">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9246">XkbFreeGeomSections, <a class="indexterm" href="#XkbFreeGeomSections">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm9179">XkbFreeGeomShapes, <a class="indexterm" href="#XkbFreeGeomShapes">Allocating and Freeing Geometry Components</a></dt><dt id="ientry-idm3193">XkbFreeIndicatorMaps, <a class="indexterm" href="#XkbFreeIndicatorMaps">Allocating and Freeing Indicator Maps</a></dt><dt id="ientry-idm1921">XkbFreeKeyboard, <a class="indexterm" href="#XkbFreeKeyboard">Allocating and Freeing a Keyboard Description</a></dt><dt id="ientry-idm16129">XkbFreeNames, <a class="indexterm" href="#XkbFreeNames">Allocating and Freeing Symbolic Names</a></dt><dt id="ientry-idm10614">XkbFreeServerMap, <a class="indexterm" href="#XkbFreeServerMap">Freeing a Server Map</a></dt><dt id="ientry-idm7604">XkbGeometryRec, <a class="indexterm" href="#XkbGeometryRec">Keyboard Geometry</a></dt><dt id="ientry-idm4639">XkbGetAccessXTimeout, <a class="indexterm" href="#XkbGetAccessXTimeout">The AccessXTimeout Control</a></dt><dt id="ientry-idm4209">XkbGetAutoRepeatRate, <a class="indexterm" href="#XkbGetAutoRepeatRate">The RepeatKeys Control</a></dt><dt id="ientry-idm4061">XkbGetAutoResetControls, <a class="indexterm" href="#XkbGetAutoResetControls">The AutoReset Control</a></dt><dt id="ientry-idm5158">XkbGetBounceKeysDelay, <a class="indexterm" href="#XkbGetBounceKeysDelay">The BounceKeys Control</a></dt><dt id="ientry-idm14946">XkbGetCompatMap, <a class="indexterm" href="#XkbGetCompatMap">Getting Compatibility Map Components From the Server</a></dt><dt id="ientry-idm6284">XkbGetControls, <a class="indexterm" href="#XkbGetControls">Querying Controls</a></dt><dt id="ientry-idm6607">XkbGetControlsChanges, <a class="indexterm" href="#XkbGetControlsChanges">Tracking Changes to Keyboard Controls</a></dt><dt id="ientry-idm4341">XkbGetDetectableAutorepeat, <a class="indexterm" href="#XkbGetDetectableAutorepeat">The DetectableAutorepeat Control</a></dt><dt id="ientry-idm17246">XkbGetDeviceButtonActions, <a class="indexterm" href="#XkbGetDeviceButtonActions">Querying Xkb Features for Non-KeyClass Input Extension Devices</a></dt><dt id="ientry-idm17131">XkbGetDeviceInfo, <a class="indexterm" href="#XkbGetDeviceInfo">Querying Xkb Features for Non-KeyClass Input Extension Devices</a></dt><dt id="ientry-idm17921">XkbGetDeviceInfoChanges, <a class="indexterm" href="#XkbGetDeviceInfoChanges">Tracking Changes to Extension Devices</a></dt><dt id="ientry-idm17323">XkbGetDeviceLedInfo, <a class="indexterm" href="#XkbGetDeviceLedInfo">Querying Xkb Features for Non-KeyClass Input Extension Devices</a></dt><dt id="ientry-idm8016">XkbGetGeometry, <a class="indexterm" href="#XkbGetGeometry">Getting Keyboard Geometry From the Server</a></dt><dt id="ientry-idm3103">XkbGetIndicatorChanges, <a class="indexterm" href="#XkbGetIndicatorChanges">Tracking Changes to Indicator State or Map</a></dt><dt id="ientry-idm2609">XkbGetIndicatorMap, <a class="indexterm" href="#XkbGetIndicatorMap">Getting Indicator Information by Index</a></dt><dt id="ientry-idm2564">XkbGetIndicatorState, <a class="indexterm" href="#XkbGetIndicatorState">Getting Indicator State</a></dt><dt id="ientry-idm14057">XkbGetKeyActions, <a class="indexterm" href="#XkbGetKeyActions">Obtaining Key Actions for Keys from the Server</a></dt><dt id="ientry-idm14269">XkbGetKeyBehaviors, <a class="indexterm" href="#XkbGetKeyBehaviors">Obtaining Key Behaviors for Keys from the Server</a></dt><dt id="ientry-idm1850">XkbGetKeyboard, <a class="indexterm" href="#XkbGetKeyboard">Obtaining a Keyboard Description from the Server</a>, <a class="indexterm" href="#XkbGetKeyboard">Obtaining a Keyboard Description from the Server</a></dt><dt id="ientry-idm16587">XkbGetKeyboardByName, <a class="indexterm" href="#XkbGetKeyboardByName">Building a Keyboard Description Using the Server Database</a></dt><dt id="ientry-idm14398">XkbGetKeyExplicitComponents, <a class="indexterm" href="#XkbGetKeyExplicitComponents">Obtaining Explicit Components for Keys from the Server</a></dt><dt id="ientry-idm11965">XkbGetKeyModifierMap, <a class="indexterm" href="#XkbGetKeyModifierMap">Getting the Per-Key Modifier Map from the Server</a></dt><dt id="ientry-idm11694">XkbGetKeySyms, <a class="indexterm" href="#XkbGetKeySyms">Getting the Symbol Map for Keys from the Server</a></dt><dt id="ientry-idm11012">XkbGetKeyTypes, <a class="indexterm" href="#XkbGetKeyTypes">Getting Key Types from the Server</a></dt><dt id="ientry-idm14567">XkbGetKeyVirtualModMap, <a class="indexterm" href="#XkbGetKeyVirtualModMap">Obtaining Per-Key Virtual Modifier Mappings from the Server</a></dt><dt id="ientry-idm9806">XkbGetMap, <a class="indexterm" href="#XkbGetMap">Getting Map Components from the Server</a></dt><dt id="ientry-idm16038">XkbGetNameChanges, <a class="indexterm" href="#XkbGetNameChanges">Tracking Name Changes</a></dt><dt id="ientry-idm8049">XkbGetNamedGeometry, <a class="indexterm" href="#XkbGetNamedGeometry">Getting Keyboard Geometry From the Server</a></dt><dt id="ientry-idm2666">XkbGetNamedIndicator, <a class="indexterm" href="#XkbGetNamedIndicator">Getting Indicator Information by Name</a></dt><dt id="ientry-idm15699">XkbGetNames, <a class="indexterm" href="#XkbGetNames">Getting Symbolic Names From the Server</a></dt><dt id="ientry-idm6772">XkbGetPerClientControls, <a class="indexterm" href="#XkbGetPerClientControls">The Miscellaneous Per-client Controls</a></dt><dt id="ientry-idm5059">XkbGetSlowKeysDelay, <a class="indexterm" href="#XkbGetSlowKeysDelay">The SlowKeys Control</a></dt><dt id="ientry-idm1555">XkbGetState, <a class="indexterm" href="#XkbGetState">Determining Keyboard State</a></dt><dt id="ientry-idm5303">XkbGetStickyKeysOptions, <a class="indexterm" href="#XkbGetStickyKeysOptions">StickyKeys Options</a></dt><dt id="ientry-idm10005">XkbGetUpdatedMap, <a class="indexterm" href="#XkbGetUpdatedMap">Getting Map Components from the Server</a></dt><dt id="ientry-idm14512">XkbGetVirtualMods, <a class="indexterm" href="#XkbGetVirtualMods">Obtaining Virtual Modifier Bindings from the Server</a></dt><dt id="ientry-idm7059">XkbGetXlibControls, <a class="indexterm" href="#XkbGetXlibControls">Determining the State of the Library Controls</a></dt><dt id="ientry-idm12612">XkbGroupAction, <a class="indexterm" href="#Actions_for_Changing_Group_State">Actions for Changing Group State</a></dt><dt id="ientry-idm484">XkbIgnoreExtension, <a class="indexterm" href="#XkbIgnoreExtension">Disabling the Keyboard Extension</a></dt><dt id="ientry-idm2934">XkbIndicatorChangesRec, <a class="indexterm" href="#XkbIndicatorChangesRec">The XkbIndicatorChangesRec Structure</a></dt><dt id="ientry-idm3016">XkbIndicatorMapNotifyEvent, <a class="indexterm" href="#Tracking_Changes_to_Indicator_State_or_Map">Tracking Changes to Indicator State or Map</a></dt><dt id="ientry-idm2218">XkbIndicatorMapRec, <a class="indexterm" href="#XkbIndicatorMapRec">XkbIndicatorMapRec</a></dt><dt id="ientry-idm2198">XkbIndicatorRec, <a class="indexterm" href="#XkbIndicatorRec">XkbIndicatorRec</a></dt><dt id="ientry-idm3009">XkbIndicatorStateNotifyEvent, <a class="indexterm" href="#Tracking_Changes_to_Indicator_State_or_Map">Tracking Changes to Indicator State or Map</a></dt><dt id="ientry-idm10957">XkbInitCanonicalKeyTypes, <a class="indexterm" href="#XkbInitCanonicalKeyTypes">Initializing the Canonical Key Types in a New Client Map</a></dt><dt id="ientry-idm13145">XkbISOAction, <a class="indexterm" href="#Actions_for_Locking_Modifiers_and_Group">Actions for Locking Modifiers and Group</a></dt><dt id="ientry-idm12167">XkbKeyAction, <a class="indexterm" href="#XkbKeyAction">Key Actions</a></dt><dt id="ientry-idm12202">XkbKeyActionEntry, <a class="indexterm" href="#XkbKeyActionEntry">Key Actions</a></dt><dt id="ientry-idm12140">XkbKeyActionsPtr, <a class="indexterm" href="#XkbKeyActionsPtr">Key Actions</a></dt><dt id="ientry-idm15517">XkbKeyAliasRec, <a class="indexterm" href="#The_XkbNamesRec_Structure">The XkbNamesRec Structure</a></dt><dt id="ientry-idm7229">XkbKeycodeToKeysym, <a class="indexterm" href="#XkbKeycodeToKeysym">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm11430">XkbKeyGroupInfo, <a class="indexterm" href="#XkbKeyGroupInfo">Per-Key Group Information</a></dt><dt id="ientry-idm11515">XkbKeyGroupsWidth, <a class="indexterm" href="#XkbKeyGroupsWidth">Offset in to the Symbol Map</a></dt><dt id="ientry-idm11540">XkbKeyGroupWidth, <a class="indexterm" href="#XkbKeyGroupWidth">Offset in to the Symbol Map</a></dt><dt id="ientry-idm12086">XkbKeyHasActions, <a class="indexterm" href="#XkbKeyHasActions">Key Actions</a></dt><dt id="ientry-idm15514">XkbKeyNameRec, <a class="indexterm" href="#The_XkbNamesRec_Structure">The XkbNamesRec Structure</a></dt><dt id="ientry-idm12113">XkbKeyNumActions, <a class="indexterm" href="#XkbKeyNumActions">Key Actions</a></dt><dt id="ientry-idm11405">XkbKeyNumGroups, <a class="indexterm" href="#XkbKeyNumGroups">Per-Key Group Information</a></dt><dt id="ientry-idm11598">XkbKeyNumSyms, <a class="indexterm" href="#XkbKeyNumSyms">Offset in to the Symbol Map</a></dt><dt id="ientry-idm11648">XkbKeySymEntry, <a class="indexterm" href="#XkbKeySymEntry">Offset in to the Symbol Map</a></dt><dt id="ientry-idm11573">XkbKeySymsOffset, <a class="indexterm" href="#XkbKeySymsOffset">Offset in to the Symbol Map</a></dt><dt id="ientry-idm11623">XkbKeySymsPtr, <a class="indexterm" href="#XkbKeySymsPtr">Offset in to the Symbol Map</a></dt><dt id="ientry-idm7274">XkbKeysymToModifiers, <a class="indexterm" href="#XkbKeysymToModifiers">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm11321">XkbKeyType, <a class="indexterm" href="#XkbKeyType">Per-Key Key Type Indices</a></dt><dt id="ientry-idm11286">XkbKeyTypeIndex, <a class="indexterm" href="#XkbKeyTypeIndex">Per-Key Key Type Indices</a></dt><dt id="ientry-idm10696">XkbKeyTypeRec, <a class="indexterm" href="#Key_Types">Key Types</a></dt><dt id="ientry-idm15109">XkbKeyTypesForCoreSymbols, <a class="indexterm" href="#XkbKeyTypesForCoreSymbols">Using the Compatibility Map</a></dt><dt id="ientry-idm10699">XkbKTMapEntryRec, <a class="indexterm" href="#Key_Types">Key Types</a></dt><dt id="ientry-idm1510">XkbLatchGroup, <a class="indexterm" href="#XkbLatchGroup">Changing Groups</a></dt><dt id="ientry-idm1391">XkbLatchModifiers, <a class="indexterm" href="#XkbLatchModifiers">Changing Modifiers</a></dt><dt id="ientry-idm262">XkbLibraryVersion, <a class="indexterm" href="#XkbLibraryVersion">Determining Library Compatibility</a></dt><dt id="ientry-idm16378">XkbListComponents, <a class="indexterm" href="#XkbListComponents">Listing the Known Keyboard Components</a></dt><dt id="ientry-idm1473">XkbLockGroup, <a class="indexterm" href="#XkbLockGroup">Changing Groups</a></dt><dt id="ientry-idm1342">XkbLockModifiers, <a class="indexterm" href="#XkbLockModifiers">Changing Modifiers</a></dt><dt id="ientry-idm7372">XkbLookupKeyBinding, <a class="indexterm" href="#XkbLookupKeyBinding">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm7311">XkbLookupKeySym, <a class="indexterm" href="#XkbLookupKeySym">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm10111">XkbMapChangesRec, <a class="indexterm" href="#The_XkbMapChangesRec_Structure">The XkbMapChangesRec Structure</a></dt><dt id="ientry-idm10280">XkbMapNotifyEvent, <a class="indexterm" href="#Tracking_Changes_to_Map_Components">Tracking Changes to Map Components</a></dt><dt id="ientry-idm13622">XkbMessageAction, <a class="indexterm" href="#Actions_for_Generating_Messages">Actions for Generating Messages</a></dt><dt id="ientry-idm12407">XkbModAction, <a class="indexterm" href="#Actions_for_Changing_Modifiers_State">Actions for Changing Modifiers’ State</a></dt><dt id="ientry-idm12557">XkbModActionVMods, <a class="indexterm" href="#XkbModActionVMods">Actions for Changing Modifiers’ State</a></dt><dt id="ientry-idm2011">XkbModsRec, <a class="indexterm" href="#Modifier_Definitions">Modifier Definitions</a></dt><dt id="ientry-idm246">XkbName, <a class="indexterm" href="#Extension_Name">Extension Name</a></dt><dt id="ientry-idm15841">XkbNameChangesRec, <a class="indexterm" href="#The_XkbNameChangesRec_Structure">The XkbNameChangesRec Structure</a></dt><dt id="ientry-idm15967">XkbNamesNotifyEvent, <a class="indexterm" href="#Tracking_Name_Changes">Tracking Name Changes</a></dt><dt id="ientry-idm15520">XkbNamesRec, <a class="indexterm" href="#The_XkbNamesRec_Structure">The XkbNamesRec Structure</a></dt><dt id="ientry-idm16215">XkbNewKeyboardNotifyEvent, <a class="indexterm" href="#Replacing_a_Keyboard_On_the_Fly">Replacing a Keyboard “On the Fly”</a></dt><dt id="ientry-idm6566">XkbNoteControlsChanges, <a class="indexterm" href="#XkbNoteControlsChanges">Tracking Changes to Keyboard Controls</a></dt><dt id="ientry-idm17878">XkbNoteDeviceChanges, <a class="indexterm" href="#XkbNoteDeviceChanges">Tracking Changes to Extension Devices</a></dt><dt id="ientry-idm3063">XkbNoteIndicatorChanges, <a class="indexterm" href="#XkbNoteIndicatorChanges">Tracking Changes to Indicator State or Map</a></dt><dt id="ientry-idm15998">XkbNoteNameChanges, <a class="indexterm" href="#XkbNoteNameChanges">Tracking Name Changes</a></dt><dt id="ientry-idm384">XkbOpenDisplay, <a class="indexterm" href="#XkbOpenDisplay">Initializing the Keyboard Extension</a></dt><dt id="ientry-idm11457">XkbOutOfRangeGroupInfo, <a class="indexterm" href="#XkbOutOfRangeGroupInfo">Per-Key Group Information</a></dt><dt id="ientry-idm11477">XkbOutOfRangeGroupNumber, <a class="indexterm" href="#XkbOutOfRangeGroupNumber">Per-Key Group Information</a></dt><dt id="ientry-idm12768">XkbPtrAction, <a class="indexterm" href="#Actions_for_Moving_the_Pointer">Actions for Moving the Pointer</a></dt><dt id="ientry-idm12826">XkbPtrActionX, <a class="indexterm" href="#XkbPtrActionX">Actions for Moving the Pointer</a></dt><dt id="ientry-idm12846">XkbPtrActionY, <a class="indexterm" href="#XkbPtrActionY">Actions for Moving the Pointer</a></dt><dt id="ientry-idm12924">XkbPtrBtnAction, <a class="indexterm" href="#Actions_for_Simulating_Pointer_Button_Press_and_Release">Actions for Simulating Pointer Button Press and Release</a></dt><dt id="ientry-idm13039">XkbPtrDfltAction, <a class="indexterm" href="#Actions_for_Changing_the_Pointer_Button_Simulated">Actions for Changing the Pointer Button Simulated</a></dt><dt id="ientry-idm318">XkbQueryExtension, <a class="indexterm" href="#XkbQueryExtension">Initializing the Keyboard Extension</a></dt><dt id="ientry-idm13736">XkbRedirectKeyAction, <a class="indexterm" href="#Actions_for_Generating_a_Different_Keycode">Actions for Generating a Different Keycode</a></dt><dt id="ientry-idm7498">XkbRefreshKeyboardMapping, <a class="indexterm" href="#XkbRefreshKeyboardMapping">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm17557">XkbResizeDeviceButtonActions, <a class="indexterm" href="#XkbResizeDeviceButtonActions">Allocating, Initializing, and Freeing the XkbDeviceInfoRec
Structure</a></dt><dt id="ientry-idm14120">XkbResizeKeyActions, <a class="indexterm" href="#XkbResizeKeyActions">Changing the Number of Actions Bound to a Key</a></dt><dt id="ientry-idm11891">XkbResizeKeySyms, <a class="indexterm" href="#XkbResizeKeySyms">Changing the Number of Symbols Bound to a Key</a></dt><dt id="ientry-idm11066">XkbResizeKeyType, <a class="indexterm" href="#XkbResizeKeyType">Changing the Number of Levels in a Key Type</a></dt><dt id="ientry-idm13592">XkbSAActionSetCtrls, <a class="indexterm" href="#XkbSAActionSetCtrls">Actions for Changing Boolean Controls State</a></dt><dt id="ientry-idm12715">XkbSAGroup, <a class="indexterm" href="#XkbSAGroup">Actions for Changing Group State</a></dt><dt id="ientry-idm13095">XkbSAPtrDfltValue, <a class="indexterm" href="#XkbSAPtrDfltValue">Actions for Changing the Pointer Button Simulated</a></dt><dt id="ientry-idm13843">XkbSARedirectSetVMods, <a class="indexterm" href="#XkbSARedirectSetVMods">Actions for Generating a Different Keycode</a></dt><dt id="ientry-idm13790">XkbSARedirectSetVModsMask, <a class="indexterm" href="#XkbSARedirectSetVModsMask">Actions for Generating a Different Keycode</a></dt><dt id="ientry-idm13823">XkbSARedirectVMods, <a class="indexterm" href="#XkbSARedirectVMods">Actions for Generating a Different Keycode</a></dt><dt id="ientry-idm13770">XkbSARedirectVModsMask, <a class="indexterm" href="#XkbSARedirectVModsMask">Actions for Generating a Different Keycode</a></dt><dt id="ientry-idm13423">XkbSAScreen, <a class="indexterm" href="#XkbSAScreen">Actions for Changing the Active Screen</a></dt><dt id="ientry-idm12734">XkbSASetGroup, <a class="indexterm" href="#XkbSASetGroup">Actions for Changing Group State</a></dt><dt id="ientry-idm13114">XkbSASetPtrDfltValue, <a class="indexterm" href="#XkbSASetPtrDfltValue">Actions for Changing the Pointer Button Simulated</a></dt><dt id="ientry-idm13442">XkbSASetScreen, <a class="indexterm" href="#XkbSASetScreen">Actions for Changing the Active Screen</a></dt><dt id="ientry-idm949">XkbSelectEventDetails, <a class="indexterm" href="#XkbSelectEventDetails">Selecting Xkb Events</a></dt><dt id="ientry-idm884">XkbSelectEvents, <a class="indexterm" href="#XkbSelectEvents">Selecting Xkb Events</a></dt><dt id="ientry-idm12034">XkbServerMapRec, <a class="indexterm" href="#XkbServerMapRec">Xkb Server Keyboard Mapping</a></dt><dt id="ientry-idm4714">XkbSetAccessXTimeout, <a class="indexterm" href="#XkbSetAccessXTimeout">The AccessXTimeout Control</a></dt><dt id="ientry-idm4256">XkbSetAutoRepeatRate, <a class="indexterm" href="#XkbSetAutoRepeatRate">The RepeatKeys Control</a></dt><dt id="ientry-idm4101">XkbSetAutoResetControls, <a class="indexterm" href="#XkbSetAutoResetControls">The AutoReset Control</a></dt><dt id="ientry-idm5200">XkbSetBounceKeysDelay, <a class="indexterm" href="#XkbSetBounceKeysDelay">The BounceKeys Control</a></dt><dt id="ientry-idm15228">XkbSetCompatMap, <a class="indexterm" href="#XkbSetCompatMap">Changing the Server’s Compatibility Map</a></dt><dt id="ientry-idm6362">XkbSetControls, <a class="indexterm" href="#XkbSetControls">Changing Controls</a></dt><dt id="ientry-idm17999">XkbSetDebuggingFlags, <a class="indexterm" href="#XkbSetDebuggingFlags">Debugging Aids</a></dt><dt id="ientry-idm4381">XkbSetDetectableAutorepeat, <a class="indexterm" href="#XkbSetDetectableAutorepeat">The DetectableAutorepeat Control</a></dt><dt id="ientry-idm17758">XkbSetDeviceButtonActions, <a class="indexterm" href="#XkbSetDeviceButtonActions">Setting Xkb Features for Non-KeyClass Input Extension Devices</a></dt><dt id="ientry-idm17672">XkbSetDeviceInfo, <a class="indexterm" href="#XkbSetDeviceInfo">Setting Xkb Features for Non-KeyClass Input Extension Devices</a></dt><dt id="ientry-idm5470">XkbSetIgnoreLockMods, <a class="indexterm" href="#XkbSetIgnoreLockMods">The IgnoreLockMods Control</a></dt><dt id="ientry-idm2796">XkbSetIndicatorMap, <a class="indexterm" href="#XkbSetIndicatorMap">Changing Indicator Maps by Index</a></dt><dt id="ientry-idm10058">XkbSetMap, <a class="indexterm" href="#XkbSetMap">Changing Map Components in the Server</a></dt><dt id="ientry-idm12578">XkbSetModActionVMods, <a class="indexterm" href="#XkbSetModActionVMods">Actions for Changing Modifiers’ State</a></dt><dt id="ientry-idm2842">XkbSetNamedIndicator, <a class="indexterm" href="#XkbSetNamedIndicator">Changing Indicator Maps by Name</a></dt><dt id="ientry-idm15777">XkbSetNames, <a class="indexterm" href="#XkbSetNames">Changing Symbolic Names on the Server</a></dt><dt id="ientry-idm6803">XkbSetPerClientControls, <a class="indexterm" href="#XkbSetPerClientControls">The Miscellaneous Per-client Controls</a></dt><dt id="ientry-idm12866">XkbSetPtrActionX, <a class="indexterm" href="#XkbSetPtrActionX">Actions for Moving the Pointer</a></dt><dt id="ientry-idm12894">XkbSetPtrActionY, <a class="indexterm" href="#XkbSetPtrActionY">Actions for Moving the Pointer</a></dt><dt id="ientry-idm5579">XkbSetServerInternalMods, <a class="indexterm" href="#XkbSetServerInternalMods">The InternalMods Control</a></dt><dt id="ientry-idm5102">XkbSetSlowKeysDelay, <a class="indexterm" href="#XkbSetSlowKeysDelay">The SlowKeys Control</a></dt><dt id="ientry-idm5352">XkbSetStickyKeysOptions, <a class="indexterm" href="#XkbSetStickyKeysOptions">StickyKeys Options</a></dt><dt id="ientry-idm7081">XkbSetXlibControls, <a class="indexterm" href="#XkbSetXlibControls">Changing the State of the Library Controls</a></dt><dt id="ientry-idm1595">XkbStateNotifyEvent, <a class="indexterm" href="#Tracking_Keyboard_State">Tracking Keyboard State</a></dt><dt id="ientry-idm1546">XkbStateRec, <a class="indexterm" href="#Determining_Keyboard_State">Determining Keyboard State</a></dt><dt id="ientry-idm13380">XkbSwitchScreenAction, <a class="indexterm" href="#Actions_for_Changing_the_Active_Screen">Actions for Changing the Active Screen</a></dt><dt id="ientry-idm14778">XkbSymInterpretRec, <a class="indexterm" href="#Symbol_Interpretations__the_XkbSymInterpretRec_Structure">Symbol Interpretations — the XkbSymInterpretRec Structure</a></dt><dt id="ientry-idm11248">XkbSymMapRec, <a class="indexterm" href="#Key_Symbol_Map">Key Symbol Map</a></dt><dt id="ientry-idm7528">XkbTranslateKeyCode, <a class="indexterm" href="#XkbTranslateKeyCode">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm7435">XkbTranslateKeySym, <a class="indexterm" href="#XkbTranslateKeySym">Xkb Event and Keymap Functions</a></dt><dt id="ientry-idm15032">XkbUpdateMapFromCore, <a class="indexterm" href="#XkbUpdateMapFromCore">Using the Compatibility Map</a></dt><dt id="ientry-idm642">XkbUseCoreKbd, <a class="indexterm" href="#XkbUseCoreKbd">Display and Device Specifications in Function Calls</a></dt><dt id="ientry-idm2072">XkbVirtualModsToReal, <a class="indexterm" href="#XkbVirtualModsToReal">Virtual Modifier Key Mapping</a></dt><dt id="ientry-idm7037">XkbXlibControlsImplemented, <a class="indexterm" href="#XkbXlibControlsImplemented">Determining Which Library Controls are Implemented</a></dt><dt id="ientry-idm7179">XKeycodeToKeysym, <a class="indexterm" href="#XKeycodeToKeysym">X Library Functions Affected by Xkb</a></dt><dt id="ientry-idm7187">XKeysymToKeycode, <a class="indexterm" href="#XKeysymToKeycode">X Library Functions Affected by Xkb</a></dt><dt id="ientry-idm7193">XLookupKeysym, <a class="indexterm" href="#XLookupKeysym">X Library Functions Affected by Xkb</a></dt><dt id="ientry-idm6861">XLookupString, <a class="indexterm" href="#X_Library_Controls">X Library Controls</a>, <a class="indexterm" href="#XLookupString">X Library Functions Affected by Xkb</a></dt><dt id="ientry-idm7220">XRebindKeysym, <a class="indexterm" href="#XRebindKeysym">X Library Functions Affected by Xkb</a></dt><dt id="ientry-idm7211">XRefreshKeyboardMapping, <a class="indexterm" href="#XRefreshKeyboardMapping">X Library Functions Affected by Xkb</a></dt></dl></div></div></div></div></body></html>